{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../node_modules/@babel/traverse/node_modules/debug/src/common.js","../node_modules/@babel/traverse/node_modules/ms/index.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/index.js"],"names":["Object","defineProperty","exports","value","findParent","callback","path","this","parentPath","find","getFunctionParent","p","isFunction","getStatementParent","Array","isArray","container","isStatement","isProgram","isFile","Error","getEarliestCommonAncestorFrom","paths","getDeepestCommonAncestorFrom","deepest","i","ancestries","earliest","keys","t","VISITOR_KEYS","type","listKey","key","indexOf","parentKey","filter","length","lastCommonIndex","lastCommon","minDepth","Infinity","map","ancestry","unshift","first","depthLoop","shouldMatch","getAncestry","push","isAncestor","maybeDescendant","isDescendant","maybeAncestor","parent","inType","candidateTypes","node","obj","__esModule","default","cache","_getRequireWildcardCache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","require","WeakMap","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declar","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","add","_inferer","inferer","inferers","validParent","delete","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","name","isAnyTypeAnnotation","isUnionTypeAnnotation","types","type2","baseTypeStrictlyMatches","rightArg","left","right","isFlowBaseAnnotation","isGenericType","genericName","isGenericTypeAnnotation","isIdentifier","id","WeakSet","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","init","isCallExpression","scope","hasBinding","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","callee","TemplateLiteral","UnaryExpression","operator","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","pop","ParenthesizedExpression","AssignmentExpression","UpdateExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","identifier","ObjectExpression","RestElement","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","enumerable","_infererReference","buildMatchMemberExpression","resolve","is","returnType","isReferenced","binding","getBinding","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","violations","slice","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","nodes","_pathCache$get","resync","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","_cache","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","loc","message","_codeFrame","codeFrameColumns","start","line","column","code","program","body","expression","_index","removeProperties","replaceWith","removed","_index2","nodePath","isNodeType","isExpression","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","isExportDefaultDeclaration","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","ReferenceError","inList","validate","debug","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","callExpression","traverse","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","returnStatement","cloneNode","setData","assignmentExpression","arrowFunctionToExpression","needToAwaitFunction","hasType","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","_interopRequireDefault","Function","skip","VariableDeclaration","kind","bindings","getBindingIdentifiers","exprs","declarations","evaluateTruthy","res","evaluate","confident","state","deoptPath","seen","Map","evaluateCached","undefined","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","val","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","property","quasi","testResult","isExpressionWrapper","isReferencedIdentifier","end","hasValue","NaN","prefix","argument","isClass","arg","isArrayExpression","arr","elems","elemValue","isObjectExpression","props","prop","isObjectMethod","isSpreadElement","computed","wasConfident","leftConfident","rightConfident","Math","pow","context","func","global","args","apply","_evaluate","raw","str","elem","cooked","expr","String","toComputedKey","isProperty","isMethod","stringLiteral","ensureBlock","bodyNode","isBlockStatement","statements","stringPath","setup","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","generateUidIdentifier","objectExpression","unshiftContainer","hub","addHelper","thisExpression","memberExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","isSuper","superBinding","getSuperBinding","forEach","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","parts","numericLiteral","sequenceExpression","isClassMethod","superClass","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","method","valueIdent","cacheKey","data","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","ReferencedIdentifier","MetaProperty","matchesPattern","pattern","allowPartial","isStatic","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","includes","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","isExportDeclaration","references","allStatus","referencePaths","executionOrderCheckedNodes","dangerous","_resolve","constant","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","getProgramParent","isExecutionUncertain","maxIndex","opts","_call","fns","fn","then","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","visit","shouldSkip","shouldStop","skipKeys","skipKey","stop","SHOULD_SKIP","SHOULD_STOP","noScope","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","popContext","contexts","pushContext","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","REMOVED","self","isWhile","isSwitchCase","isVariableDeclaration","expressions","isBinary","insertBefore","nodes_","isExportNamedDeclaration","isDeclaration","isJSXElement","isForStatement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","queue","isPattern","assertExpression","temp","fromIndex","incrementBy","msg","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","isJSXIdentifier","react","isCompatTag","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","bindingIdentifierEquals","isCompatibleScope","_getAttachmentPath","targetScope","hasOwnBinding","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","getCompatibleScopes","attachTo","getAttachmentPath","declarator","variableDeclarator","variableDeclaration","attached","children","jsxExpressionContainer","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","r","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","ids","create","shift","_ids","declaration","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","c","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","label","unaryExpression","getStatementListCompletion","lastNormalCompletions","newContext","assign","statementCompletions","some","isDoExpression","isTryStatement","isCatchClause","isSwitchStatement","cases","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","formatArgs","useColors","namespace","module","humanize","diff","color","index","lastC","replace","save","namespaces","storage","setItem","removeItem","error","load","getItem","process","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","log","formatters","j","v","JSON","stringify","env","createDebug","prevTime","enableOverride","enabled","curr","Number","Date","ms","coerce","format","formatter","logFn","selectColor","extend","configurable","delimiter","newDebug","toNamespace","regexp","toString","substring","stack","disable","names","skips","join","enable","len","substr","test","hash","charCodeAt","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","exec","parseFloat","isFinite","long","fmtLong","fmtShort","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","trace","alias","_verified","validateVisitorMethods","TYPES","visitorKey","TypeError","oldVisitor","newVisitor","newFn","exit","checkPath","arguments","dest","src","Hub","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","grandparent","isBinding","isForXStatement","isScope","isBlockScoped","isVar","isUser","isPure","isFlow","importKind","exportKind","isObjectPattern","await","_renamer","_binding","globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","specifiers","isModuleSpecifier","local","properties","meta","openingElement","openingFragment","collectorVisitor","For","FOR_INIT_KEYS","registerBinding","Declaration","registerDeclaration","ForXStatement","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","getBlockParent","assignments","CatchClause","NOT_LOCAL_BINDING","params","param","block","labels","inited","uids","crawling","cached","_parent","isKey","generateUid","toIdentifier","_generateUid","hasLabel","hasGlobal","hasReference","defaultName","generateUidBasedOnNode","isThisExpression","dontPush","generateUidIdentifierBasedOnNode","buildError","oldName","newName","rename","sep","repeat","arrayLikeIsIterable","helperName","getLabel","registerLabel","specifier","reassign","bindingPath","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClassBody","elements","tag","isPureish","crawl","programParent","typeVisitors","addGlobal","ref","unique","blockHoist","dataKey","declarPath","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referenced","clearValue","hasDeoptedValue","_path","_scope","_hub","_context","_default","hasDenylistedType","cheap","traverseFast","clearNode","tree","denylistTypes","TraversalContext","priorityQueue","notPriority","trap","shouldVisit","visitQueue","visited","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","buildDebug","NodePath","def","SyntaxError","getPathLocation","targetNode","typeKey","virtualType"],"mappings":"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","file":"static/js/vendors-runtime-traverse.6ceb9106.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    callee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    callee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst globals = require(\"globals\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst buildDebug = require(\"debug\");\n\nconst debug = buildDebug(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;"],"sourceRoot":""}