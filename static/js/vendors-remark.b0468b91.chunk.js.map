{"version":3,"sources":["../node_modules/remark-parse/lib/util/interrupt.js","../node_modules/remark-parse/lib/util/normalize.js","../node_modules/remark-parse/lib/defaults.js","../node_modules/remark-parse/lib/util/get-indentation.js","../node_modules/remark-parse/lib/util/html.js","../node_modules/remark-parse/lib/locate/tag.js","../node_modules/remark-parse/lib/locate/link.js","../node_modules/remark-parse/index.js","../node_modules/remark-parse/lib/parser.js","../node_modules/remark-parse/lib/unescape.js","../node_modules/remark-parse/lib/decode.js","../node_modules/remark-parse/lib/tokenizer.js","../node_modules/remark-parse/lib/set-options.js","../node_modules/remark-parse/lib/parse.js","../node_modules/remark-parse/lib/tokenize/newline.js","../node_modules/remark-parse/lib/tokenize/code-indented.js","../node_modules/remark-parse/lib/tokenize/code-fenced.js","../node_modules/remark-parse/lib/tokenize/blockquote.js","../node_modules/remark-parse/lib/tokenize/heading-atx.js","../node_modules/remark-parse/lib/tokenize/thematic-break.js","../node_modules/remark-parse/lib/tokenize/list.js","../node_modules/remark-parse/lib/util/remove-indentation.js","../node_modules/remark-parse/lib/tokenize/heading-setext.js","../node_modules/remark-parse/lib/tokenize/html-block.js","../node_modules/remark-parse/lib/tokenize/footnote-definition.js","../node_modules/remark-parse/lib/tokenize/definition.js","../node_modules/remark-parse/lib/tokenize/table.js","../node_modules/remark-parse/lib/tokenize/paragraph.js","../node_modules/remark-parse/lib/tokenize/escape.js","../node_modules/remark-parse/lib/locate/escape.js","../node_modules/remark-parse/lib/tokenize/auto-link.js","../node_modules/remark-parse/lib/tokenize/url.js","../node_modules/remark-parse/lib/locate/url.js","../node_modules/remark-parse/lib/tokenize/html-inline.js","../node_modules/remark-parse/lib/tokenize/link.js","../node_modules/remark-parse/lib/tokenize/reference.js","../node_modules/remark-parse/lib/tokenize/strong.js","../node_modules/remark-parse/lib/locate/strong.js","../node_modules/remark-parse/lib/tokenize/emphasis.js","../node_modules/remark-parse/lib/locate/emphasis.js","../node_modules/remark-parse/lib/tokenize/delete.js","../node_modules/remark-parse/lib/locate/delete.js","../node_modules/remark-parse/lib/tokenize/code-inline.js","../node_modules/remark-parse/lib/locate/code-inline.js","../node_modules/remark-parse/lib/tokenize/break.js","../node_modules/remark-parse/lib/locate/break.js","../node_modules/remark-parse/lib/tokenize/text.js"],"names":["module","exports","interruptors","tokenizers","ctx","params","interruptor","config","fn","offset","bool","ignore","bools","count","length","index","undefined","options","apply","collapseWhiteSpace","require","value","toLowerCase","position","gfm","commonmark","footnotes","pedantic","blocks","size","indent","character","charAt","stops","characters","Math","floor","openTag","closeTag","openCloseTag","RegExp","tag","fromIndex","indexOf","link","image","unherit","xtend","Parser","parse","Local","prototype","this","data","toggle","vfileLocation","unescape","decode","tokenizer","doc","file","setOptions","inList","inBlock","inLink","atStart","toOffset","proto","keys","key","result","push","exitStart","enterList","enterLink","enterBlock","interruptParagraph","interruptList","interruptBlockquote","blockTokenizers","newline","indentedCode","fencedCode","blockquote","atxHeading","thematicBreak","list","setextHeading","html","footnote","definition","table","paragraph","inlineTokenizers","escape","autoLink","url","reference","strong","emphasis","deletion","code","break","text","blockMethods","inlineMethods","tokenizeBlock","tokenizeInline","tokenizeFactory","prev","queue","slice","join","entities","decoder","raw","normalize","warning","handleWarning","offsets","line","start","reason","message","handler","textContext","referenceContext","type","location","method","matched","valueLength","self","tokens","methods","column","eat","now","updatePosition","onlyAtStart","notInList","notInBlock","notInLink","fail","Error","eof","subvalue","lastIndex","getOffset","indentation","pos","last","Position","end","validateEat","substring","before","update","node","combined","n","l","concat","add","parent","children","MERGEABLE_NODES","mergeable","call","current","reset","test","arguments","escapes","defaults","removePosition","String","content","replace","EXPRESSION_LINE_BREAKS","charCodeAt","whitespace","silent","repeat","trim","blankQueue","subvalueQueue","contentQueue","CODE_INDENT","lang","fenceCount","marker","flag","exdentedContent","closing","exdentedClosing","settings","C_SPACE","C_TAB","C_NEWLINE","interrupt","rest","nextIndex","startIndex","prefixed","exit","currentLine","values","contents","indents","depth","C_HASH","markerCount","decimal","getIndent","removeIndent","markers","ordered","currentMarker","prevEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","isLoose","indented","interuptors","LIST_ORDERED_COMMONMARK_MARKERS","LIST_ORDERED_MARKERS","LIST_UNORDERED_MARKERS","parseInt","TAB_SIZE","trail","loose","listItem","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","task","pedanticListItem","normalListItem","checked","match","replacer","$0","max","bullet","lines","trimmedLines","$1","$2","$3","$4","Number","split","maximum","padding","minIndent","Infinity","matrix","unshift","shift","SETEXT_MARKERS","next","sequence","sequences","source","footnoteDefinition","EXPRESSION_INITIAL_TAB","subqueue","identifier","C_BRACKET_OPEN","C_BRACKET_CLOSE","beforeURL","beforeTitle","title","isEnclosedURLCharacter","delimiter","isUnclosedURLCharacter","nonTerminated","alignments","alignment","row","hasDash","align","cell","preamble","opening","lineCount","rows","lineIndex","pipeIndex","first","splice","TABLE_ALIGN_LEFT","trimTrailingLines","left","locate","locator","MAILTO","MAILTO_LENGTH","hasAtCharacter","substr","MAILTO_PROTOCOL","PROTOCOLS","PROTOCOLS_LENGTH","protocol","parenCount","nextCharacter","min","alphabetical","inlineHTML","EXPRESSION_HTML_LINK_OPEN","EXPRESSION_HTML_LINK_CLOSE","own","hasOwnProperty","C_BACKSLASH","C_PAREN_OPEN","C_PAREN_CLOSE","C_DOUBLE_QUOTE","C_SINGLE_QUOTE","LINK_MARKERS","COMMONMARK_LINK_MARKERS","closed","hasMarker","isImage","alt","T_LINK","T_IMAGE","T_FOOTNOTE","REFERENCE_TYPE_FULL","bracketed","intro","referenceType","asterisk","underscore","word","strikethrough","C_TILDE","previous","preceding","inlineCode","C_TICK","openingCount","found","tickQueue","hardBreak","name"],"mappings":"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","file":"static/js/vendors-remark.b0468b91.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = interrupt;\n\nfunction interrupt(interruptors, tokenizers, ctx, params) {\n  var bools = ['pedantic', 'commonmark'];\n  var count = bools.length;\n  var length = interruptors.length;\n  var index = -1;\n  var interruptor;\n  var config;\n  var fn;\n  var offset;\n  var bool;\n  var ignore;\n\n  while (++index < length) {\n    interruptor = interruptors[index];\n    config = interruptor[1] || {};\n    fn = interruptor[0];\n    offset = -1;\n    ignore = false;\n\n    while (++offset < count) {\n      bool = bools[offset];\n\n      if (config[bool] !== undefined && config[bool] !== ctx.options[bool]) {\n        ignore = true;\n        break;\n      }\n    }\n\n    if (ignore) {\n      continue;\n    }\n\n    if (tokenizers[fn].apply(ctx, params)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","'use strict';\n\nvar collapseWhiteSpace = require('collapse-white-space');\n\nmodule.exports = normalize;\n\n/* Normalize an identifier.  Collapses multiple white space\n * characters into a single space, and removes casing. */\nfunction normalize(value) {\n  return collapseWhiteSpace(value).toLowerCase();\n}\n","'use strict';\n\nmodule.exports = {\n  position: true,\n  gfm: true,\n  commonmark: false,\n  footnotes: false,\n  pedantic: false,\n  blocks: require('./block-elements.json')\n};\n","'use strict';\n\nmodule.exports = indentation;\n\n/* Map of characters, and their column length,\n * which can be used as indentation. */\nvar characters = {' ': 1, '\\t': 4};\n\n/* Gets indentation information for a line. */\nfunction indentation(value) {\n  var index = 0;\n  var indent = 0;\n  var character = value.charAt(index);\n  var stops = {};\n  var size;\n\n  while (character in characters) {\n    size = characters[character];\n\n    indent += size;\n\n    if (size > 1) {\n      indent = Math.floor(indent / size) * size;\n    }\n\n    stops[indent] = index;\n\n    character = value.charAt(++index);\n  }\n\n  return {indent: indent, stops: stops};\n}\n","'use strict';\n\nvar attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar unquoted = '[^\"\\'=<>`\\\\u0000-\\\\u0020]+';\nvar singleQuoted = '\\'[^\\']*\\'';\nvar doubleQuoted = '\"[^\"]*\"';\nvar attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';\nvar attribute = '(?:\\\\s+' + attributeName + '(?:\\\\s*=\\\\s*' + attributeValue + ')?)';\nvar openTag = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\nvar closeTag = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing = '<[?].*?[?]>';\nvar declaration = '<![A-Za-z]+\\\\s+[^>]*>';\nvar cdata = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nexports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');\n\nexports.tag = new RegExp('^(?:' +\n  openTag + '|' +\n  closeTag + '|' +\n  comment + '|' +\n  processing + '|' +\n  declaration + '|' +\n  cdata +\n')');\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('<', fromIndex);\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var link = value.indexOf('[', fromIndex);\n  var image = value.indexOf('![', fromIndex);\n\n  if (image === -1) {\n    return link;\n  }\n\n  /* Link can never be `-1` if an image is found, so we dont need\n   * to check for that :) */\n  return link < image ? link : image;\n}\n","'use strict';\n\nvar unherit = require('unherit');\nvar xtend = require('xtend');\nvar Parser = require('./lib/parser.js');\n\nmodule.exports = parse;\nparse.Parser = Parser;\n\nfunction parse(options) {\n  var Local = unherit(Parser);\n  Local.prototype.options = xtend(Local.prototype.options, this.data('settings'), options);\n  this.Parser = Local;\n}\n","'use strict';\n\nvar xtend = require('xtend');\nvar toggle = require('state-toggle');\nvar vfileLocation = require('vfile-location');\nvar unescape = require('./unescape');\nvar decode = require('./decode');\nvar tokenizer = require('./tokenizer');\n\nmodule.exports = Parser;\n\nfunction Parser(doc, file) {\n  this.file = file;\n  this.offset = {};\n  this.options = xtend(this.options);\n  this.setOptions({});\n\n  this.inList = false;\n  this.inBlock = false;\n  this.inLink = false;\n  this.atStart = true;\n\n  this.toOffset = vfileLocation(file).toOffset;\n  this.unescape = unescape(this, 'escape');\n  this.decode = decode(this);\n}\n\nvar proto = Parser.prototype;\n\n/* Expose core. */\nproto.setOptions = require('./set-options');\nproto.parse = require('./parse');\n\n/* Expose `defaults`. */\nproto.options = require('./defaults');\n\n/* Enter and exit helpers. */\nproto.exitStart = toggle('atStart', true);\nproto.enterList = toggle('inList', false);\nproto.enterLink = toggle('inLink', false);\nproto.enterBlock = toggle('inBlock', false);\n\n/* Nodes that can interupt a paragraph:\n *\n * ```markdown\n * A paragraph, followed by a thematic break.\n * ___\n * ```\n *\n * In the above example, the thematic break interupts\n * the paragraph. */\nproto.interruptParagraph = [\n  ['thematicBreak'],\n  ['atxHeading'],\n  ['fencedCode'],\n  ['blockquote'],\n  ['html'],\n  ['setextHeading', {commonmark: false}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n];\n\n/* Nodes that can interupt a list:\n *\n * ```markdown\n * - One\n * ___\n * ```\n *\n * In the above example, the thematic break interupts\n * the list. */\nproto.interruptList = [\n  ['atxHeading', {pedantic: false}],\n  ['fencedCode', {pedantic: false}],\n  ['thematicBreak', {pedantic: false}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n];\n\n/* Nodes that can interupt a blockquote:\n *\n * ```markdown\n * > A paragraph.\n * ___\n * ```\n *\n * In the above example, the thematic break interupts\n * the blockquote. */\nproto.interruptBlockquote = [\n  ['indentedCode', {commonmark: true}],\n  ['fencedCode', {commonmark: true}],\n  ['atxHeading', {commonmark: true}],\n  ['setextHeading', {commonmark: true}],\n  ['thematicBreak', {commonmark: true}],\n  ['html', {commonmark: true}],\n  ['list', {commonmark: true}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n];\n\n/* Handlers. */\nproto.blockTokenizers = {\n  newline: require('./tokenize/newline'),\n  indentedCode: require('./tokenize/code-indented'),\n  fencedCode: require('./tokenize/code-fenced'),\n  blockquote: require('./tokenize/blockquote'),\n  atxHeading: require('./tokenize/heading-atx'),\n  thematicBreak: require('./tokenize/thematic-break'),\n  list: require('./tokenize/list'),\n  setextHeading: require('./tokenize/heading-setext'),\n  html: require('./tokenize/html-block'),\n  footnote: require('./tokenize/footnote-definition'),\n  definition: require('./tokenize/definition'),\n  table: require('./tokenize/table'),\n  paragraph: require('./tokenize/paragraph')\n};\n\nproto.inlineTokenizers = {\n  escape: require('./tokenize/escape'),\n  autoLink: require('./tokenize/auto-link'),\n  url: require('./tokenize/url'),\n  html: require('./tokenize/html-inline'),\n  link: require('./tokenize/link'),\n  reference: require('./tokenize/reference'),\n  strong: require('./tokenize/strong'),\n  emphasis: require('./tokenize/emphasis'),\n  deletion: require('./tokenize/delete'),\n  code: require('./tokenize/code-inline'),\n  break: require('./tokenize/break'),\n  text: require('./tokenize/text')\n};\n\n/* Expose precedence. */\nproto.blockMethods = keys(proto.blockTokenizers);\nproto.inlineMethods = keys(proto.inlineTokenizers);\n\n/* Tokenizers. */\nproto.tokenizeBlock = tokenizer('block');\nproto.tokenizeInline = tokenizer('inline');\nproto.tokenizeFactory = tokenizer;\n\n/* Get all keys in `value`. */\nfunction keys(value) {\n  var result = [];\n  var key;\n\n  for (key in value) {\n    result.push(key);\n  }\n\n  return result;\n}\n","'use strict';\n\nmodule.exports = factory;\n\n/* Factory to de-escape a value, based on a list at `key`\n * in `ctx`. */\nfunction factory(ctx, key) {\n  return unescape;\n\n  /* De-escape a string using the expression at `key`\n   * in `ctx`. */\n  function unescape(value) {\n    var prev = 0;\n    var index = value.indexOf('\\\\');\n    var escape = ctx[key];\n    var queue = [];\n    var character;\n\n    while (index !== -1) {\n      queue.push(value.slice(prev, index));\n      prev = index + 1;\n      character = value.charAt(prev);\n\n      /* If the following character is not a valid escape,\n       * add the slash. */\n      if (!character || escape.indexOf(character) === -1) {\n        queue.push('\\\\');\n      }\n\n      index = value.indexOf('\\\\', prev);\n    }\n\n    queue.push(value.slice(prev));\n\n    return queue.join('');\n  }\n}\n","'use strict';\n\nvar xtend = require('xtend');\nvar entities = require('parse-entities');\n\nmodule.exports = factory;\n\n/* Factory to create an entity decoder. */\nfunction factory(ctx) {\n  decoder.raw = decodeRaw;\n\n  return decoder;\n\n  /* Normalize `position` to add an `indent`. */\n  function normalize(position) {\n    var offsets = ctx.offset;\n    var line = position.line;\n    var result = [];\n\n    while (++line) {\n      if (!(line in offsets)) {\n        break;\n      }\n\n      result.push((offsets[line] || 0) + 1);\n    }\n\n    return {\n      start: position,\n      indent: result\n    };\n  }\n\n  /* Handle a warning.\n   * See https://github.com/wooorm/parse-entities\n   * for the warnings. */\n  function handleWarning(reason, position, code) {\n    if (code === 3) {\n      return;\n    }\n\n    ctx.file.message(reason, position);\n  }\n\n  /* Decode `value` (at `position`) into text-nodes. */\n  function decoder(value, position, handler) {\n    entities(value, {\n      position: normalize(position),\n      warning: handleWarning,\n      text: handler,\n      reference: handler,\n      textContext: ctx,\n      referenceContext: ctx\n    });\n  }\n\n  /* Decode `value` (at `position`) into a string. */\n  function decodeRaw(value, position, options) {\n    return entities(value, xtend(options, {\n      position: normalize(position),\n      warning: handleWarning\n    }));\n  }\n}\n","'use strict';\n\nmodule.exports = factory;\n\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line ||\n      end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length;\n\n          method.apply(self, [eat, value]);\n\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the ranges offsets. */\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {line: line, column: column};\n\n      pos.offset = self.toOffset(pos);\n\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldnt happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this ' +\n            'warning on http://git.io/vg5Ft'\n          ),\n          now()\n        );\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasnt\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasnt\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        node.type in MERGEABLE_NODES &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n\n      validateEat(subvalue);\n\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n\n      value = value.substring(subvalue.length);\n\n      updatePosition(subvalue);\n\n      indent = indent();\n\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return result.position;\n      }\n    }\n  }\n}\n","'use strict';\n\nvar xtend = require('xtend');\nvar escapes = require('markdown-escapes');\nvar defaults = require('./defaults');\n\nmodule.exports = setOptions;\n\nfunction setOptions(options) {\n  var self = this;\n  var current = self.options;\n  var key;\n  var value;\n\n  if (options == null) {\n    options = {};\n  } else if (typeof options === 'object') {\n    options = xtend(options);\n  } else {\n    throw new Error(\n      'Invalid value `' + options + '` ' +\n      'for setting `options`'\n    );\n  }\n\n  for (key in defaults) {\n    value = options[key];\n\n    if (value == null) {\n      value = current[key];\n    }\n\n    if (\n      (key !== 'blocks' && typeof value !== 'boolean') ||\n      (key === 'blocks' && typeof value !== 'object')\n    ) {\n      throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');\n    }\n\n    options[key] = value;\n  }\n\n  self.options = options;\n  self.escape = escapes(options);\n\n  return self;\n}\n","'use strict';\n\nvar xtend = require('xtend');\nvar removePosition = require('unist-util-remove-position');\n\nmodule.exports = parse;\n\nvar C_NEWLINE = '\\n';\nvar EXPRESSION_LINE_BREAKS = /\\r\\n|\\r/g;\n\n/* Parse the bound file. */\nfunction parse() {\n  var self = this;\n  var value = String(self.file);\n  var start = {line: 1, column: 1, offset: 0};\n  var content = xtend(start);\n  var node;\n\n  /* Clean non-unix newlines: `\\r\\n` and `\\r` are all\n   * changed to `\\n`.  This should not affect positional\n   * information. */\n  value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE);\n\n  if (value.charCodeAt(0) === 0xFEFF) {\n    value = value.slice(1);\n\n    content.column++;\n    content.offset++;\n  }\n\n  node = {\n    type: 'root',\n    children: self.tokenizeBlock(value, content),\n    position: {\n      start: start,\n      end: self.eof || xtend(start)\n    }\n  };\n\n  if (!self.options.position) {\n    removePosition(node, true);\n  }\n\n  return node;\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = newline;\n\n/* Tokenise newline. */\nfunction newline(eat, value, silent) {\n  var character = value.charAt(0);\n  var length;\n  var subvalue;\n  var queue;\n  var index;\n\n  if (character !== '\\n') {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  index = 1;\n  length = value.length;\n  subvalue = character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n\n    if (character === '\\n') {\n      subvalue += queue;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  eat(subvalue);\n}\n","'use strict';\n\nvar repeat = require('repeat-string');\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = indentedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\n\nvar CODE_INDENT_COUNT = 4;\nvar CODE_INDENT = repeat(C_SPACE, CODE_INDENT_COUNT);\n\n/* Tokenise indented code. */\nfunction indentedCode(eat, value, silent) {\n  var index = -1;\n  var length = value.length;\n  var subvalue = '';\n  var content = '';\n  var subvalueQueue = '';\n  var contentQueue = '';\n  var character;\n  var blankQueue;\n  var indent;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (indent) {\n      indent = false;\n\n      subvalue += subvalueQueue;\n      content += contentQueue;\n      subvalueQueue = '';\n      contentQueue = '';\n\n      if (character === C_NEWLINE) {\n        subvalueQueue = character;\n        contentQueue = character;\n      } else {\n        subvalue += character;\n        content += character;\n\n        while (++index < length) {\n          character = value.charAt(index);\n\n          if (!character || character === C_NEWLINE) {\n            contentQueue = character;\n            subvalueQueue = character;\n            break;\n          }\n\n          subvalue += character;\n          content += character;\n        }\n      }\n    } else if (\n      character === C_SPACE &&\n      value.charAt(index + 1) === character &&\n      value.charAt(index + 2) === character &&\n      value.charAt(index + 3) === character\n    ) {\n      subvalueQueue += CODE_INDENT;\n      index += 3;\n      indent = true;\n    } else if (character === C_TAB) {\n      subvalueQueue += character;\n      indent = true;\n    } else {\n      blankQueue = '';\n\n      while (character === C_TAB || character === C_SPACE) {\n        blankQueue += character;\n        character = value.charAt(++index);\n      }\n\n      if (character !== C_NEWLINE) {\n        break;\n      }\n\n      subvalueQueue += blankQueue + character;\n      contentQueue += character;\n    }\n  }\n\n  if (content) {\n    if (silent) {\n      return true;\n    }\n\n    return eat(subvalue)({\n      type: 'code',\n      lang: null,\n      value: trim(content)\n    });\n  }\n}\n","'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\n\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}\n","'use strict';\n\nvar trim = require('trim');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = blockquote;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_GT = '>';\n\n/* Tokenise a blockquote. */\nfunction blockquote(eat, value, silent) {\n  var self = this;\n  var offsets = self.offset;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptBlockquote;\n  var now = eat.now();\n  var currentLine = now.line;\n  var length = value.length;\n  var values = [];\n  var contents = [];\n  var indents = [];\n  var add;\n  var index = 0;\n  var character;\n  var rest;\n  var nextIndex;\n  var content;\n  var line;\n  var startIndex;\n  var prefixed;\n  var exit;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_GT) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      index++;\n    }\n\n    if (value.charAt(index) === C_GT) {\n      index++;\n      prefixed = true;\n\n      if (value.charAt(index) === C_SPACE) {\n        index++;\n      }\n    } else {\n      index = startIndex;\n    }\n\n    content = value.slice(index, nextIndex);\n\n    if (!prefixed && !trim(content)) {\n      index = startIndex;\n      break;\n    }\n\n    if (!prefixed) {\n      rest = value.slice(index);\n\n      /* Check if the following code contains a possible\n       * block. */\n      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {\n        break;\n      }\n    }\n\n    line = startIndex === index ? content : value.slice(startIndex, nextIndex);\n\n    indents.push(index - startIndex);\n    values.push(line);\n    contents.push(content);\n\n    index = nextIndex + 1;\n  }\n\n  index = -1;\n  length = indents.length;\n  add = eat(values.join(C_NEWLINE));\n\n  while (++index < length) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];\n    currentLine++;\n  }\n\n  exit = self.enterBlock();\n  contents = self.tokenizeBlock(contents.join(C_NEWLINE), now);\n  exit();\n\n  return add({\n    type: 'blockquote',\n    children: contents\n  });\n}\n","'use strict';\n\nmodule.exports = atxHeading;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_HASH = '#';\n\nvar MAX_ATX_COUNT = 6;\n\nfunction atxHeading(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = -1;\n  var now = eat.now();\n  var subvalue = '';\n  var content = '';\n  var character;\n  var queue;\n  var depth;\n\n  /* Eat initial spacing. */\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n\n  /* Eat hashes. */\n  depth = 0;\n\n  while (++index <= length) {\n    character = value.charAt(index);\n\n    if (character !== C_HASH) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n    depth++;\n  }\n\n  if (depth > MAX_ATX_COUNT) {\n    return;\n  }\n\n  if (\n    !depth ||\n    (!settings.pedantic && value.charAt(index + 1) === C_HASH)\n  ) {\n    return;\n  }\n\n  length = value.length + 1;\n\n  /* Eat intermediate white-space. */\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  /* Exit when not in pedantic mode without spacing. */\n  if (\n    !settings.pedantic &&\n    queue.length === 0 &&\n    character &&\n    character !== C_NEWLINE\n  ) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  /* Eat content. */\n  subvalue += queue;\n  queue = '';\n  content = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n\n    if (\n      character !== C_SPACE &&\n      character !== C_TAB &&\n      character !== C_HASH\n    ) {\n      content += queue + character;\n      queue = '';\n      continue;\n    }\n\n    while (character === C_SPACE || character === C_TAB) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    while (character === C_HASH) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    while (character === C_SPACE || character === C_TAB) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    index--;\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n\n  return eat(subvalue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}\n","'use strict';\n\nmodule.exports = thematicBreak;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_DASH = '-';\n\nvar THEMATIC_BREAK_MARKER_COUNT = 3;\n\nfunction thematicBreak(eat, value, silent) {\n  var index = -1;\n  var length = value.length + 1;\n  var subvalue = '';\n  var character;\n  var marker;\n  var markerCount;\n  var queue;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n  }\n\n  if (\n    character !== C_ASTERISK &&\n    character !== C_DASH &&\n    character !== C_UNDERSCORE\n  ) {\n    return;\n  }\n\n  marker = character;\n  subvalue += character;\n  markerCount = 1;\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === marker) {\n      markerCount++;\n      subvalue += queue + marker;\n      queue = '';\n    } else if (character === C_SPACE) {\n      queue += character;\n    } else if (\n      markerCount >= THEMATIC_BREAK_MARKER_COUNT &&\n      (!character || character === C_NEWLINE)\n    ) {\n      subvalue += queue;\n\n      if (silent) {\n        return true;\n      }\n\n      return eat(subvalue)({type: 'thematicBreak'});\n    } else {\n      return;\n    }\n  }\n}\n","'use strict';\n\n/* eslint-disable max-params */\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\n\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - (size % TAB_SIZE);\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n\n  markers = commonmark ?\n    LIST_ORDERED_COMMONMARK_MARKERS :\n    LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - (size % TAB_SIZE);\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - (size % TAB_SIZE);\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (\n      currentMarker === C_ASTERISK ||\n      currentMarker === C_UNDERSCORE ||\n      currentMarker === C_DASH\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n\n  node.loose = isLoose;\n\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n      value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-items bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-items bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n\n  lines = value.split(C_NEWLINE);\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) +\n      lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n    return max + rest;\n  }\n}\n","'use strict';\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar getIndent = require('./get-indentation');\n\nmodule.exports = indentation;\n\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\n/* Remove the minimum indent from every line in `value`.\n * Supports both tab, spaced, and mixed indentation (as\n * well as possible). */\nfunction indentation(value, maximum) {\n  var values = value.split(C_NEWLINE);\n  var position = values.length + 1;\n  var minIndent = Infinity;\n  var matrix = [];\n  var index;\n  var indentation;\n  var stops;\n  var padding;\n\n  values.unshift(repeat(C_SPACE, maximum) + '!');\n\n  while (position--) {\n    indentation = getIndent(values[position]);\n\n    matrix[position] = indentation.stops;\n\n    if (trim(values[position]).length === 0) {\n      continue;\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent;\n      }\n    } else {\n      minIndent = Infinity;\n\n      break;\n    }\n  }\n\n  if (minIndent !== Infinity) {\n    position = values.length;\n\n    while (position--) {\n      stops = matrix[position];\n      index = minIndent;\n\n      while (index && !(index in stops)) {\n        index--;\n      }\n\n      if (\n        trim(values[position]).length !== 0 &&\n        minIndent &&\n        index !== minIndent\n      ) {\n        padding = C_TAB;\n      } else {\n        padding = '';\n      }\n\n      values[position] = padding + values[position].slice(\n        index in stops ? stops[index] + 1 : 0\n      );\n    }\n  }\n\n  values.shift();\n\n  return values.join(C_NEWLINE);\n}\n","'use strict';\n\nmodule.exports = setextHeading;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_EQUALS = '=';\nvar C_DASH = '-';\n\nvar MAX_HEADING_INDENT = 3;\n\n/* Map of characters which can be used to mark setext\n * headers, mapping to their corresponding depth. */\nvar SETEXT_MARKERS = {};\n\nSETEXT_MARKERS[C_EQUALS] = 1;\nSETEXT_MARKERS[C_DASH] = 2;\n\nfunction setextHeading(eat, value, silent) {\n  var self = this;\n  var now = eat.now();\n  var length = value.length;\n  var index = -1;\n  var subvalue = '';\n  var content;\n  var queue;\n  var character;\n  var marker;\n  var depth;\n\n  /* Eat initial indentation. */\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n\n  /* Eat content. */\n  content = '';\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      index--;\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      content += queue + character;\n      queue = '';\n    }\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n\n  /* Ensure the content is followed by a newline and a\n   * valid marker. */\n  character = value.charAt(++index);\n  marker = value.charAt(++index);\n\n  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {\n    return;\n  }\n\n  subvalue += character;\n\n  /* Eat Setext-line. */\n  queue = marker;\n  depth = SETEXT_MARKERS[marker];\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      if (character !== C_NEWLINE) {\n        return;\n      }\n\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}\n","'use strict';\n\nvar openCloseTag = require('../util/html').openCloseTag;\n\nmodule.exports = blockHTML;\n\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_LT = '<';\n\nfunction blockHTML(eat, value, silent) {\n  var self = this;\n  var blocks = self.options.blocks;\n  var length = value.length;\n  var index = 0;\n  var next;\n  var line;\n  var offset;\n  var character;\n  var count;\n  var sequence;\n  var subvalue;\n\n  var sequences = [\n    [/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true],\n    [/^<!--/, /-->/, true],\n    [/^<\\?/, /\\?>/, true],\n    [/^<![A-Za-z]/, />/, true],\n    [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n    [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n    [new RegExp(openCloseTag.source + '\\\\s*$'), /^$/, false]\n  ];\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_LT) {\n    return;\n  }\n\n  next = value.indexOf(C_NEWLINE, index + 1);\n  next = next === -1 ? length : next;\n  line = value.slice(index, next);\n  offset = -1;\n  count = sequences.length;\n\n  while (++offset < count) {\n    if (sequences[offset][0].test(line)) {\n      sequence = sequences[offset];\n      break;\n    }\n  }\n\n  if (!sequence) {\n    return;\n  }\n\n  if (silent) {\n    return sequence[2];\n  }\n\n  index = next;\n\n  if (!sequence[1].test(line)) {\n    while (index < length) {\n      next = value.indexOf(C_NEWLINE, index + 1);\n      next = next === -1 ? length : next;\n      line = value.slice(index + 1, next);\n\n      if (sequence[1].test(line)) {\n        if (line) {\n          index = next;\n        }\n\n        break;\n      }\n\n      index = next;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n\n  return eat(subvalue)({type: 'html', value: subvalue});\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar normalize = require('../util/normalize');\n\nmodule.exports = footnoteDefinition;\nfootnoteDefinition.notInList = true;\nfootnoteDefinition.notInBlock = true;\n\nvar C_BACKSLASH = '\\\\';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_CARET = '^';\nvar C_COLON = ':';\n\nvar EXPRESSION_INITIAL_TAB = /^( {4}|\\t)?/gm;\n\nfunction footnoteDefinition(eat, value, silent) {\n  var self = this;\n  var offsets = self.offset;\n  var index;\n  var length;\n  var subvalue;\n  var now;\n  var currentLine;\n  var content;\n  var queue;\n  var subqueue;\n  var character;\n  var identifier;\n  var add;\n  var exit;\n\n  if (!self.options.footnotes) {\n    return;\n  }\n\n  index = 0;\n  length = value.length;\n  subvalue = '';\n  now = eat.now();\n  currentLine = now.line;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  if (\n    value.charAt(index) !== C_BRACKET_OPEN ||\n    value.charAt(index + 1) !== C_CARET\n  ) {\n    return;\n  }\n\n  subvalue += C_BRACKET_OPEN + C_CARET;\n  index = subvalue.length;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      break;\n    } else if (character === C_BACKSLASH) {\n      queue += character;\n      index++;\n      character = value.charAt(index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (\n    !queue ||\n    value.charAt(index) !== C_BRACKET_CLOSE ||\n    value.charAt(index + 1) !== C_COLON\n  ) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  identifier = normalize(queue);\n  subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n  index = subvalue.length;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  queue = '';\n  content = '';\n  subqueue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      subqueue = character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_NEWLINE) {\n          break;\n        }\n\n        subqueue += character;\n        index++;\n      }\n\n      queue += subqueue;\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE) {\n          break;\n        }\n\n        subqueue += character;\n        index++;\n      }\n\n      if (subqueue.length === 0) {\n        break;\n      }\n\n      queue += subqueue;\n    }\n\n    if (queue) {\n      content += queue;\n      queue = '';\n    }\n\n    content += character;\n    index++;\n  }\n\n  subvalue += content;\n\n  content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + line.length;\n    currentLine++;\n\n    return '';\n  });\n\n  add = eat(subvalue);\n\n  exit = self.enterBlock();\n  content = self.tokenizeBlock(content, now);\n  exit();\n\n  return add({\n    type: 'footnoteDefinition',\n    identifier: identifier,\n    children: content\n  });\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar normalize = require('../util/normalize');\n\nmodule.exports = definition;\ndefinition.notInList = true;\ndefinition.notInBlock = true;\n\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\nvar C_BACKSLASH = '\\\\';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_COLON = ':';\nvar C_LT = '<';\nvar C_GT = '>';\n\nfunction definition(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var beforeURL;\n  var beforeTitle;\n  var queue;\n  var character;\n  var test;\n  var identifier;\n  var url;\n  var title;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      break;\n    } else if (character === C_BACKSLASH) {\n      queue += character;\n      index++;\n      character = value.charAt(index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (\n    !queue ||\n    value.charAt(index) !== C_BRACKET_CLOSE ||\n    value.charAt(index + 1) !== C_COLON\n  ) {\n    return;\n  }\n\n  identifier = queue;\n  subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n  index = subvalue.length;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character !== C_TAB &&\n      character !== C_SPACE &&\n      character !== C_NEWLINE\n    ) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!isEnclosedURLCharacter(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === isEnclosedURLCharacter.delimiter) {\n      subvalue += C_LT + queue + character;\n      index++;\n    } else {\n      if (commonmark) {\n        return;\n      }\n\n      index -= queue.length + 1;\n      queue = '';\n    }\n  }\n\n  if (!queue) {\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!isUnclosedURLCharacter(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    subvalue += queue;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  url = queue;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character !== C_TAB &&\n      character !== C_SPACE &&\n      character !== C_NEWLINE\n    ) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  test = null;\n\n  if (character === C_DOUBLE_QUOTE) {\n    test = C_DOUBLE_QUOTE;\n  } else if (character === C_SINGLE_QUOTE) {\n    test = C_SINGLE_QUOTE;\n  } else if (character === C_PAREN_OPEN) {\n    test = C_PAREN_CLOSE;\n  }\n\n  if (!test) {\n    queue = '';\n    index = subvalue.length;\n  } else if (queue) {\n    subvalue += queue + character;\n    index = subvalue.length;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === test) {\n        break;\n      }\n\n      if (character === C_NEWLINE) {\n        index++;\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE || character === test) {\n          return;\n        }\n\n        queue += C_NEWLINE;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character !== test) {\n      return;\n    }\n\n    beforeTitle = subvalue;\n    subvalue += queue + character;\n    index++;\n    title = queue;\n    queue = '';\n  } else {\n    return;\n  }\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (!character || character === C_NEWLINE) {\n    if (silent) {\n      return true;\n    }\n\n    beforeURL = eat(beforeURL).test().end;\n    url = self.decode.raw(self.unescape(url), beforeURL, {nonTerminated: false});\n\n    if (title) {\n      beforeTitle = eat(beforeTitle).test().end;\n      title = self.decode.raw(self.unescape(title), beforeTitle);\n    }\n\n    return eat(subvalue)({\n      type: 'definition',\n      identifier: normalize(identifier),\n      title: title || null,\n      url: url\n    });\n  }\n}\n\n/* Check if `character` can be inside an enclosed URI. */\nfunction isEnclosedURLCharacter(character) {\n  return character !== C_GT &&\n    character !== C_BRACKET_OPEN &&\n    character !== C_BRACKET_CLOSE;\n}\n\nisEnclosedURLCharacter.delimiter = C_GT;\n\n/* Check if `character` can be inside an unclosed URI. */\nfunction isUnclosedURLCharacter(character) {\n  return character !== C_BRACKET_OPEN &&\n    character !== C_BRACKET_CLOSE &&\n    !whitespace(character);\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\n\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {type: 'tableRow', children: []};\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}\n","'use strict';\n\nvar trim = require('trim');\nvar decimal = require('is-decimal');\nvar trimTrailingLines = require('trim-trailing-lines');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = paragraph;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\n\nvar TAB_SIZE = 4;\n\n/* Tokenise paragraph. */\nfunction paragraph(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var commonmark = settings.commonmark;\n  var gfm = settings.gfm;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptParagraph;\n  var index = value.indexOf(C_NEWLINE);\n  var length = value.length;\n  var position;\n  var subvalue;\n  var character;\n  var size;\n  var now;\n\n  while (index < length) {\n    /* Eat everything if theres no following newline. */\n    if (index === -1) {\n      index = length;\n      break;\n    }\n\n    /* Stop if the next character is NEWLINE. */\n    if (value.charAt(index + 1) === C_NEWLINE) {\n      break;\n    }\n\n    /* In commonmark-mode, following indented lines\n     * are part of the paragraph. */\n    if (commonmark) {\n      size = 0;\n      position = index + 1;\n\n      while (position < length) {\n        character = value.charAt(position);\n\n        if (character === C_TAB) {\n          size = TAB_SIZE;\n          break;\n        } else if (character === C_SPACE) {\n          size++;\n        } else {\n          break;\n        }\n\n        position++;\n      }\n\n      if (size >= TAB_SIZE) {\n        index = value.indexOf(C_NEWLINE, index + 1);\n        continue;\n      }\n    }\n\n    subvalue = value.slice(index + 1);\n\n    /* Check if the following code contains a possible\n     * block. */\n    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {\n      break;\n    }\n\n    /* Break if the following line starts a list, when\n     * already in a list, or when in commonmark, or when\n     * in gfm mode and the bullet is *not* numeric. */\n    if (\n      tokenizers.list.call(self, eat, subvalue, true) &&\n      (\n        self.inList ||\n        commonmark ||\n        (gfm && !decimal(trim.left(subvalue).charAt(0)))\n      )\n    ) {\n      break;\n    }\n\n    position = index;\n    index = value.indexOf(C_NEWLINE, index + 1);\n\n    if (index !== -1 && trim(value.slice(position, index)) === '') {\n      index = position;\n      break;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n\n  if (trim(subvalue) === '') {\n    eat(subvalue);\n\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  subvalue = trimTrailingLines(subvalue);\n\n  return eat(subvalue)({\n    type: 'paragraph',\n    children: self.tokenizeInline(subvalue, now)\n  });\n}\n","'use strict';\n\nvar locate = require('../locate/escape');\n\nmodule.exports = escape;\nescape.locator = locate;\n\nfunction escape(eat, value, silent) {\n  var self = this;\n  var character;\n  var node;\n\n  if (value.charAt(0) === '\\\\') {\n    character = value.charAt(1);\n\n    if (self.escape.indexOf(character) !== -1) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      if (character === '\\n') {\n        node = {type: 'break'};\n      } else {\n        node = {\n          type: 'text',\n          value: character\n        };\n      }\n\n      return eat('\\\\' + character)(node);\n    }\n  }\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('\\\\', fromIndex);\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar decode = require('parse-entities');\nvar locate = require('../locate/tag');\n\nmodule.exports = autoLink;\nautoLink.locator = locate;\nautoLink.notInLink = true;\n\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_AT_SIGN = '@';\nvar C_SLASH = '/';\nvar MAILTO = 'mailto:';\nvar MAILTO_LENGTH = MAILTO.length;\n\n/* Tokenise a link. */\nfunction autoLink(eat, value, silent) {\n  var self;\n  var subvalue;\n  var length;\n  var index;\n  var queue;\n  var character;\n  var hasAtCharacter;\n  var link;\n  var now;\n  var content;\n  var tokenizers;\n  var exit;\n\n  if (value.charAt(0) !== C_LT) {\n    return;\n  }\n\n  self = this;\n  subvalue = '';\n  length = value.length;\n  index = 0;\n  queue = '';\n  hasAtCharacter = false;\n  link = '';\n\n  index++;\n  subvalue = C_LT;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      whitespace(character) ||\n      character === C_GT ||\n      character === C_AT_SIGN ||\n      (character === ':' && value.charAt(index + 1) === C_SLASH)\n    ) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  link += queue;\n  queue = '';\n\n  character = value.charAt(index);\n  link += character;\n  index++;\n\n  if (character === C_AT_SIGN) {\n    hasAtCharacter = true;\n  } else {\n    if (\n      character !== ':' ||\n      value.charAt(index + 1) !== C_SLASH\n    ) {\n      return;\n    }\n\n    link += C_SLASH;\n    index++;\n  }\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (whitespace(character) || character === C_GT) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (!queue || character !== C_GT) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  link += queue;\n  content = link;\n  subvalue += link + character;\n  now = eat.now();\n  now.column++;\n  now.offset++;\n\n  if (hasAtCharacter) {\n    if (link.slice(0, MAILTO_LENGTH).toLowerCase() === MAILTO) {\n      content = content.substr(MAILTO_LENGTH);\n      now.column += MAILTO_LENGTH;\n      now.offset += MAILTO_LENGTH;\n    } else {\n      link = MAILTO + link;\n    }\n  }\n\n  /* Temporarily remove all tokenizers except text in autolinks. */\n  tokenizers = self.inlineTokenizers;\n  self.inlineTokenizers = {text: tokenizers.text};\n\n  exit = self.enterLink();\n\n  content = self.tokenizeInline(content, now);\n\n  self.inlineTokenizers = tokenizers;\n  exit();\n\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(link, {nonTerminated: false}),\n    children: content\n  });\n}\n","'use strict';\n\nvar decode = require('parse-entities');\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/url');\n\nmodule.exports = url;\nurl.locator = locate;\nurl.notInLink = true;\n\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_AT_SIGN = '@';\n\nvar HTTP_PROTOCOL = 'http://';\nvar HTTPS_PROTOCOL = 'https://';\nvar MAILTO_PROTOCOL = 'mailto:';\n\nvar PROTOCOLS = [\n  HTTP_PROTOCOL,\n  HTTPS_PROTOCOL,\n  MAILTO_PROTOCOL\n];\n\nvar PROTOCOLS_LENGTH = PROTOCOLS.length;\n\nfunction url(eat, value, silent) {\n  var self = this;\n  var subvalue;\n  var content;\n  var character;\n  var index;\n  var position;\n  var protocol;\n  var match;\n  var length;\n  var queue;\n  var parenCount;\n  var nextCharacter;\n  var exit;\n\n  if (!self.options.gfm) {\n    return;\n  }\n\n  subvalue = '';\n  index = -1;\n  length = PROTOCOLS_LENGTH;\n\n  while (++index < length) {\n    protocol = PROTOCOLS[index];\n    match = value.slice(0, protocol.length);\n\n    if (match.toLowerCase() === protocol) {\n      subvalue = match;\n      break;\n    }\n  }\n\n  if (!subvalue) {\n    return;\n  }\n\n  index = subvalue.length;\n  length = value.length;\n  queue = '';\n  parenCount = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (whitespace(character) || character === C_LT) {\n      break;\n    }\n\n    if (\n      character === '.' ||\n      character === ',' ||\n      character === ':' ||\n      character === ';' ||\n      character === '\"' ||\n      character === '\\'' ||\n      character === ')' ||\n      character === ']'\n    ) {\n      nextCharacter = value.charAt(index + 1);\n\n      if (!nextCharacter || whitespace(nextCharacter)) {\n        break;\n      }\n    }\n\n    if (character === C_PAREN_OPEN || character === C_BRACKET_OPEN) {\n      parenCount++;\n    }\n\n    if (character === C_PAREN_CLOSE || character === C_BRACKET_CLOSE) {\n      parenCount--;\n\n      if (parenCount < 0) {\n        break;\n      }\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  subvalue += queue;\n  content = subvalue;\n\n  if (protocol === MAILTO_PROTOCOL) {\n    position = queue.indexOf(C_AT_SIGN);\n\n    if (position === -1 || position === length - 1) {\n      return;\n    }\n\n    content = content.substr(MAILTO_PROTOCOL.length);\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  exit = self.enterLink();\n  content = self.tokenizeInline(content, eat.now());\n  exit();\n\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(subvalue, {nonTerminated: false}),\n    children: content\n  });\n}\n","'use strict';\n\nmodule.exports = locate;\n\nvar PROTOCOLS = ['https://', 'http://', 'mailto:'];\n\nfunction locate(value, fromIndex) {\n  var length = PROTOCOLS.length;\n  var index = -1;\n  var min = -1;\n  var position;\n\n  if (!this.options.gfm) {\n    return -1;\n  }\n\n  while (++index < length) {\n    position = value.indexOf(PROTOCOLS[index], fromIndex);\n\n    if (position !== -1 && (position < min || min === -1)) {\n      min = position;\n    }\n  }\n\n  return min;\n}\n","'use strict';\n\nvar alphabetical = require('is-alphabetical');\nvar locate = require('../locate/tag');\nvar tag = require('../util/html').tag;\n\nmodule.exports = inlineHTML;\ninlineHTML.locator = locate;\n\nvar EXPRESSION_HTML_LINK_OPEN = /^<a /i;\nvar EXPRESSION_HTML_LINK_CLOSE = /^<\\/a>/i;\n\nfunction inlineHTML(eat, value, silent) {\n  var self = this;\n  var length = value.length;\n  var character;\n  var subvalue;\n\n  if (value.charAt(0) !== '<' || length < 3) {\n    return;\n  }\n\n  character = value.charAt(1);\n\n  if (\n    !alphabetical(character) &&\n    character !== '?' &&\n    character !== '!' &&\n    character !== '/'\n  ) {\n    return;\n  }\n\n  subvalue = value.match(tag);\n\n  if (!subvalue) {\n    return;\n  }\n\n  /* istanbul ignore if - not used yet. */\n  if (silent) {\n    return true;\n  }\n\n  subvalue = subvalue[0];\n\n  if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {\n    self.inLink = true;\n  } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {\n    self.inLink = false;\n  }\n\n  return eat(subvalue)({type: 'html', value: subvalue});\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\n\nvar own = {}.hasOwnProperty;\n\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n\n/* Map of characters, which can be used to mark link\n * and image titles. */\nvar LINK_MARKERS = {};\n\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\nvar COMMONMARK_LINK_MARKERS = {};\n\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var pedantic = self.options.pedantic;\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n\n  /* Detect whether this is an image. */\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n\n  /* Eat the opening. */\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  /* Exit when this is a link and were already inside\n   * a link. */\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n\n  /* Eat the content. */\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n    /* In GFM mode, brackets in code still count.\n     * In all other modes, they dont.  This empty\n     * block prevents the next statements are\n     * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (!pedantic) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n\n  /* Eat the content closing. */\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n\n  /* Eat white-space. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat the URL. */\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && own.call(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (!pedantic) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n\n  /* Eat white-space. */\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n\n  /* Eat the title. */\n  if (queue && own.call(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {nonTerminated: false});\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\n\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n\n  /* Check whether were eating an image. */\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = '';\n\n  /* Check whether were eating a footnote. */\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and well enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n\n  /* Eat the text. */\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  /* Inline footnotes cannot have an identifier. */\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  }\n\n  /* Brackets cannot be inside the identifier. */\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}\n","'use strict';\n\nvar trim = require('trim');\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/strong');\n\nmodule.exports = strong;\nstrong.locator = locate;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\n\nfunction strong(eat, value, silent) {\n  var self = this;\n  var index = 0;\n  var character = value.charAt(index);\n  var now;\n  var pedantic;\n  var marker;\n  var queue;\n  var subvalue;\n  var length;\n  var prev;\n\n  if (\n    (character !== C_ASTERISK && character !== C_UNDERSCORE) ||\n    value.charAt(++index) !== character\n  ) {\n    return;\n  }\n\n  pedantic = self.options.pedantic;\n  marker = character;\n  subvalue = marker + marker;\n  length = value.length;\n  index++;\n  queue = '';\n  character = '';\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return;\n  }\n\n  while (index < length) {\n    prev = character;\n    character = value.charAt(index);\n\n    if (\n      character === marker &&\n      value.charAt(index + 1) === marker &&\n      (!pedantic || !whitespace(prev))\n    ) {\n      character = value.charAt(index + 2);\n\n      if (character !== marker) {\n        if (!trim(queue)) {\n          return;\n        }\n\n        /* istanbul ignore if - never used (yet) */\n        if (silent) {\n          return true;\n        }\n\n        now = eat.now();\n        now.column += 2;\n        now.offset += 2;\n\n        return eat(subvalue + queue + subvalue)({\n          type: 'strong',\n          children: self.tokenizeInline(queue, now)\n        });\n      }\n    }\n\n    if (!pedantic && character === '\\\\') {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('**', fromIndex);\n  var underscore = value.indexOf('__', fromIndex);\n\n  if (underscore === -1) {\n    return asterisk;\n  }\n\n  if (asterisk === -1) {\n    return underscore;\n  }\n\n  return underscore < asterisk ? underscore : asterisk;\n}\n","'use strict';\n\nvar trim = require('trim');\nvar word = require('is-word-character');\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/emphasis');\n\nmodule.exports = emphasis;\nemphasis.locator = locate;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\n\nfunction emphasis(eat, value, silent) {\n  var self = this;\n  var index = 0;\n  var character = value.charAt(index);\n  var now;\n  var pedantic;\n  var marker;\n  var queue;\n  var subvalue;\n  var length;\n  var prev;\n\n  if (character !== C_ASTERISK && character !== C_UNDERSCORE) {\n    return;\n  }\n\n  pedantic = self.options.pedantic;\n  subvalue = character;\n  marker = character;\n  length = value.length;\n  index++;\n  queue = '';\n  character = '';\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return;\n  }\n\n  while (index < length) {\n    prev = character;\n    character = value.charAt(index);\n\n    if (character === marker && (!pedantic || !whitespace(prev))) {\n      character = value.charAt(++index);\n\n      if (character !== marker) {\n        if (!trim(queue) || prev === marker) {\n          return;\n        }\n\n        if (!pedantic && marker === C_UNDERSCORE && word(character)) {\n          queue += marker;\n          continue;\n        }\n\n        /* istanbul ignore if - never used (yet) */\n        if (silent) {\n          return true;\n        }\n\n        now = eat.now();\n        now.column++;\n        now.offset++;\n\n        return eat(subvalue + queue + marker)({\n          type: 'emphasis',\n          children: self.tokenizeInline(queue, now)\n        });\n      }\n\n      queue += marker;\n    }\n\n    if (!pedantic && character === '\\\\') {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('*', fromIndex);\n  var underscore = value.indexOf('_', fromIndex);\n\n  if (underscore === -1) {\n    return asterisk;\n  }\n\n  if (asterisk === -1) {\n    return underscore;\n  }\n\n  return underscore < asterisk ? underscore : asterisk;\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/delete');\n\nmodule.exports = strikethrough;\nstrikethrough.locator = locate;\n\nvar C_TILDE = '~';\nvar DOUBLE = '~~';\n\nfunction strikethrough(eat, value, silent) {\n  var self = this;\n  var character = '';\n  var previous = '';\n  var preceding = '';\n  var subvalue = '';\n  var index;\n  var length;\n  var now;\n\n  if (\n    !self.options.gfm ||\n    value.charAt(0) !== C_TILDE ||\n    value.charAt(1) !== C_TILDE ||\n    whitespace(value.charAt(2))\n  ) {\n    return;\n  }\n\n  index = 1;\n  length = value.length;\n  now = eat.now();\n  now.column += 2;\n  now.offset += 2;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_TILDE &&\n      previous === C_TILDE &&\n      (!preceding || !whitespace(preceding))\n    ) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      return eat(DOUBLE + subvalue + DOUBLE)({\n        type: 'delete',\n        children: self.tokenizeInline(subvalue, now)\n      });\n    }\n\n    subvalue += previous;\n    preceding = previous;\n    previous = character;\n  }\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('~~', fromIndex);\n}\n","'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/code-inline');\n\nmodule.exports = inlineCode;\ninlineCode.locator = locate;\n\nvar C_TICK = '`';\n\n/* Tokenise inline code. */\nfunction inlineCode(eat, value, silent) {\n  var length = value.length;\n  var index = 0;\n  var queue = '';\n  var tickQueue = '';\n  var contentQueue;\n  var subqueue;\n  var count;\n  var openingCount;\n  var subvalue;\n  var character;\n  var found;\n  var next;\n\n  while (index < length) {\n    if (value.charAt(index) !== C_TICK) {\n      break;\n    }\n\n    queue += C_TICK;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  subvalue = queue;\n  openingCount = index;\n  queue = '';\n  next = value.charAt(index);\n  count = 0;\n\n  while (index < length) {\n    character = next;\n    next = value.charAt(index + 1);\n\n    if (character === C_TICK) {\n      count++;\n      tickQueue += character;\n    } else {\n      count = 0;\n      queue += character;\n    }\n\n    if (count && next !== C_TICK) {\n      if (count === openingCount) {\n        subvalue += queue + tickQueue;\n        found = true;\n        break;\n      }\n\n      queue += tickQueue;\n      tickQueue = '';\n    }\n\n    index++;\n  }\n\n  if (!found) {\n    if (openingCount % 2 !== 0) {\n      return;\n    }\n\n    queue = '';\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  contentQueue = '';\n  subqueue = '';\n  length = queue.length;\n  index = -1;\n\n  while (++index < length) {\n    character = queue.charAt(index);\n\n    if (whitespace(character)) {\n      subqueue += character;\n      continue;\n    }\n\n    if (subqueue) {\n      if (contentQueue) {\n        contentQueue += subqueue;\n      }\n\n      subqueue = '';\n    }\n\n    contentQueue += character;\n  }\n\n  return eat(subvalue)({\n    type: 'inlineCode',\n    value: contentQueue\n  });\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('`', fromIndex);\n}\n","'use strict';\n\nvar locate = require('../locate/break');\n\nmodule.exports = hardBreak;\nhardBreak.locator = locate;\n\nvar MIN_BREAK_LENGTH = 2;\n\nfunction hardBreak(eat, value, silent) {\n  var length = value.length;\n  var index = -1;\n  var queue = '';\n  var character;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === '\\n') {\n      if (index < MIN_BREAK_LENGTH) {\n        return;\n      }\n\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      queue += character;\n\n      return eat(queue)({type: 'break'});\n    }\n\n    if (character !== ' ') {\n      return;\n    }\n\n    queue += character;\n  }\n}\n","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var index = value.indexOf('\\n', fromIndex);\n\n  while (index > fromIndex) {\n    if (value.charAt(index - 1) !== ' ') {\n      break;\n    }\n\n    index--;\n  }\n\n  return index;\n}\n","'use strict';\n\nmodule.exports = text;\n\nfunction text(eat, value, silent) {\n  var self = this;\n  var methods;\n  var tokenizers;\n  var index;\n  var length;\n  var subvalue;\n  var position;\n  var tokenizer;\n  var name;\n  var min;\n  var now;\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  methods = self.inlineMethods;\n  length = methods.length;\n  tokenizers = self.inlineTokenizers;\n  index = -1;\n  min = value.length;\n\n  while (++index < length) {\n    name = methods[index];\n\n    if (name === 'text' || !tokenizers[name]) {\n      continue;\n    }\n\n    tokenizer = tokenizers[name].locator;\n\n    if (!tokenizer) {\n      eat.file.fail('Missing locator: `' + name + '`');\n    }\n\n    position = tokenizer.call(self, value, 1);\n\n    if (position !== -1 && position < min) {\n      min = position;\n    }\n  }\n\n  subvalue = value.slice(0, min);\n  now = eat.now();\n\n  self.decode(subvalue, now, function (content, position, source) {\n    eat(source || content)({\n      type: 'text',\n      value: content\n    });\n  });\n}\n"],"sourceRoot":""}