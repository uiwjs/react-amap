{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../node_modules/@babel/traverse/node_modules/debug/src/common.js","../node_modules/@babel/traverse/node_modules/ms/index.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","default","SHOULD_SKIP","SHOULD_STOP","REMOVED","virtualTypes","require","_debug","_index","_scope","t","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","NodePath","hub","parent","this","contexts","state","opts","_traverseFlags","skipKeys","parentPath","container","listKey","key","node","type","data","context","scope","isScope","val","create","def","undefined","msg","Error","SyntaxError","buildError","visitor","validate","parts","path","inList","unshift","join","message","enabled","getPathLocation","code","v","targetNode","paths","get","Map","set","setup","assign","prototype","TYPES","typeKey","fn","TypeError","indexOf","push","virtualType","checkPath","keys","_default","clear","clearPath","clearScope","WeakMap","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","types","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","isExportNamedDeclaration","source","specifiers","length","isExportDefaultDeclaration","declaration","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","declarations","decl","getBindingIdentifiers","LabeledStatement","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","isFunctionExpression","has","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","block","labels","inited","globals","uids","crawling","cached","_parent","isKey","isMethod","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","slice","generateUidBasedOnNode","isThisExpression","isSuper","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","crawl","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","pop","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","_path","TraversalContext","queue","priorityQueue","VISITOR_KEYS","obj","notPriority","trap","shouldVisit","visitQueue","visited","WeakSet","stop","resync","pushContext","process","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","formatArgs","useColors","module","humanize","diff","c","color","splice","index","lastC","match","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","formatters","j","JSON","stringify","env","createDebug","prevTime","enableOverride","self","curr","Number","Date","ms","prev","coerce","format","formatter","call","logFn","apply","selectColor","extend","enumerable","configurable","delimiter","newDebug","toNamespace","regexp","toString","substring","stack","disable","names","skips","enable","split","len","substr","test","forEach","hash","charCodeAt","Math","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","str","String","exec","parseFloat","parse","isFinite","long","fmtLong","fmtShort","_helperSplitExportDeclaration","renameVisitor","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","delete","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_hub","visitors","_context","cache","noScope","explode","hasDenylistedType","verify","cheap","traverseFast","clearNode","removeProperties","tree","hasType","denylistTypes","denylist","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","err","_codeFrame","codeFrameColumns","start","line","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","pow","func","global","_evaluate","raw","cooked","expr","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","fns","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","updateSiblingKeys","isWhile","isSwitchCase","insertBefore","nodes_","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","assertExpression","temp","fromIndex","incrementBy","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","jsxExpressionContainer","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","nodeType","shouldIgnoreKey","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","arguments","dest","src","Hub"],"mappings":"sJAEAA,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,QAAUF,EAAQG,YAAcH,EAAQI,YAAcJ,EAAQK,aAAU,EAEhF,IAAIC,EAAeC,EAAQ,KAEvBC,EAASD,EAAQ,KAEjBE,EAASF,EAAQ,IAEjBG,EAASH,EAAQ,KAEjBI,EAAIJ,EAAQ,IAEZK,EAASL,EAAQ,KAEjBM,EAAaN,EAAQ,KAErBO,EAAoBP,EAAQ,KAE5BQ,EAAqBR,EAAQ,KAE7BS,EAAuBT,EAAQ,KAE/BU,EAAsBV,EAAQ,KAE9BW,EAAsBX,EAAQ,KAE9BY,EAAyBZ,EAAQ,KAEjCa,EAAmBb,EAAQ,KAE3Bc,EAAmBd,EAAQ,KAE3Be,EAAwBf,EAAQ,KAEhCgB,EAAkBhB,EAAQ,KAE1BiB,EAAoBjB,EAAQ,KAE1BkB,EAAQjB,EAAO,SAGrBR,EAAQK,QADQ,EAGhBL,EAAQI,YADY,EAGpBJ,EAAQG,YADY,E,IAGduB,E,WACJ,WAAYC,EAAKC,GAAQ,UACvBC,KAAKC,SAAW,GAChBD,KAAKE,MAAQ,KACbF,KAAKG,KAAO,KACZH,KAAKI,eAAiB,EACtBJ,KAAKK,SAAW,KAChBL,KAAKM,WAAa,KAClBN,KAAKO,UAAY,KACjBP,KAAKQ,QAAU,KACfR,KAAKS,IAAM,KACXT,KAAKU,KAAO,KACZV,KAAKW,KAAO,KACZX,KAAKD,OAASA,EACdC,KAAKF,IAAMA,EACXE,KAAKY,KAAO,KACZZ,KAAKa,QAAU,KACfb,KAAKc,MAAQ,K,kCAwCf,SAASA,GACP,OAAOd,KAAKe,UAAY,IAAIlC,EAAOR,QAAQ2B,MAAQc,I,qBAGrD,SAAQL,EAAKO,GAKX,OAJiB,MAAbhB,KAAKY,OACPZ,KAAKY,KAAO3C,OAAOgD,OAAO,OAGrBjB,KAAKY,KAAKH,GAAOO,I,qBAG1B,SAAQP,EAAKS,GACM,MAAblB,KAAKY,OACPZ,KAAKY,KAAO3C,OAAOgD,OAAO,OAG5B,IAAID,EAAMhB,KAAKY,KAAKH,GAEpB,YADYU,IAARH,QAA6BG,IAARD,IAAmBF,EAAMhB,KAAKY,KAAKH,GAAOS,GAC5DF,I,iCAGT,SAAoBI,GAA0B,IAArBC,EAAqB,uDAAbC,YAC/B,OAAOtB,KAAKF,IAAIyB,WAAWvB,KAAKU,KAAMU,EAAKC,K,sBAG7C,SAASG,EAAStB,IAChB,EAAItB,EAAOP,SAAS2B,KAAKU,KAAMc,EAASxB,KAAKc,MAAOZ,EAAOF,Q,iBAG7D,SAAIS,EAAKC,GACP5B,EAAE2C,SAASzB,KAAKU,KAAMD,EAAKC,GAC3BV,KAAKU,KAAKD,GAAOC,I,6BAGnB,WACE,IAAMgB,EAAQ,GACVC,EAAO3B,KAEX,EAAG,CACD,IAAIS,EAAMkB,EAAKlB,IACXkB,EAAKC,SAAQnB,EAAM,GAAH,OAAMkB,EAAKnB,QAAX,YAAsBC,EAAtB,MACpBiB,EAAMG,QAAQpB,SACPkB,EAAOA,EAAKrB,YAErB,OAAOoB,EAAMI,KAAK,O,mBAGpB,SAAMC,GACCnC,EAAMoC,SACXpC,EAAM,GAAD,OAAII,KAAKiC,kBAAT,YAA8BjC,KAAKW,KAAnC,aAA4CoB,M,sBAGnD,WACE,OAAO,EAAI/C,EAAWX,SAAS2B,KAAKU,MAAMwB,O,kBAG5C,WACE,QAASlC,KAAKQ,S,IAGhB,SAAWoB,GACJA,IACH5B,KAAKQ,QAAU,Q,qBAInB,WACE,OAAOR,KAAKQ,SAAWR,KAAKS,M,sBAG9B,WACE,SApIgB,EAoINT,KAAKI,iB,IAGjB,SAAe+B,GACTA,EACFnC,KAAKI,gBAzIS,EA2IdJ,KAAKI,iBAAkB,I,sBAI3B,WACE,SAlJgB,EAkJNJ,KAAKI,iB,IAGjB,SAAe+B,GACTA,EACFnC,KAAKI,gBAvJS,EAyJdJ,KAAKI,iBAAkB,I,mBAI3B,WACE,SAhKY,EAgKFJ,KAAKI,iB,IAGjB,SAAY+B,GACNA,EACFnC,KAAKI,gBArKK,EAuKVJ,KAAKI,iBAAkB,K,kBA5I3B,YAOG,IANDN,EAMC,EANDA,IACAQ,EAKC,EALDA,WACAP,EAIC,EAJDA,OACAQ,EAGC,EAHDA,UACAC,EAEC,EAFDA,QACAC,EACC,EADDA,IAMA,IAJKX,GAAOQ,IACVR,EAAMQ,EAAWR,MAGdC,EACH,MAAM,IAAIsB,MAAM,gDAGlB,IAAMe,EAAa7B,EAAUE,GAEzB4B,EAAQtD,EAAO4C,KAAKW,IAAIvC,GAEvBsC,IACHA,EAAQ,IAAIE,IAEZxD,EAAO4C,KAAKa,IAAIzC,EAAQsC,IAG1B,IAAIV,EAAOU,EAAMC,IAAIF,GAQrB,OANKT,IACHA,EAAO,IAAI9B,EAASC,EAAKC,GACrBqC,GAAYC,EAAMG,IAAIJ,EAAYT,IAGxCA,EAAKc,MAAMnC,EAAYC,EAAWC,EAASC,GACpCkB,M,KAgHX1D,OAAOyE,OAAO7C,EAAS8C,UAAW1D,EAAmBC,EAAoBC,EAAsBC,EAAqBC,EAAqBC,EAAwBC,EAAkBC,EAAkBC,EAAuBC,EAAiBC,G,UAE1Nb,EAAE8D,O,yBAAVjC,E,QACHkC,EAAU,KAAH,OAAQlC,GACfmC,EAAKhE,EAAE+D,GAEbhD,EAAS8C,UAAUE,GAAW,SAAU1C,GACtC,OAAO2C,EAAG9C,KAAKU,KAAMP,IAGvBN,EAAS8C,UAAT,gBAA4BhC,IAAU,SAAUR,GAC9C,IAAK2C,EAAG9C,KAAKU,KAAMP,GACjB,MAAM,IAAI4C,UAAJ,qCAA4CpC,MAVxD,2BAA4B,I,8BAe5B,I,iBAAK,IAAMA,EAAI,KACb,GAAgB,MAAZA,EAAK,GAAY,iBACjB7B,EAAE8D,MAAMI,QAAQrC,GAAQ,GAAG7B,EAAE8D,MAAMK,KAAKtC,GAC5C,IAAMuC,EAAczE,EAAakC,GAEjCd,EAAS8C,UAAT,YAAwBhC,IAAU,SAAUR,GAC1C,OAAO+C,EAAYC,UAAUnD,KAAMG,KANvC,MAAmBlC,OAAOmF,KAAK3E,GAA/B,eAA8C,IAU9C,IAAI4E,EAAWxD,EACf1B,EAAQE,QAAUgF,G,iCCpPlBpF,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQmF,MASR,WACEC,IACAC,KAVFrF,EAAQoF,UAAYA,EACpBpF,EAAQqF,WAAaA,EACrBrF,EAAQ2C,MAAQ3C,EAAQwD,UAAO,EAC/B,IAAIA,EAAO,IAAI8B,QACftF,EAAQwD,KAAOA,EACf,IAAIb,EAAQ,IAAI2C,QAQhB,SAASF,IACPpF,EAAQwD,KAAOA,EAAO,IAAI8B,QAG5B,SAASD,IACPrF,EAAQ2C,MAAQA,EAAQ,IAAI2C,QAZ9BtF,EAAQ2C,MAAQA,G,iCCVhB7C,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQuF,kBAAoBvF,EAAQwF,6BAA+BxF,EAAQyF,qBAAuBzF,EAAQ0F,eAAiB1F,EAAQ2F,aAAe3F,EAAQ4F,KAAO5F,EAAQ6F,KAAO7F,EAAQ8F,UAAY9F,EAAQ+F,KAAO/F,EAAQgG,IAAMhG,EAAQiG,YAAcjG,EAAQkG,WAAalG,EAAQmG,MAAQnG,EAAQoG,WAAapG,EAAQqG,UAAYrG,EAAQsG,kBAAoBtG,EAAQuG,2BAA6BvG,EAAQwG,0BAAuB,EAEra,IAAI7F,EAAIJ,EAAQ,IAEViG,EAAuB,CAC3BC,MAAO,CAAC,aAAc,iBAEtBzB,UAH2B,SAGjBxB,EAAMxB,GACd,IACEO,EAEEiB,EAFFjB,KACAX,EACE4B,EADF5B,OAGF,IAAKjB,EAAE+F,aAAanE,EAAMP,KAAUrB,EAAEgG,sBAAsB/E,EAAQI,GAAO,CACzE,IAAIrB,EAAEiG,gBAAgBrE,EAAMP,GAG1B,OAAO,EAFP,GAAIrB,EAAEkG,MAAMC,YAAYvE,EAAKwE,MAAO,OAAO,EAM/C,OAAOpG,EAAEqG,aAAazE,EAAMX,EAAQ4B,EAAKrB,WAAWP,UAIxD5B,EAAQwG,qBAAuBA,EAC/B,IAAMD,EAA6B,CACjCE,MAAO,CAAC,oBAERzB,UAHiC,YAM9B,IAFDzC,EAEC,EAFDA,KACAX,EACC,EADDA,OAEA,OAAOjB,EAAEsG,mBAAmB1E,IAAS5B,EAAEqG,aAAazE,EAAMX,KAI9D5B,EAAQuG,2BAA6BA,EACrC,IAAMD,EAAoB,CACxBG,MAAO,CAAC,cAERzB,UAHwB,SAGdxB,GACR,IACEjB,EAEEiB,EAFFjB,KACAX,EACE4B,EADF5B,OAEIsF,EAAc1D,EAAKrB,WAAWP,OACpC,OAAOjB,EAAE+F,aAAanE,IAAS5B,EAAEwG,UAAU5E,EAAMX,EAAQsF,KAI7DlH,EAAQsG,kBAAoBA,EAC5B,IAAMD,EAAY,CAChBI,MAAO,CAAC,aAERzB,UAHgB,YAMb,IAFDzC,EAEC,EAFDA,KACAX,EACC,EADDA,OAEA,GAAIjB,EAAEyG,YAAY7E,GAAO,CACvB,GAAI5B,EAAE0G,sBAAsB9E,GAAO,CACjC,GAAI5B,EAAE2G,gBAAgB1F,EAAQ,CAC5B2F,KAAMhF,IACJ,OAAO,EACX,GAAI5B,EAAE6G,eAAe5F,EAAQ,CAC3B6F,KAAMlF,IACJ,OAAO,EAGb,OAAO,EAEP,OAAO,IAKbvC,EAAQqG,UAAYA,EACpB,IAAMD,EAAa,CACjBK,MAAO,CAAC,cAERzB,UAHiB,SAGPxB,GACR,OAAIA,EAAKkD,eACAlD,EAAKkE,yBAEL/G,EAAEgH,aAAanE,EAAKjB,QAKjCvC,EAAQoG,WAAaA,EACrB,IAAMD,EAAQ,CACZM,MAAO,CAAC,WAAY,WAEpBzB,UAHY,SAGFxB,GACR,OAAO7C,EAAEiC,QAAQY,EAAKjB,KAAMiB,EAAK5B,UAIrC5B,EAAQmG,MAAQA,EAChB,IAAMD,EAAa,CACjBlB,UADiB,SACPxB,GACR,OAAO7C,EAAEqG,aAAaxD,EAAKjB,KAAMiB,EAAK5B,UAI1C5B,EAAQkG,WAAaA,EACrB,IAAMD,EAAc,CAClBjB,UADkB,SACRxB,GACR,OAAO7C,EAAEiH,cAAcpE,EAAKjB,QAIhCvC,EAAQiG,YAAcA,EACtB,IAAMD,EAAM,CACVS,MAAO,CAAC,uBAERzB,UAHU,SAGAxB,GACR,OAAO7C,EAAEkH,MAAMrE,EAAKjB,QAIxBvC,EAAQgG,IAAMA,EAOdhG,EAAQ+F,KANK,CACXf,UADW,SACDxB,GACR,OAAOA,EAAKjB,QAAUiB,EAAKjB,KAAKuF,MAWpC9H,EAAQ8F,UANU,CAChBd,UADgB,SACNxB,GACR,OAAQA,EAAKuE,WAWjB/H,EAAQ6F,KANK,CACXb,UADW,SACDxB,EAAMxB,GACd,OAAOwB,EAAKb,MAAMqF,OAAOxE,EAAKjB,KAAMP,KAKxC,IAAM4D,EAAO,CACXa,MAAO,CAAC,OAAQ,oBAAqB,oBAAqB,mBAE1DzB,UAHW,YAKR,IADDzC,EACC,EADDA,KAEA,QAAI5B,EAAEsH,OAAO1F,KAEF5B,EAAEuH,oBAAoB3F,GACJ,SAApBA,EAAK4F,YAA6C,WAApB5F,EAAK4F,WACjCxH,EAAEyH,oBAAoB7F,GACJ,SAApBA,EAAK8F,aACH1H,EAAE2H,kBAAkB/F,KACF,SAApBA,EAAK4F,YAA6C,WAApB5F,EAAK4F,eAOhDnI,EAAQ4F,KAAOA,EASf5F,EAAQ2F,aARa,CACnBc,MAAO,CAAC,eAERzB,UAHmB,SAGTxB,GACR,OAAOA,EAAKrB,YAAcqB,EAAKrB,WAAWoG,oBAa9CvI,EAAQ0F,eARe,CACrBe,MAAO,CAAC,eAERzB,UAHqB,SAGXxB,GACR,OAAOA,EAAKrB,YAAcqB,EAAKrB,WAAWqG,uBAQ9CxI,EAAQyF,qBAHqB,CAC3BgB,MAAO,CAAC,yBAMVzG,EAAQwF,6BAH6B,CACnCiB,MAAO,CAAC,gCAaVzG,EAAQuF,kBAVkB,CACxBkB,MAAO,CAAC,kBAERzB,UAHwB,YAMtB,OAAsB,IADrB,EADDzC,KAEYkG,S,qECvMhB3I,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAIwI,EAAWnI,EAAQ,KAEnBE,EAASF,EAAQ,IAEjBoI,EAAWpI,EAAQ,KAEnBqI,EAAWrI,EAAQ,KAEnBI,EAAIJ,EAAQ,IAEZK,EAASL,EAAQ,KAErB,SAASsI,EAAgBtG,EAAMgB,GAC7B,OAAgB,MAARhB,OAAe,EAASA,EAAKC,MACnC,QACE,GAAI7B,EAAEmI,oBAAoBvG,GACxB,IAAK5B,EAAEoI,uBAAuBxG,IAAS5B,EAAEqI,yBAAyBzG,IAAS5B,EAAEuH,oBAAoB3F,KAAUA,EAAK0G,OAC9GJ,EAAgBtG,EAAK0G,OAAQ1F,QACxB,IAAK5C,EAAEqI,yBAAyBzG,IAAS5B,EAAEuH,oBAAoB3F,KAAUA,EAAK2G,YAAc3G,EAAK2G,WAAWC,OAAQ,WACzG5G,EAAK2G,YADoG,IACzH,4BAAiCL,EAAjC,QAAoDtF,IADqE,oCAE/G5C,EAAEyI,2BAA2B7G,IAAS5B,EAAEqI,yBAAyBzG,KAAUA,EAAK8G,aAC1FR,EAAgBtG,EAAK8G,YAAa9F,QAE3B5C,EAAE2I,kBAAkB/G,GAC7BsG,EAAgBtG,EAAKgH,MAAOhG,GACnB5C,EAAE6I,UAAUjH,IACrBgB,EAAMuB,KAAKvC,EAAKtC,OAGlB,MAEF,IAAK,mBACL,IAAK,2BACL,IAAK,sBACH4I,EAAgBtG,EAAKkH,OAAQlG,GAC7BsF,EAAgBtG,EAAKmH,SAAUnG,GAC/B,MAEF,IAAK,aACL,IAAK,gBACHA,EAAMuB,KAAKvC,EAAKwE,MAChB,MAEF,IAAK,iBACL,IAAK,yBACL,IAAK,gBACH8B,EAAgBtG,EAAKoH,OAAQpG,GAC7B,MAEF,IAAK,mBACL,IAAK,gBAAL,UACkBhB,EAAKqH,YADvB,IACE,2BAAiC,CAC/Bf,EAD+B,QACZtF,IAFvB,8BAKE,MAEF,IAAK,gBACL,IAAK,cACHsF,EAAgBtG,EAAKsH,SAAUtG,GAC/B,MAEF,IAAK,iBACL,IAAK,eACL,IAAK,gBACL,IAAK,cACL,IAAK,uBACL,IAAK,qBACHsF,EAAgBtG,EAAKD,IAAKiB,GAC1B,MAEF,IAAK,iBACHA,EAAMuB,KAAK,QACX,MAEF,IAAK,QACHvB,EAAMuB,KAAK,SACX,MAEF,IAAK,SACHvB,EAAMuB,KAAK,UACX,MAEF,IAAK,eACHvB,EAAMuB,KAAK,MACX,MAEF,IAAK,kBACHvB,EAAMuB,KAAK,SACX+D,EAAgBtG,EAAKsH,SAAUtG,GAC/B,MAEF,IAAK,kBACHA,EAAMuB,KAAK,SACX+D,EAAgBtG,EAAKsH,SAAUtG,GAC/B,MAEF,IAAK,uBACHsF,EAAgBtG,EAAKgF,KAAMhE,GAC3B,MAEF,IAAK,qBACHsF,EAAgBtG,EAAKuH,GAAIvG,GACzB,MAEF,IAAK,qBACL,IAAK,sBACL,IAAK,kBACL,IAAK,mBAIL,IAAK,cACHsF,EAAgBtG,EAAKuH,GAAIvG,GACzB,MAEF,IAAK,0BACHsF,EAAgBtG,EAAKwH,WAAYxG,GACjC,MAEF,IAAK,kBACL,IAAK,mBACHsF,EAAgBtG,EAAKsH,SAAUtG,GAC/B,MAEF,IAAK,eACHsF,EAAgBtG,EAAKyH,KAAMzG,GAC3BsF,EAAgBtG,EAAKmH,SAAUnG,GAC/B,MAEF,IAAK,aACHsF,EAAgBtG,EAAK0H,eAAgB1G,GACrC,MAEF,IAAK,oBACHA,EAAMuB,KAAKvC,EAAKwE,MAChB,MAEF,IAAK,cACH8B,EAAgBtG,EAAK2H,gBAAiB3G,GACtC,MAEF,IAAK,qBACHA,EAAMuB,KAAK,YACX,MAEF,IAAK,oBACH+D,EAAgBtG,EAAK4H,UAAW5G,GAChCsF,EAAgBtG,EAAKwE,KAAMxD,IAKjC,IAAM6G,EAAmB,CACvBC,IADuB,SACnB7G,GAAM,UACU7C,EAAE2J,eADZ,IACR,2BAAmC,KAAxBhI,EAAwB,QAC3BiI,EAAS/G,EAAKW,IAAI7B,GAExB,GAAIiI,EAAO1C,SACWrE,EAAKb,MAAM6H,qBAAuBhH,EAAKb,MAAM8H,oBACrDC,gBAAgB,MAAOH,IAN/B,gCAWVI,YAZuB,SAYXnH,GACNA,EAAKoE,kBACLpE,EAAK4E,wBACM5E,EAAKb,MAAM6H,qBAAuBhH,EAAKb,MAAM8H,oBACrDG,oBAAoBpH,KAG7BgD,qBAnBuB,SAmBFhD,EAAMzB,GACzBA,EAAM8I,WAAW/F,KAAKtB,IAGxBsH,cAvBuB,SAuBTtH,EAAMzB,GAClB,IAAMwF,EAAO/D,EAAKW,IAAI,SAElBoD,EAAKwD,aAAexD,EAAKb,iBAC3B3E,EAAMiJ,mBAAmBlG,KAAKtB,IAIlCyH,kBAAmB,CACjBC,KADiB,SACZ1H,GACH,IACEjB,EAEEiB,EAFFjB,KACAI,EACEa,EADFb,MAEF,IAAIhC,EAAEoI,uBAAuBxG,GAA7B,CACA,IAAMgI,EAAShI,EAAK8G,YAEpB,GAAI1I,EAAEwK,mBAAmBZ,IAAW5J,EAAEyK,sBAAsBb,GAAS,CACnE,IAAMT,EAAKS,EAAOT,GAClB,IAAKA,EAAI,OACT,IAAMuB,EAAU1I,EAAM2I,WAAWxB,EAAG/C,MAChCsE,GAASA,EAAQE,UAAU/H,QAC1B,GAAI7C,EAAE0G,sBAAsBkD,GAAS,WACvBA,EAAOiB,cADgB,IAC1C,2BACE,IADsC,IAA7BC,EAA6B,QACtC,MAAmB3L,OAAOmF,KAAKtE,EAAE+K,sBAAsBD,IAAvD,eAA+D,CAA1D,IAAM1E,EAAI,KACPsE,EAAU1I,EAAM2I,WAAWvE,GAC7BsE,GAASA,EAAQE,UAAU/H,IAJO,mCAYhDmI,iBAzDuB,SAyDNnI,GACfA,EAAKb,MAAMiJ,iBAAiBhB,oBAAoBpH,IAGlDqI,qBA7DuB,SA6DFrI,EAAMzB,GACzBA,EAAM+J,YAAYhH,KAAKtB,IAGzBuI,iBAjEuB,SAiENvI,EAAMzB,GACrBA,EAAMiJ,mBAAmBlG,KAAKtB,IAGhCwI,gBArEuB,SAqEPxI,EAAMzB,GACO,WAAvByB,EAAKjB,KAAK0J,UACZlK,EAAMiJ,mBAAmBlG,KAAKtB,IAIlCyC,YA3EuB,SA2EXzC,GACV,IAAIb,EAAQa,EAAKb,MAKjB,GAJIA,EAAMa,OAASA,IAAMb,EAAQA,EAAMf,QACxBe,EAAMiJ,iBACdhB,oBAAoBpH,GAEvBA,EAAK2H,sBAAwB3H,EAAKjB,KAAKuH,GAAI,CAC7C,IACM/C,EADKvD,EAAKjB,KAAKuH,GACL/C,KAChBvD,EAAKb,MAAMuJ,SAASnF,GAAQvD,EAAKb,MAAMf,OAAO0J,WAAWvE,KAI7DoF,YAxFuB,SAwFX3I,GACVA,EAAKb,MAAM+H,gBAAgB,MAAOlH,IAGpC4I,SA5FuB,SA4Fd5I,GACHA,EAAK6I,wBAA0B7I,EAAK8I,IAAI,QAAU9I,EAAKW,IAAI,MAAM5B,KAAK5B,EAAE4L,oBAC1E/I,EAAKb,MAAM+H,gBAAgB,QAASlH,EAAKW,IAAI,MAAOX,GAGtD,IALa,EAKPgJ,EAAShJ,EAAKW,IAAI,UALX,IAOOqI,GAPP,IAOb,2BAA4B,KAAjBC,EAAiB,QAC1BjJ,EAAKb,MAAM+H,gBAAgB,QAAS+B,IARzB,gCAYfC,gBAxGuB,SAwGPlJ,GACVA,EAAK8I,IAAI,QAAU9I,EAAKW,IAAI,MAAM5B,KAAK5B,EAAE4L,oBAC3C/I,EAAKb,MAAM+H,gBAAgB,QAASlH,KAKtCmJ,EAAM,EAEJxG,E,WACJ,WAAY3C,GAAM,UAChB3B,KAAK8K,SAAM,EACX9K,KAAK2B,UAAO,EACZ3B,KAAK+K,WAAQ,EACb/K,KAAKgL,YAAS,EACdhL,KAAKiL,YAAS,EACdjL,KAAKqK,cAAW,EAChBrK,KAAKgJ,gBAAa,EAClBhJ,KAAKkL,aAAU,EACflL,KAAKmL,UAAO,EACZnL,KAAKY,UAAO,EACZZ,KAAKoL,cAAW,EAChB,IACE1K,EACEiB,EADFjB,KAGI2K,EAAStM,EAAO+B,MAAMwB,IAAI5B,GAEhC,IAAe,MAAV2K,OAAiB,EAASA,EAAO1J,QAAUA,EAC9C,OAAO0J,EAGTtM,EAAO+B,MAAM0B,IAAI9B,EAAMV,MAEvBA,KAAK8K,IAAMA,IACX9K,KAAK+K,MAAQrK,EACbV,KAAK2B,KAAOA,EACZ3B,KAAKgL,OAAS,IAAIzI,IAClBvC,KAAKiL,QAAS,E,8BAGhB,WACE,IAAIK,EAEAvL,EACA4B,EAAO3B,KAAK2B,KAEhB,EAAG,CACD,IAAM4J,EAAqB,QAAb5J,EAAKlB,IACnBkB,EAAOA,EAAKrB,WACRiL,GAAS5J,EAAK6J,aAAY7J,EAAOA,EAAKrB,YACtCqB,GAAQA,EAAKZ,YAAWhB,EAAS4B,SAC9BA,IAAS5B,GAElB,OAA6B,OAArBuL,EAAUvL,QAAkB,EAASuL,EAAQxK,Q,uBAGvD,WACE,OAAOd,KAAK2B,KAAK5B,S,eAGnB,WACE,OAAOC,KAAK2B,KAAK7B,M,sBAGnB,SAASY,EAAMP,EAAMD,IACnB,EAAItB,EAAOP,SAASqC,EAAMP,EAAMH,KAAME,EAAOF,KAAK2B,Q,2CAGpD,SAA8BuD,GAC5B,IAAM+C,EAAKjI,KAAKyL,sBAAsBvG,GAItC,OAHAlF,KAAKiD,KAAK,CACRgF,OAEKnJ,EAAE4M,UAAUzD,K,mCAGrB,SAAsB/C,GACpB,OAAOpG,EAAE6M,WAAW3L,KAAK4L,YAAY1G,M,yBAGvC,WAA2B,IAErB4F,EAFM5F,EAAe,uDAAR,OACjBA,EAAOpG,EAAE+M,aAAa3G,GAAM4G,QAAQ,MAAO,IAAIA,QAAQ,WAAY,IAEnE,IAAIC,EAAI,EAER,GACEjB,EAAM9K,KAAKgM,aAAa9G,EAAM6G,GAC9BA,UACO/L,KAAKiM,SAASnB,IAAQ9K,KAAKkM,WAAWpB,IAAQ9K,KAAKmM,UAAUrB,IAAQ9K,KAAKoM,aAAatB,IAEhG,IAAMuB,EAAUrM,KAAK4I,mBAGrB,OAFAyD,EAAQrD,WAAW8B,IAAO,EAC1BuB,EAAQlB,KAAKL,IAAO,EACbA,I,0BAGT,SAAa5F,EAAM6G,GACjB,IAAI9D,EAAK/C,EAET,OADI6G,EAAI,IAAG9D,GAAM8D,GACjB,WAAW9D,K,oCAGb,SAAuBvH,EAAM4L,GAC3B,IAAM5K,EAAQ,GACdsF,EAAgBtG,EAAMgB,GACtB,IAAIuG,EAAKvG,EAAMI,KAAK,KAEpB,OADAmG,EAAKA,EAAG6D,QAAQ,KAAM,KAAOQ,GAAe,MACrCtM,KAAK4L,YAAY3D,EAAGsE,MAAM,EAAG,O,8CAGtC,SAAiC7L,EAAM4L,GACrC,OAAOxN,EAAE6M,WAAW3L,KAAKwM,uBAAuB9L,EAAM4L,M,sBAGxD,SAAS5L,GACP,GAAI5B,EAAE2N,iBAAiB/L,IAAS5B,EAAE4N,QAAQhM,GACxC,OAAO,EAGT,GAAI5B,EAAE+F,aAAanE,GAAO,CACxB,IAAM8I,EAAUxJ,KAAKyJ,WAAW/I,EAAKwE,MAErC,OAAIsE,EACKA,EAAQmD,SAER3M,KAAKkM,WAAWxL,EAAKwE,MAIhC,OAAO,I,mCAGT,SAAsBxE,EAAMkM,GAC1B,GAAI5M,KAAK6M,SAASnM,GAChB,OAAO,KAEP,IAAMuH,EAAKjI,KAAK8M,iCAAiCpM,GAEjD,OAAKkM,EAOE3E,GANLjI,KAAKiD,KAAK,CACRgF,OAEKnJ,EAAE4M,UAAUzD,M,wCAOzB,SAA2BP,EAAOqF,EAAM7H,EAAM+C,GAC5C,GAAa,UAAT8E,IACe,UAAfrF,EAAMqF,OACiB,QAATA,GAAiC,QAAfrF,EAAMqF,MAAiC,UAAfrF,EAAMqF,MAAmC,WAAfrF,EAAMqF,MAAoC,UAAfrF,EAAMqF,OAA8B,QAATA,GAA2B,UAATA,KAG5J,MAAM/M,KAAKF,IAAIyB,WAAW0G,EAApB,iCAAkD/C,EAAlD,KAA2DnC,a,oBAIrE,SAAOiK,EAASC,EAASlC,GACvB,IAAMvB,EAAUxJ,KAAKyJ,WAAWuD,GAEhC,GAAIxD,EAEF,OADAyD,EAAUA,GAAWjN,KAAKyL,sBAAsBuB,GAAS9H,KAClD,IAAI2B,EAASxI,QAAQmL,EAASwD,EAASC,GAASC,OAAOnC,K,4BAIlE,SAAeoC,EAAKH,EAASC,EAAS7O,GAChC+O,EAAIH,KACNG,EAAIF,GAAW7O,EACf+O,EAAIH,GAAW,Q,kBAInB,WACE,IAAMI,EAAM,IAAIC,OAAO,IACvBC,QAAQC,IAAIH,GACZ,IAAItM,EAAQd,KAEZ,EAAG,CACDsN,QAAQC,IAAI,IAAKzM,EAAMiK,MAAMpK,MAE7B,cAAmB1C,OAAOmF,KAAKtC,EAAMuJ,UAArC,eAAgD,CAA3C,IAAMnF,EAAI,KACPsE,EAAU1I,EAAMuJ,SAASnF,GAC/BoI,QAAQC,IAAI,KAAMrI,EAAM,CACtByH,SAAUnD,EAAQmD,SAClB3D,WAAYQ,EAAQR,WACpBwE,WAAYhE,EAAQL,mBAAmB7B,OACvCyF,KAAMvD,EAAQuD,cAGXjM,EAAQA,EAAMf,QAEvBuN,QAAQC,IAAIH,K,qBAGd,SAAQ1M,EAAMqL,EAAG0B,GACf,GAAI3O,EAAE+F,aAAanE,GAAO,CACxB,IAAM8I,EAAUxJ,KAAKyJ,WAAW/I,EAAKwE,MAErC,GAAe,MAAXsE,GAAmBA,EAAQmD,UAAYnD,EAAQ7H,KAAK+L,cAAc,SACpE,OAAOhN,EAIX,GAAI5B,EAAE6O,kBAAkBjN,GACtB,OAAOA,EAGT,GAAI5B,EAAE+F,aAAanE,EAAM,CACvBwE,KAAM,cAEN,OAAOpG,EAAE8O,eAAe9O,EAAE+O,iBAAiB/O,EAAE+O,iBAAiB/O,EAAE+O,iBAAiB/O,EAAE6M,WAAW,SAAU7M,EAAE6M,WAAW,cAAe7M,EAAE6M,WAAW,UAAW7M,EAAE6M,WAAW,SAAU,CAACjL,IAGtL,IAAIoN,EACEC,EAAO,CAACrN,GAgBd,OAdU,IAANqL,EACF+B,EAAa,oBACJ/B,GACTgC,EAAK9K,KAAKnE,EAAEkP,eAAejC,IAC3B+B,EAAa,iBAEbA,EAAa,UAGXL,IACFM,EAAKlM,QAAQ7B,KAAKF,IAAImO,UAAUH,IAChCA,EAAa,kBAGRhP,EAAE8O,eAAe5N,KAAKF,IAAImO,UAAUH,GAAaC,K,sBAG1D,SAAS7I,GACP,QAASlF,KAAKkO,SAAShJ,K,sBAGzB,SAASA,GACP,OAAOlF,KAAKgL,OAAO1I,IAAI4C,K,2BAGzB,SAAcvD,GACZ3B,KAAKgL,OAAOxI,IAAIb,EAAKjB,KAAKyN,MAAMjJ,KAAMvD,K,iCAGxC,SAAoBA,GAClB,GAAIA,EAAKyM,qBACPpO,KAAKqO,cAAc1M,QACd,GAAIA,EAAK4H,wBACdvJ,KAAK6I,gBAAgB,UAAWlH,EAAKW,IAAI,MAAOX,QAC3C,GAAIA,EAAK6D,wBAAyB,CACvC,IADuC,EACjCmE,EAAehI,EAAKW,IAAI,gBADS,IAGlBqH,GAHkB,IAGvC,2BAAmC,KAAxBjB,EAAwB,QACjC1I,KAAK6I,gBAAgBlH,EAAKjB,KAAKqM,KAAMrE,IAJA,oCAMlC,GAAI/G,EAAK2H,qBACdtJ,KAAK6I,gBAAgB,MAAOlH,QACvB,GAAIA,EAAK0E,sBAAuB,CACrC,IADqC,EAC/BgB,EAAa1F,EAAKW,IAAI,cADS,IAGb+E,GAHa,IAGrC,2BAAoC,KAAzBiH,EAAyB,QAClCtO,KAAK6I,gBAAgB,SAAUyF,IAJI,oCAMhC,GAAI3M,EAAK4E,sBAAuB,CACrC,IAAMmC,EAAS/G,EAAKW,IAAI,gBAEpBoG,EAAOY,sBAAwBZ,EAAOa,yBAA2Bb,EAAOlD,0BAC1ExF,KAAK+I,oBAAoBL,QAG3B1I,KAAK6I,gBAAgB,UAAWlH,K,gCAIpC,WACE,OAAO7C,EAAEyP,gBAAgB,OAAQzP,EAAEkP,eAAe,IAAI,K,uCAGxD,SAA0BrM,GAGxB,IAFA,IAAM6M,EAAM7M,EAAKkI,wBAEjB,MAAmB5L,OAAOmF,KAAKoL,GAA/B,eAAqC,CAAhC,IAAMtJ,EAAI,KACPsE,EAAUxJ,KAAKyJ,WAAWvE,GAC5BsE,GAASA,EAAQiF,SAAS9M,M,6BAIlC,SAAgBoL,EAAMpL,GAA0B,IAApB+M,EAAoB,uDAAN/M,EACxC,IAAKoL,EAAM,MAAM,IAAI4B,eAAe,aAEpC,GAAIhN,EAAK6D,wBAAT,CACE,IADgC,EAC1BoJ,EAAcjN,EAAKW,IAAI,gBADG,IAGXsM,GAHW,IAGhC,2BAAkC,KAAvBlG,EAAuB,QAChC1I,KAAK6I,gBAAgBkE,EAAMrE,IAJG,oCAalC,IAHA,IAAM3I,EAASC,KAAK4I,mBACd4F,EAAM7M,EAAKkN,4BAA2B,GAE5C,MAAmB5Q,OAAOmF,KAAKoL,GAA/B,eAAqC,CAAhC,IAAMtJ,EAAI,KACbnF,EAAOiJ,WAAW9D,IAAQ,EADS,UAGlBsJ,EAAItJ,IAHc,IAGnC,2BAA4B,KAAjB+C,EAAiB,QACpBP,EAAQ1H,KAAK8O,cAAc5J,GAEjC,GAAIwC,EAAO,CACT,GAAIA,EAAMiE,aAAe1D,EAAI,SAC7BjI,KAAK+O,2BAA2BrH,EAAOqF,EAAM7H,EAAM+C,GAGjDP,EACF1H,KAAKgP,0BAA0BN,GAE/B1O,KAAKqK,SAASnF,GAAQ,IAAI4B,EAASzI,QAAQ,CACzCsN,WAAY1D,EACZnH,MAAOd,KACP2B,KAAM+M,EACN3B,KAAMA,KAlBuB,kC,uBAyBvC,SAAUrM,GACRV,KAAKkL,QAAQxK,EAAKwE,MAAQxE,I,oBAG5B,SAAOwE,GACL,IAAIpE,EAAQd,KAEZ,GACE,GAAIc,EAAMqK,KAAKjG,GAAO,OAAO,QACtBpE,EAAQA,EAAMf,QAEvB,OAAO,I,uBAGT,SAAUmF,GACR,IAAIpE,EAAQd,KAEZ,GACE,GAAIc,EAAMoK,QAAQhG,GAAO,OAAO,QACzBpE,EAAQA,EAAMf,QAEvB,OAAO,I,0BAGT,SAAamF,GACX,QAASlF,KAAK4I,mBAAmBI,WAAW9D,K,oBAG9C,SAAOxE,EAAMuO,GACX,GAAInQ,EAAE+F,aAAanE,GAAO,CACxB,IAAM8I,EAAUxJ,KAAKyJ,WAAW/I,EAAKwE,MACrC,QAAKsE,KACDyF,GAAsBzF,EAAQmD,UAE7B,GAAI7N,EAAEoQ,QAAQxO,GACnB,QAAIA,EAAKyO,aAAenP,KAAKmG,OAAOzF,EAAKyO,WAAYF,KAI9CjP,KAAKmG,OAAOzF,EAAK0O,KAAMH,GACzB,GAAInQ,EAAEuQ,YAAY3O,GAAO,WACTA,EAAK0O,MADI,IAC9B,2BAAgC,KAArBE,EAAqB,QAC9B,IAAKtP,KAAKmG,OAAOmJ,EAAQL,GAAgB,OAAO,GAFpB,8BAK9B,OAAO,EACF,GAAInQ,EAAEyQ,SAAS7O,GACpB,OAAOV,KAAKmG,OAAOzF,EAAKgF,KAAMuJ,IAAkBjP,KAAKmG,OAAOzF,EAAK8O,MAAOP,GACnE,GAAInQ,EAAE6O,kBAAkBjN,GAAO,WACjBA,EAAK+O,UADY,IACpC,2BAAkC,KAAvBC,EAAuB,QAChC,IAAK1P,KAAKmG,OAAOuJ,EAAMT,GAAgB,OAAO,GAFZ,8BAKpC,OAAO,EACF,GAAInQ,EAAE6H,mBAAmBjG,GAAO,WAClBA,EAAKqH,YADa,IACrC,2BAAoC,KAAzB4H,EAAyB,QAClC,IAAK3P,KAAKmG,OAAOwJ,EAAMV,GAAgB,OAAO,GAFX,8BAKrC,OAAO,EACF,GAAInQ,EAAE0M,SAAS9K,GACpB,QAAIA,EAAKkP,WAAa5P,KAAKmG,OAAOzF,EAAKD,IAAKwO,MAC1B,QAAdvO,EAAKqM,MAAgC,QAAdrM,EAAKqM,MAE3B,GAAIjO,EAAE+Q,WAAWnP,GACtB,QAAIA,EAAKkP,WAAa5P,KAAKmG,OAAOzF,EAAKD,IAAKwO,KACrCjP,KAAKmG,OAAOzF,EAAKtC,MAAO6Q,GAC1B,GAAInQ,EAAEgR,kBAAkBpP,GAC7B,OAAOV,KAAKmG,OAAOzF,EAAKsH,SAAUiH,GAC7B,GAAInQ,EAAEiR,2BAA2BrP,GACtC,OAAO5B,EAAEkR,eAAetP,EAAKuP,IAAK,gBAAkBjQ,KAAKkM,WAAW,UAAU,IAASlM,KAAKmG,OAAOzF,EAAKwP,MAAOjB,GAC1G,GAAInQ,EAAEqR,kBAAkBzP,GAAO,WACXA,EAAK0P,aADM,IACpC,2BAA2C,KAAhClI,EAAgC,QACzC,IAAKlI,KAAKmG,OAAO+B,EAAY+G,GAAgB,OAAO,GAFlB,8BAKpC,OAAO,EAEP,OAAOnQ,EAAEuR,UAAU3P,K,qBAIvB,SAAQD,EAAKO,GACX,OAAOhB,KAAKY,KAAKH,GAAOO,I,qBAG1B,SAAQP,GACN,IAAIK,EAAQd,KAEZ,EAAG,CACD,IAAMY,EAAOE,EAAMF,KAAKH,GACxB,GAAY,MAARG,EAAc,OAAOA,QAClBE,EAAQA,EAAMf,U,wBAGzB,SAAWU,GACT,IAAIK,EAAQd,KAEZ,EAAG,CAEW,MADCc,EAAMF,KAAKH,KACNK,EAAMF,KAAKH,GAAO,YAC7BK,EAAQA,EAAMf,U,kBAGzB,WACOC,KAAKiL,SACRjL,KAAKiL,QAAS,EACdjL,KAAKsQ,W,mBAIT,WACE,IAAM3O,EAAO3B,KAAK2B,KAClB3B,KAAKgJ,WAAa/K,OAAOgD,OAAO,MAChCjB,KAAKqK,SAAWpM,OAAOgD,OAAO,MAC9BjB,KAAKkL,QAAUjN,OAAOgD,OAAO,MAC7BjB,KAAKmL,KAAOlN,OAAOgD,OAAO,MAC1BjB,KAAKY,KAAO3C,OAAOgD,OAAO,MAC1B,IAAMsP,EAAgBvQ,KAAK4I,mBAC3B,IAAI2H,EAAcnF,SAAlB,CACA,IAAMlL,EAAQ,CACZ8I,WAAY,GACZG,mBAAoB,GACpBc,YAAa,IAIf,GAFAjK,KAAKoL,UAAW,EAEE,YAAdzJ,EAAKhB,MAAsB4H,EAAiBiI,UAAW,WACrCjI,EAAiBkI,OADoB,IACzD,2BAA4C,EAC1CC,EAD0C,SACpC/O,EAAMzB,IAF2C,8BAKzD,IAAMyQ,EAAepI,EAAiB5G,EAAKhB,MAE3C,GAAIgQ,EAAc,WACIA,EAAaF,OADjB,IAChB,2BAAwC,EACtCC,EADsC,SAChC/O,EAAMzB,IAFE,gCAOpByB,EAAKiP,SAASrI,EAAkBrI,GAChCF,KAAKoL,UAAW,EA/BV,UAiCalL,EAAM+J,aAjCnB,IAiCN,2BAAsC,CAGpC,IAHoC,IAA3BtI,EAA2B,QAC9B6M,EAAM7M,EAAKkI,wBAEjB,MAAmB5L,OAAOmF,KAAKoL,GAA/B,eAAqC,CAAhC,IAAMtJ,EAAI,KACTvD,EAAKb,MAAM2I,WAAWvE,IAC1BqL,EAAcM,UAAUrC,EAAItJ,IAG9BvD,EAAKb,MAAMkO,0BAA0BrN,IAzCjC,wCA4CYzB,EAAM8I,YA5ClB,IA4CN,2BAAoC,KAAzB8H,EAAyB,QAC5BtH,EAAUsH,EAAIhQ,MAAM2I,WAAWqH,EAAIpQ,KAAKwE,MAE1CsE,EACFA,EAAQE,UAAUoH,GAElBP,EAAcM,UAAUC,EAAIpQ,OAlD1B,wCAsDaR,EAAMiJ,oBAtDnB,IAsDN,2BAA6C,KAAlCxH,EAAkC,QAC3CA,EAAKb,MAAMkO,0BAA0BrN,IAvDjC,kC,kBA2DR,SAAKxB,GACH,IAAIwB,EAAO3B,KAAK2B,KAEXA,EAAKoP,oBAAuBpP,EAAKqP,cACpCrP,EAAO3B,KAAK+J,iBAAiBpI,MAG3BA,EAAKsP,sBACPtP,GAAQ3B,KAAK2I,qBAAuB3I,KAAK4I,oBAAoBjH,OAG3DA,EAAKuP,UAAYvP,EAAKwP,iBAAmBxP,EAAKyP,gBAChDzP,EAAK0P,cACL1P,EAAOA,EAAKW,IAAI,SAGlB,IAAMgP,EAASnR,EAAKmR,OACdvE,EAAO5M,EAAK4M,MAAQ,MACpBwE,EAAiC,MAApBpR,EAAKqR,YAAsB,EAAIrR,EAAKqR,YACjDC,EAAU,eAAH,OAAkB1E,EAAlB,YAA0BwE,GACnCG,GAAcJ,GAAU3P,EAAKgQ,QAAQF,GAEzC,IAAKC,EAAY,CACf,IAAMhJ,EAAS5J,EAAE8S,oBAAoB7E,EAAM,IAC3CrE,EAAO8I,YAAcD,EAFN,MAGA5P,EAAKkQ,iBAAiB,OAAQ,CAACnJ,IAA7CgJ,EAHc,UAIVJ,GAAQ3P,EAAKmQ,QAAQL,EAASC,GAGrC,IAAMK,EAAajT,EAAEkT,mBAAmB7R,EAAK8H,GAAI9H,EAAKyF,MACtD8L,EAAWhR,KAAKiJ,aAAa1G,KAAK8O,GAClC/R,KAAK6I,gBAAgBkE,EAAM2E,EAAWpP,IAAI,gBAAgB2P,S,8BAG5D,WACE,IAAInR,EAAQd,KAEZ,GACE,GAAIc,EAAMa,KAAKqP,YACb,OAAOlQ,QAEFA,EAAQA,EAAMf,QAEvB,MAAM,IAAIsB,MAAM,6B,+BAGlB,WACE,IAAIP,EAAQd,KAEZ,GACE,GAAIc,EAAMa,KAAKuQ,mBACb,OAAOpR,QAEFA,EAAQA,EAAMf,QAEvB,OAAO,O,4BAGT,WACE,IAAIe,EAAQd,KAEZ,GACE,GAAIc,EAAMa,KAAKwQ,gBACb,OAAOrR,QAEFA,EAAQA,EAAMf,QAEvB,MAAM,IAAIsB,MAAM,kF,4BAGlB,WACE,IAAMmN,EAAMvQ,OAAOgD,OAAO,MACtBH,EAAQd,KAEZ,EAAG,CACD,cAAkB/B,OAAOmF,KAAKtC,EAAMuJ,UAApC,eAA+C,CAA1C,IAAM5J,EAAG,KACRA,KAAO+N,KAAQ,IACjBA,EAAI/N,GAAOK,EAAMuJ,SAAS5J,IAI9BK,EAAQA,EAAMf,aACPe,GAET,OAAO0N,I,kCAGT,WAA+B,IAC7B,IAAMA,EAAMvQ,OAAOgD,OAAO,MADG,mBAAPmR,EAAO,yBAAPA,EAAO,gBAG7B,cAAmBA,EAAnB,eAA0B,CAArB,IAAMrF,EAAI,KACTjM,EAAQd,KAEZ,EAAG,CACD,cAAmB/B,OAAOmF,KAAKtC,EAAMuJ,UAArC,eAAgD,CAA3C,IAAMnF,EAAI,KACPsE,EAAU1I,EAAMuJ,SAASnF,GAC3BsE,EAAQuD,OAASA,IAAMyB,EAAItJ,GAAQsE,GAGzC1I,EAAQA,EAAMf,aACPe,GAGX,OAAO0N,I,qCAGT,SAAwBtJ,EAAMxE,GAC5B,OAAOV,KAAKqS,qBAAqBnN,KAAUxE,I,wBAG7C,SAAWwE,GACT,IACIoN,EADAxR,EAAQd,KAGZ,EAAG,CACD,IAGMuS,EAHA/I,EAAU1I,EAAMgO,cAAc5J,GAEpC,GAAIsE,EAGF,GAAsC,OAAjC+I,EAAgBD,KAAyBC,EAAcrJ,aAAgC,UAAjBM,EAAQuD,KACjF,OAAOvD,EAIX8I,EAAexR,EAAMa,WACdb,EAAQA,EAAMf,U,2BAGzB,SAAcmF,GACZ,OAAOlF,KAAKqK,SAASnF,K,kCAGvB,SAAqBA,GACnB,IAAIsN,EAEJ,OAAqD,OAA7CA,EAAmBxS,KAAKyJ,WAAWvE,SAAiB,EAASsN,EAAiB7G,a,qCAGxF,SAAwBzG,GACtB,IAAMsE,EAAUxJ,KAAKqK,SAASnF,GAC9B,OAAkB,MAAXsE,OAAkB,EAASA,EAAQmC,a,2BAG5C,SAAczG,GACZ,QAASlF,KAAK8O,cAAc5J,K,wBAG9B,SAAWA,EAAMuN,GACf,QAAKvN,MACDlF,KAAK0S,cAAcxN,OACnBlF,KAAK2S,iBAAiBzN,EAAMuN,OAC5BzS,KAAK4S,OAAO1N,OACXuN,IAAanO,EAAM4G,QAAQ2H,SAAS3N,OACpCuN,IAAanO,EAAMwO,iBAAiBD,SAAS3N,U,8BAIpD,SAAiBA,EAAMuN,GACrB,IAAIM,EAEJ,OAAuC,OAA/BA,EAAe/S,KAAKD,aAAkB,EAASgT,EAAa7G,WAAWhH,EAAMuN,K,2BAGvF,SAAcvN,EAAMpE,GAClB,IAAMkS,EAAOhT,KAAKyJ,WAAWvE,GAEzB8N,IACFA,EAAKlS,MAAMmS,iBAAiB/N,GAC5B8N,EAAKlS,MAAQA,EACbA,EAAMuJ,SAASnF,GAAQ8N,K,8BAI3B,SAAiB9N,UACRlF,KAAKqK,SAASnF,K,2BAGvB,SAAcA,GACZ,IAAIgO,EAE2C,OAA9CA,EAAoBlT,KAAKyJ,WAAWvE,KAA0BgO,EAAkBpS,MAAMmS,iBAAiB/N,GACxG,IAAIpE,EAAQd,KAEZ,GACMc,EAAMqK,KAAKjG,KACbpE,EAAMqK,KAAKjG,IAAQ,SAEdpE,EAAQA,EAAMf,Y,KAK3B5B,EAAQE,QAAUiG,EAClBA,EAAM4G,QAAUjN,OAAOmF,KAAK2D,EAASoM,SACrC7O,EAAMwO,iBAAmB,CAAC,YAAa,YAAa,WAAY,Q,qDCh8BhE7U,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,E,IAEZ+U,E,WACJ,cAKG,IAJDzH,EAIC,EAJDA,WACA7K,EAGC,EAHDA,MACAa,EAEC,EAFDA,KACAoL,EACC,EADDA,KACC,UACD/M,KAAK2L,gBAAa,EAClB3L,KAAKc,WAAQ,EACbd,KAAK2B,UAAO,EACZ3B,KAAK+M,UAAO,EACZ/M,KAAKmJ,mBAAqB,GAC1BnJ,KAAK2M,UAAW,EAChB3M,KAAKqT,eAAiB,GACtBrT,KAAKsT,YAAa,EAClBtT,KAAKgJ,WAAa,EAClBhJ,KAAK2L,WAAaA,EAClB3L,KAAKc,MAAQA,EACbd,KAAK2B,KAAOA,EACZ3B,KAAK+M,KAAOA,EACZ/M,KAAKuT,a,oCAGP,WACEvT,KAAKuT,aACLvT,KAAKwT,iBAAkB,I,sBAGzB,SAASpV,GACH4B,KAAKwT,kBACTxT,KAAKyT,UAAW,EAChBzT,KAAK5B,MAAQA,K,wBAGf,WACE4B,KAAKwT,iBAAkB,EACvBxT,KAAKyT,UAAW,EAChBzT,KAAK5B,MAAQ,O,sBAGf,SAASuD,GACP3B,KAAK2M,UAAW,GAE+B,IAA3C3M,KAAKmJ,mBAAmBnG,QAAQrB,IAIpC3B,KAAKmJ,mBAAmBlG,KAAKtB,K,uBAG/B,SAAUA,IACmC,IAAvC3B,KAAKqT,eAAerQ,QAAQrB,KAIhC3B,KAAKsT,YAAa,EAClBtT,KAAKgJ,aACLhJ,KAAKqT,eAAepQ,KAAKtB,M,yBAG3B,WACE3B,KAAKgJ,aACLhJ,KAAKsT,aAAetT,KAAKgJ,e,KAK7B7K,EAAQE,QAAU+U,G,6DCxElBnV,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAIqV,EAAQhV,EAAQ,KAEhBI,EAAIJ,EAAQ,IAIViV,E,WACJ,WAAY7S,EAAOX,EAAMD,EAAOI,GAAY,UAC1CN,KAAK4T,MAAQ,KACb5T,KAAK6T,cAAgB,KACrB7T,KAAKM,WAAaA,EAClBN,KAAKc,MAAQA,EACbd,KAAKE,MAAQA,EACbF,KAAKG,KAAOA,E,qCAGd,SAAYO,GACV,IAAMP,EAAOH,KAAKG,KAClB,GAAIA,EAAKsQ,OAAStQ,EAAKkJ,KAAM,OAAO,EACpC,GAAIlJ,EAAKO,EAAKC,MAAO,OAAO,EAC5B,IAAMyC,EAAOtE,EAAEgV,aAAapT,EAAKC,MACjC,GAAc,MAARyC,IAAgBA,EAAKkE,OAAS,OAAO,EAL3B,UAOElE,GAPF,IAOhB,2BAAwB,CACtB,GAAI1C,EADkB,SACP,OAAO,GARR,8BAWhB,OAAO,I,oBAGT,SAAOA,EAAMqT,EAAKtT,EAAKD,GACrB,OAAOkT,EAAMrV,QAAQiE,IAAI,CACvBhC,WAAYN,KAAKM,WACjBP,OAAQW,EACRH,UAAWwT,EACXtT,IAAKA,EACLD,c,wBAIJ,SAAWmB,EAAMqS,GACf,GAAIhU,KAAKiU,KACP,MAAM,IAAI5S,MAAM,2BAGdrB,KAAK4T,QACHI,EACFhU,KAAK4T,MAAM3Q,KAAKtB,GAEhB3B,KAAK6T,cAAc5Q,KAAKtB,M,2BAK9B,SAAcpB,EAAWR,EAAQS,GAC/B,GAAyB,IAArBD,EAAU+G,OAAc,OAAO,EAGnC,IAFA,IAAMsM,EAAQ,GAELnT,EAAM,EAAGA,EAAMF,EAAU+G,OAAQ7G,IAAO,CAC/C,IAAMC,EAAOH,EAAUE,GAEnBC,GAAQV,KAAKkU,YAAYxT,IAC3BkT,EAAM3Q,KAAKjD,KAAKiB,OAAOlB,EAAQQ,EAAWE,EAAKD,IAInD,OAAOR,KAAKmU,WAAWP,K,yBAGzB,SAAYlT,EAAMD,GAChB,QAAIT,KAAKkU,YAAYxT,EAAKD,KACjBT,KAAKmU,WAAW,CAACnU,KAAKiB,OAAOP,EAAMA,EAAMD,O,wBAMpD,SAAWmT,GACT5T,KAAK4T,MAAQA,EACb5T,KAAK6T,cAAgB,GACrB,IAHgB,EAGVO,EAAU,IAAIC,QAChBC,GAAO,EAJK,IAMGV,GANH,IAMhB,2BAA0B,KAAfjS,EAAe,QAOxB,GANAA,EAAK4S,SAEwB,IAAzB5S,EAAK1B,SAASqH,QAAgB3F,EAAK1B,SAAS0B,EAAK1B,SAASqH,OAAS,KAAOtH,MAC5E2B,EAAK6S,YAAYxU,MAGF,OAAb2B,EAAKlB,IAAT,CAtFUgU,MA4FV,IACE/T,EACEiB,EADFjB,KAEF,IAAI0T,EAAQ3J,IAAI/J,GAAhB,CAGA,GAFIA,GAAM0T,EAAQM,IAAIhU,GAElBiB,EAAK+O,QAAS,CAChB4D,GAAO,EACP,MAGF,GAAItU,KAAK6T,cAAcvM,SACrBgN,EAAOtU,KAAKmU,WAAWnU,KAAK6T,eAC5B7T,KAAK6T,cAAgB,GACrB7T,KAAK4T,MAAQA,EACTU,GAAM,SAlCE,wCAsCGV,GAtCH,IAsChB,2BAA0B,SACnBe,cAvCS,8BA2ChB,OADA3U,KAAK4T,MAAQ,KACNU,I,mBAGT,SAAM5T,EAAMD,GACV,IAAMmU,EAAQlU,EAAKD,GACnB,QAAKmU,IAEDC,MAAMC,QAAQF,GACT5U,KAAK+U,cAAcH,EAAOlU,EAAMD,GAEhCT,KAAKgV,YAAYtU,EAAMD,Q,KAMpCtC,EAAQE,QAAUsV,G,qBC/IlB,YAMAxV,EAAQ8W,WA2IR,SAAoBlH,GAQnB,GAPAA,EAAK,IAAM/N,KAAKkV,UAAY,KAAO,IAClClV,KAAKsI,WACJtI,KAAKkV,UAAY,MAAQ,KAC1BnH,EAAK,IACJ/N,KAAKkV,UAAY,MAAQ,KAC1B,IAAMC,EAAOhX,QAAQiX,SAASpV,KAAKqV,OAE/BrV,KAAKkV,UACT,OAGD,IAAMI,EAAI,UAAYtV,KAAKuV,MAC3BxH,EAAKyH,OAAO,EAAG,EAAGF,EAAG,kBAKrB,IAAIG,EAAQ,EACRC,EAAQ,EACZ3H,EAAK,GAAGjC,QAAQ,eAAe,SAAA6J,GAChB,OAAVA,IAGJF,IACc,OAAVE,IAGHD,EAAQD,OAIV1H,EAAKyH,OAAOE,EAAO,EAAGJ,IA1KvBnX,EAAQyX,KA6LR,SAAcC,GACb,IACKA,EACH1X,EAAQ2X,QAAQC,QAAQ,QAASF,GAEjC1X,EAAQ2X,QAAQE,WAAW,SAE3B,MAAOC,MAnMV9X,EAAQ+X,KA+MR,WACC,IAAIC,EACJ,IACCA,EAAIhY,EAAQ2X,QAAQM,QAAQ,SAC3B,MAAOH,KAMJE,GAAwB,qBAAZ1B,GAA2B,QAASA,IACpD0B,EAAI1B,8IAAY4B,OAGjB,OAAOF,GA5NRhY,EAAQ+W,UAyGR,WAIC,GAAsB,qBAAXoB,QAA0BA,OAAO7B,UAAoC,aAAxB6B,OAAO7B,QAAQ9T,MAAuB2V,OAAO7B,QAAQ8B,QAC5G,OAAO,EAIR,GAAyB,qBAAdC,WAA6BA,UAAUC,WAAaD,UAAUC,UAAUC,cAAcf,MAAM,yBACtG,OAAO,EAKR,MAA4B,qBAAbgB,UAA4BA,SAASC,iBAAmBD,SAASC,gBAAgBC,OAASF,SAASC,gBAAgBC,MAAMC,kBAEpH,qBAAXR,QAA0BA,OAAOhJ,UAAYgJ,OAAOhJ,QAAQyJ,SAAYT,OAAOhJ,QAAQ0J,WAAaV,OAAOhJ,QAAQ2J,QAGrG,qBAAdT,WAA6BA,UAAUC,WAAaD,UAAUC,UAAUC,cAAcf,MAAM,mBAAqBuB,SAASC,OAAOC,GAAI,KAAO,IAE9H,qBAAdZ,WAA6BA,UAAUC,WAAaD,UAAUC,UAAUC,cAAcf,MAAM,uBA9HtGxX,EAAQ2X,QAyOR,WACC,IAGC,OAAOuB,aACN,MAAOpB,KA9OQqB,GAClBnZ,EAAQoZ,QAAW,WAClB,IAAIC,GAAS,EAEb,OAAO,WACDA,IACJA,GAAS,EACTlK,QAAQmK,KAAK,2IANG,GAenBtZ,EAAQuZ,OAAS,CAChB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAsFDvZ,EAAQoP,IAAMD,QAAQ1N,OAAS0N,QAAQC,KAAQ,aAkE/C4H,EAAOhX,QAAUO,EAAQ,IAARA,CAAoBP,GAEhBgX,EAAOhX,QAArBwZ,WAMIC,EAAI,SAAUzV,GACxB,IACC,OAAO0V,KAAKC,UAAU3V,GACrB,MAAO8T,GACR,MAAO,+BAAiCA,EAAMlU,Y,kDCNhDoT,EAAOhX,QA9PP,SAAe4Z,GAqDd,SAASC,EAAY1P,GACpB,IAAI2P,EACAC,EAAiB,KAErB,SAAStY,IAAe,2BAANmO,EAAM,yBAANA,EAAM,gBAEvB,GAAKnO,EAAMoC,QAAX,CAIA,IAAMmW,EAAOvY,EAGPwY,EAAOC,OAAO,IAAIC,MAClBC,EAAKH,GAAQH,GAAYG,GAC/BD,EAAK9C,KAAOkD,EACZJ,EAAKK,KAAOP,EACZE,EAAKC,KAAOA,EACZH,EAAWG,EAEXrK,EAAK,GAAKiK,EAAYS,OAAO1K,EAAK,IAEX,kBAAZA,EAAK,IAEfA,EAAKlM,QAAQ,MAId,IAAI4T,EAAQ,EACZ1H,EAAK,GAAKA,EAAK,GAAGjC,QAAQ,iBAAiB,SAAC6J,EAAO+C,GAElD,GAAc,OAAV/C,EACH,MAAO,IAERF,IACA,IAAMkD,EAAYX,EAAYL,WAAWe,GACzC,GAAyB,oBAAdC,EAA0B,CACpC,IAAM3X,EAAM+M,EAAK0H,GACjBE,EAAQgD,EAAUC,KAAKT,EAAMnX,GAG7B+M,EAAKyH,OAAOC,EAAO,GACnBA,IAED,OAAOE,KAIRqC,EAAY/C,WAAW2D,KAAKT,EAAMpK,GAElC,IAAM8K,EAAQV,EAAK5K,KAAOyK,EAAYzK,IACtCsL,EAAMC,MAAMX,EAAMpK,IAuBnB,OApBAnO,EAAM0I,UAAYA,EAClB1I,EAAMsV,UAAY8C,EAAY9C,YAC9BtV,EAAM2V,MAAQyC,EAAYe,YAAYzQ,GACtC1I,EAAMoZ,OAASA,EACfpZ,EAAM2X,QAAUS,EAAYT,QAE5BtZ,OAAOC,eAAe0B,EAAO,UAAW,CACvCqZ,YAAY,EACZC,cAAc,EACd5W,IAAK,kBAAyB,OAAnB4V,EAA0BF,EAAYhW,QAAQsG,GAAa4P,GACtE1V,IAAK,SAAAL,GACJ+V,EAAiB/V,KAKa,oBAArB6V,EAAYpS,MACtBoS,EAAYpS,KAAKhG,GAGXA,EAGR,SAASoZ,EAAO1Q,EAAW6Q,GAC1B,IAAMC,EAAWpB,EAAYhY,KAAKsI,WAAkC,qBAAd6Q,EAA4B,IAAMA,GAAa7Q,GAErG,OADA8Q,EAAS7L,IAAMvN,KAAKuN,IACb6L,EAwFR,SAASC,EAAYC,GACpB,OAAOA,EAAOC,WACZC,UAAU,EAAGF,EAAOC,WAAWjS,OAAS,GACxCwE,QAAQ,UAAW,KA2BtB,OA1PAkM,EAAYpY,MAAQoY,EACpBA,EAAY3Z,QAAU2Z,EACtBA,EAAYS,OAuOZ,SAAgBzX,GACf,GAAIA,aAAeK,MAClB,OAAOL,EAAIyY,OAASzY,EAAIe,QAEzB,OAAOf,GA1ORgX,EAAY0B,QA2KZ,WACC,IAAM7D,EAAa,YACfmC,EAAY2B,MAAMxM,IAAIkM,IADP,EAEfrB,EAAY4B,MAAMzM,IAAIkM,GAAalM,KAAI,SAAA7E,GAAS,MAAI,IAAMA,OAC5DxG,KAAK,KAEP,OADAkW,EAAY6B,OAAO,IACZhE,GAhLRmC,EAAY6B,OA0IZ,SAAgBhE,GAMf,IAAI9J,EALJiM,EAAYpC,KAAKC,GAEjBmC,EAAY2B,MAAQ,GACpB3B,EAAY4B,MAAQ,GAGpB,IAAME,GAA+B,kBAAfjE,EAA0BA,EAAa,IAAIiE,MAAM,UACjEC,EAAMD,EAAMxS,OAElB,IAAKyE,EAAI,EAAGA,EAAIgO,EAAKhO,IACf+N,EAAM/N,KAOW,OAFtB8J,EAAaiE,EAAM/N,GAAGD,QAAQ,MAAO,QAEtB,GACdkM,EAAY4B,MAAM3W,KAAK,IAAIkU,OAAO,IAAMtB,EAAWmE,OAAO,GAAK,MAE/DhC,EAAY2B,MAAM1W,KAAK,IAAIkU,OAAO,IAAMtB,EAAa,QA9JxDmC,EAAYhW,QAyLZ,SAAiBkD,GAChB,GAA8B,MAA1BA,EAAKA,EAAKoC,OAAS,GACtB,OAAO,EAGR,IAAIyE,EACAgO,EAEJ,IAAKhO,EAAI,EAAGgO,EAAM/B,EAAY4B,MAAMtS,OAAQyE,EAAIgO,EAAKhO,IACpD,GAAIiM,EAAY4B,MAAM7N,GAAGkO,KAAK/U,GAC7B,OAAO,EAIT,IAAK6G,EAAI,EAAGgO,EAAM/B,EAAY2B,MAAMrS,OAAQyE,EAAIgO,EAAKhO,IACpD,GAAIiM,EAAY2B,MAAM5N,GAAGkO,KAAK/U,GAC7B,OAAO,EAIT,OAAO,GA5MR8S,EAAY5C,SAAW1W,EAAQ,KAC/BsZ,EAAYT,QA6OZ,WACCjK,QAAQmK,KAAK,0IA5OdxZ,OAAOmF,KAAK2U,GAAKmC,SAAQ,SAAAzZ,GACxBuX,EAAYvX,GAAOsX,EAAItX,MAOxBuX,EAAY2B,MAAQ,GACpB3B,EAAY4B,MAAQ,GAOpB5B,EAAYL,WAAa,GAkBzBK,EAAYe,YAVZ,SAAqBzQ,GAGpB,IAFA,IAAI6R,EAAO,EAEFpO,EAAI,EAAGA,EAAIzD,EAAUhB,OAAQyE,IACrCoO,GAASA,GAAQ,GAAKA,EAAQ7R,EAAU8R,WAAWrO,GACnDoO,GAAQ,EAGT,OAAOnC,EAAYN,OAAO2C,KAAKC,IAAIH,GAAQnC,EAAYN,OAAOpQ,SA+M/D0Q,EAAY6B,OAAO7B,EAAY9B,QAExB8B,I,kBC7PR,IAAIuC,EAAI,IACJC,EAAQ,GAAJD,EACJE,EAAQ,GAAJD,EACJE,EAAQ,GAAJD,EACJE,EAAQ,EAAJD,EACJE,EAAQ,OAAJF,EAqJR,SAASG,EAAOtC,EAAIuC,EAAOC,EAAG7V,GAC5B,IAAI8V,EAAWF,GAAa,IAAJC,EACxB,OAAOV,KAAKY,MAAM1C,EAAKwC,GAAK,IAAM7V,GAAQ8V,EAAW,IAAM,IAvI7D7F,EAAOhX,QAAU,SAAS6C,EAAKka,GAC7BA,EAAUA,GAAW,GACrB,IAAIva,SAAcK,EAClB,GAAa,WAATL,GAAqBK,EAAIsG,OAAS,EACpC,OAkBJ,SAAe6T,GAEb,IADAA,EAAMC,OAAOD,IACL7T,OAAS,IACf,OAEF,IAAIqO,EAAQ,mIAAmI0F,KAC7IF,GAEF,IAAKxF,EACH,OAEF,IAAIoF,EAAIO,WAAW3F,EAAM,IAEzB,QADYA,EAAM,IAAM,MAAMe,eAE5B,IAAK,QACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,IACH,OAAOqE,EAAIH,EACb,IAAK,QACL,IAAK,OACL,IAAK,IACH,OAAOG,EAAIJ,EACb,IAAK,OACL,IAAK,MACL,IAAK,IACH,OAAOI,EAAIL,EACb,IAAK,QACL,IAAK,OACL,IAAK,MACL,IAAK,KACL,IAAK,IACH,OAAOK,EAAIN,EACb,IAAK,UACL,IAAK,SACL,IAAK,OACL,IAAK,MACL,IAAK,IACH,OAAOM,EAAIP,EACb,IAAK,UACL,IAAK,SACL,IAAK,OACL,IAAK,MACL,IAAK,IACH,OAAOO,EAAIR,EACb,IAAK,eACL,IAAK,cACL,IAAK,QACL,IAAK,OACL,IAAK,KACH,OAAOQ,EACT,QACE,QAvEKQ,CAAMva,GACR,GAAa,WAATL,GAAqB6a,SAASxa,GACvC,OAAOka,EAAQO,KA0GnB,SAAiBlD,GACf,IAAIuC,EAAQT,KAAKC,IAAI/B,GACrB,GAAIuC,GAASJ,EACX,OAAOG,EAAOtC,EAAIuC,EAAOJ,EAAG,OAE9B,GAAII,GAASL,EACX,OAAOI,EAAOtC,EAAIuC,EAAOL,EAAG,QAE9B,GAAIK,GAASN,EACX,OAAOK,EAAOtC,EAAIuC,EAAON,EAAG,UAE9B,GAAIM,GAASP,EACX,OAAOM,EAAOtC,EAAIuC,EAAOP,EAAG,UAE9B,OAAOhC,EAAK,MAxHYmD,CAAQ1a,GAiFlC,SAAkBuX,GAChB,IAAIuC,EAAQT,KAAKC,IAAI/B,GACrB,GAAIuC,GAASJ,EACX,OAAOL,KAAKY,MAAM1C,EAAKmC,GAAK,IAE9B,GAAII,GAASL,EACX,OAAOJ,KAAKY,MAAM1C,EAAKkC,GAAK,IAE9B,GAAIK,GAASN,EACX,OAAOH,KAAKY,MAAM1C,EAAKiC,GAAK,IAE9B,GAAIM,GAASP,EACX,OAAOF,KAAKY,MAAM1C,EAAKgC,GAAK,IAE9B,OAAOhC,EAAK,KA/F2BoD,CAAS3a,GAEhD,MAAM,IAAIK,MACR,wDACEwW,KAAKC,UAAU9W,M,6DCjCrB/C,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAEHK,EAAQ,KAAvB,IAEIkd,EAAgCld,EAAQ,KAExCI,EAAIJ,EAAQ,IAEVmd,EAAgB,CACpBlX,qBADoB,WAGjBzE,GAAO,IADRQ,EACQ,EADRA,KAEIA,EAAKwE,OAAShF,EAAM8M,UACtBtM,EAAKwE,KAAOhF,EAAM+M,UAItB3I,MAToB,SASd3C,EAAMzB,GACLyB,EAAKb,MAAMgb,wBAAwB5b,EAAM8M,QAAS9M,EAAMsJ,QAAQmC,aAuGzE,SAAqChK,GACnC,IAAKA,EAAK6J,aAAe7J,EAAKjB,KAAKkP,SAEjC,YADAjO,EAAKoa,OAIP,IANyC,EAMnC3Y,EAAOtE,EAAEgV,aAAanS,EAAKhB,MANQ,IAQvByC,GARuB,IAQzC,2BAAwB,KAAb3C,EAAa,QACV,QAARA,GAAekB,EAAKqa,QAAQvb,IATO,+BAtGrCwb,CAA4Bta,IAIhC,sDAfoB,SAekCA,EAAMzB,GAC1D,IAAIyB,EAAK6D,wBAAT,CACA,IAAMgJ,EAAM7M,EAAKkN,6BAEjB,IAAK,IAAM3J,KAAQsJ,EACbtJ,IAAShF,EAAM8M,UAASwB,EAAItJ,GAAMA,KAAOhF,EAAM+M,YAMnDiP,E,WACJ,WAAY1S,EAASwD,EAASC,GAAS,UACrCjN,KAAKiN,QAAUA,EACfjN,KAAKgN,QAAUA,EACfhN,KAAKwJ,QAAUA,E,2DAGjB,SAAkC2S,GAChC,IAAMC,EAAoBD,EAAa7b,WAElC8b,EAAkB7V,wBAInB6V,EAAkB7U,+BAAiC6U,EAAkB9Z,IAAI,eAAe5B,KAAKuH,KAIjG,EAAI2T,EAA8Bvd,SAAS+d,M,sDAG7C,SAAyCza,M,qDASzC,SAAwCA,M,oBAWxC,SAAOoJ,GAAO,WAEVvB,EAGExJ,KAHFwJ,QACAwD,EAEEhN,KAFFgN,QACAC,EACEjN,KADFiN,QAGAnM,EAEE0I,EAFF1I,MAGIqb,EADF3S,EADF7H,KAEwB0a,MAAK,SAAA1a,GAAI,OAAIA,EAAK2a,iBAAmB3a,EAAK6I,wBAA0B7I,EAAK4a,uBAE/FJ,IACiBA,EAAatN,6BAEjB7B,KAAaxD,EAAQmC,YAClC3L,KAAKwc,kCAAkCL,IAI3C,IAAMM,EAAkB1R,GAASjK,EAAMiK,MAE2B,qBAA1C,MAAnB0R,OAA0B,EAASA,EAAgB9b,MACtD8b,EAAgBC,MAAMxC,SAAQ,SAAA5E,GAC5BxU,EAAM8P,SAAS0E,EAAGuG,EAAe,MAGnC/a,EAAM8P,SAAS6L,EAAiBZ,EAAe7b,MAG5C+K,IACHjK,EAAMmS,iBAAiBjG,GACvBlM,EAAMuJ,SAAS4C,GAAWzD,EAC1BxJ,KAAKwJ,QAAQmC,WAAWzG,KAAO+H,GAG7BkP,IACFnc,KAAK2c,yCAAyCR,GAC9Cnc,KAAK4c,wCAAwCT,Q,KAMnDhe,EAAQE,QAAU6d,G,6CC1HlBje,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ0e,WAeR,SAAoBC,GAClB,IAAInb,EAAO3B,KAEX,KAAO2B,EAAOA,EAAKrB,YACjB,GAAIwc,EAASnb,GAAO,OAAOA,EAG7B,OAAO,MArBTxD,EAAQke,KAwBR,SAAcS,GACZ,IAAInb,EAAO3B,KAEX,GACE,GAAI8c,EAASnb,GAAO,OAAOA,QACpBA,EAAOA,EAAKrB,YAErB,OAAO,MA9BTnC,EAAQwK,kBAiCR,WACE,OAAO3I,KAAK6c,YAAW,SAAAE,GAAC,OAAIA,EAAE3L,iBAjChCjT,EAAQ6e,mBAoCR,WACE,IAAIrb,EAAO3B,KAEX,EAAG,CACD,IAAK2B,EAAKrB,YAAcuU,MAAMC,QAAQnT,EAAKpB,YAAcoB,EAAK4D,cAC5D,MAEA5D,EAAOA,EAAKrB,iBAEPqB,GAET,GAAIA,IAASA,EAAKqP,aAAerP,EAAKsb,UACpC,MAAM,IAAI5b,MAAM,wEAGlB,OAAOM,GAlDTxD,EAAQ+e,8BAqDR,SAAuC7a,GACrC,OAAOrC,KAAKmd,6BAA6B9a,GAAO,SAAU+a,EAASrR,EAAGsR,GACpE,IAAIC,EAD4E,EAE1Ela,EAAOtE,EAAEgV,aAAasJ,EAAQzc,MAF4C,IAIzD0c,GAJyD,IAIhF,2BAAmC,KAC3B1b,EAD2B,QACXoK,EAAI,GAE1B,GAAKuR,EAKL,GAAI3b,EAAKnB,SAAW8c,EAAS9c,UAAYmB,EAAKnB,SACxCmB,EAAKlB,IAAM6c,EAAS7c,IACtB6c,EAAW3b,OAKUyB,EAAKJ,QAAQsa,EAASC,WACvBna,EAAKJ,QAAQrB,EAAK4b,aAGxCD,EAAW3b,QAfX2b,EAAW3b,GARiE,8BA2BhF,OAAO2b,MAhFXnf,EAAQgf,6BAoFR,SAAsC9a,EAAOmb,GAAQ,WACnD,IAAKnb,EAAMiF,OACT,OAAOtH,KAGT,GAAqB,IAAjBqC,EAAMiF,OACR,OAAOjF,EAAM,GAGf,IACIob,EAAiBC,EADjBC,EAAWC,IAETP,EAAahb,EAAM8K,KAAI,SAAAxL,GAC3B,IAAMkc,EAAW,GAEjB,GACEA,EAAShc,QAAQF,UACTA,EAAOA,EAAKrB,aAAeqB,IAAS,GAM9C,OAJIkc,EAASvW,OAASqW,IACpBA,EAAWE,EAASvW,QAGfuW,KAEHC,EAAQT,EAAW,GAEzBU,EAAW,IAAK,IAAIhS,EAAI,EAAGA,EAAI4R,EAAU5R,IAAK,CAC5C,IAD4C,EACtCiS,EAAcF,EAAM/R,GADkB,IAGrBsR,GAHqB,IAG5C,2BAAmC,CACjC,GADiC,QACpBtR,KAAOiS,EAClB,MAAMD,GALkC,8BAS5CN,EAAkB1R,EAClB2R,EAAaM,EAGf,GAAIN,EACF,OAAIF,EACKA,EAAOE,EAAYD,EAAiBJ,GAEpCK,EAGT,MAAM,IAAIrc,MAAM,+BAjIpBlD,EAAQ8f,YAqIR,WACE,IAAItc,EAAO3B,KACLqC,EAAQ,GAEd,GACEA,EAAMY,KAAKtB,SACJA,EAAOA,EAAKrB,YAErB,OAAO+B,GA5ITlE,EAAQ+f,WA+IR,SAAoBC,GAClB,OAAOA,EAAgBC,aAAape,OA/ItC7B,EAAQigB,aAkJR,SAAsBC,GACpB,QAASre,KAAK6c,YAAW,SAAA9c,GAAM,OAAIA,IAAWse,MAlJhDlgB,EAAQmgB,OAqJR,WAAmC,IACjC,IAAI3c,EAAO3B,KADsB,mBAAhBue,EAAgB,yBAAhBA,EAAgB,gBAGjC,KAAO5c,GAAM,WACQ4c,GADR,IACX,2BAAmC,KAAxB5d,EAAwB,QACjC,GAAIgB,EAAKjB,KAAKC,OAASA,EAAM,OAAO,GAF3B,8BAKXgB,EAAOA,EAAKrB,WAGd,OAAO,GA9JT,IAAIxB,EAAIJ,EAAQ,IAEHA,EAAQ,M,6CChBrBT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQqgB,kBAWR,WACE,GAAIxe,KAAKye,eAAgB,OAAOze,KAAKye,eACrC,IAAI9d,EAAOX,KAAK0e,sBAAwB5f,EAAE6f,oBACtC7f,EAAE8f,iBAAiBje,KAAOA,EAAOA,EAAK8d,gBAC1C,OAAOze,KAAKye,eAAiB9d,GAd/BxC,EAAQugB,mBAmBR,WACE,IAAMhe,EAAOV,KAAKU,KAElB,IAAKA,EAAM,CACT,GAAiB,SAAbV,KAAKS,KAAkBT,KAAKM,WAAWue,uBAAwB,CACjE,IAAMnW,EAAS1I,KAAKM,WAAWA,WACzBwe,EAAepW,EAAOpI,WAE5B,MAAmB,SAAfoI,EAAOjI,KAAkBqe,EAAaC,mBACjCjgB,EAAEkgB,uBAGQ,SAAftW,EAAOjI,KAAkBqe,EAAaG,mBACjCngB,EAAE6f,oBAGJ7f,EAAEogB,qBAET,OAIJ,GAAIxe,EAAK+d,eACP,OAAO/d,EAAK+d,eAGd,GAAIU,EAA6B1U,IAAI/J,GACnC,OAGFye,EAA6BzK,IAAIhU,GAEjC,IACE,IAAI0e,EAEAC,EAAUC,EAAS5e,EAAKC,MAE5B,GAAI0e,EACF,OAAOA,EAAQzG,KAAK5Y,KAAMU,GAK5B,GAFA2e,EAAUC,EAAStf,KAAKM,WAAWK,MAEP,OAAvBye,EAAWC,IAAoBD,EAASG,YAC3C,OAAOvf,KAAKM,WAAWke,oBAZ3B,QAeEW,EAA6BK,OAAO9e,KAjExCvC,EAAQshB,WAqER,SAAoBC,EAAUC,GAC5B,OAAOC,EAAYF,EAAU1f,KAAKwe,oBAAqBmB,IArEzDxhB,EAAQ0hB,gBAgGR,SAAyB3a,GACvB,IAAMvE,EAAOX,KAAKwe,oBAClB,GAAI1f,EAAEghB,oBAAoBnf,GAAO,OAAO,EAExC,GAAI7B,EAAEihB,sBAAsBpf,GAAO,WACbA,EAAKiE,OADQ,IACjC,2BAAgC,KAArBob,EAAqB,QAC9B,GAAIlhB,EAAEghB,oBAAoBE,IAAUJ,EAAY1a,EAAM8a,GAAO,GAC3D,OAAO,GAHsB,8BAOjC,OAAO,EAEP,OAAOJ,EAAY1a,EAAMvE,GAAM,IA5GnCxC,EAAQ8hB,wBAgHR,SAAiCC,GAC/B,IAAMxa,EAAO1F,KAAKwe,oBACZhP,EAAQ0Q,EAAS1B,oBAEvB,IAAK1f,EAAEghB,oBAAoBpa,IAAS5G,EAAEqhB,qBAAqBza,GACzD,OAAO8J,EAAM7O,OAAS+E,EAAK/E,KAG7B,OAAO,GAvHTxC,EAAQuP,cA0HR,SAAuB0S,GACrB,IAAMzf,EAAOX,KAAKwe,oBAClB,OAAO1f,EAAEuhB,wBAAwB1f,IAAS7B,EAAE+F,aAAalE,EAAKsH,GAAI,CAChE/C,KAAMkb,KA3HV,IAAId,EAAW5gB,EAAQ,KAEnBI,EAAIJ,EAAQ,IAShB,IAAMygB,EAA+B,IAAI9K,QAyDzC,SAASuL,EAAYF,EAAU/e,EAAMgf,GACnC,GAAiB,WAAbD,EACF,OAAO5gB,EAAEwhB,uBAAuB3f,GAC3B,GAAiB,WAAb+e,EACT,OAAO5gB,EAAEyhB,uBAAuB5f,GAC3B,GAAiB,YAAb+e,EACT,OAAO5gB,EAAE0hB,wBAAwB7f,GAC5B,GAAiB,QAAb+e,EACT,OAAO5gB,EAAEghB,oBAAoBnf,GACxB,GAAiB,UAAb+e,EACT,OAAO5gB,EAAE2hB,sBAAsB9f,GAC1B,GAAiB,UAAb+e,EACT,OAAO5gB,EAAE4hB,sBAAsB/f,GAC1B,GAAiB,SAAb+e,EACT,OAAO5gB,EAAE6hB,qBAAqBhgB,GAE9B,GAAIgf,EACF,OAAO,EAEP,MAAM,IAAIte,MAAJ,4BAA+Bqe,M,iCCjG3CzhB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyiB,mBAkCR,WACE,IAAIC,EAGJ,IADW7gB,KAAKsC,IAAI,MACZuC,eAAgB,OACxB,IAAMe,EAAO5F,KAAKsC,IAAI,QAClB3B,EAAOiF,EAAK4Y,oBAEuC,uBAAhC,OAAjBqC,EAAQlgB,QAAgB,EAASkgB,EAAMlgB,OACvCiF,EAAKkb,oBAAsBlb,EAAKtD,IAAI,UAAUuC,aAAa,CAC7DK,KAAM,YACDU,EAAK9E,MAAMoL,WAAW,SAAS,KACpCvL,EAAOogB,KAIX,OAAOpgB,GAjDTxC,EAAQ6iB,mBAAqBA,EAC7B7iB,EAAQ8iB,cAyDR,SAAuBvgB,GACrB,GAAIV,KAAKsC,IAAI,UAAUuC,eACrB,OAAO/F,EAAEoiB,sBAAsBxgB,EAAKoH,SA1DxC3J,EAAQgjB,gBA8DR,WACE,OAAOriB,EAAEkgB,wBA9DX7gB,EAAQgM,gBAiER,SAAyBzJ,GACvB,IAAM0J,EAAW1J,EAAK0J,SAEtB,GAAiB,SAAbA,EACF,OAAOtL,EAAEogB,qBACJ,GAAIpgB,EAAEsiB,uBAAuBpe,QAAQoH,IAAa,EACvD,OAAOtL,EAAEuiB,uBACJ,GAAIviB,EAAEwiB,uBAAuBte,QAAQoH,IAAa,EACvD,OAAOtL,EAAEkgB,uBACJ,GAAIlgB,EAAEyiB,wBAAwBve,QAAQoH,IAAa,EACxD,OAAOtL,EAAE0iB,yBA1EbrjB,EAAQsjB,iBA8ER,SAA0B/gB,GACxB,IAAM0J,EAAW1J,EAAK0J,SAEtB,GAAItL,EAAE4iB,wBAAwB1e,QAAQoH,IAAa,EACjD,OAAOtL,EAAEuiB,uBACJ,GAAIviB,EAAE6iB,yBAAyB3e,QAAQoH,IAAa,EACzD,OAAOtL,EAAE0iB,wBACJ,GAAiB,MAAbpX,EAAkB,CAC3B,IAAMoF,EAAQxP,KAAKsC,IAAI,SACjBoD,EAAO1F,KAAKsC,IAAI,QAEtB,OAAIoD,EAAK+Z,WAAW,WAAajQ,EAAMiQ,WAAW,UACzC3gB,EAAEuiB,uBACA3b,EAAK+Z,WAAW,WAAajQ,EAAMiQ,WAAW,UAChD3gB,EAAEkgB,uBAGJlgB,EAAE8iB,oBAAoB,CAAC9iB,EAAEkgB,uBAAwBlgB,EAAEuiB,2BA9F9DljB,EAAQ0jB,kBAkGR,WACE,IAAMC,EAAgB,CAAC9hB,KAAKsC,IAAI,QAAQkc,oBAAqBxe,KAAKsC,IAAI,SAASkc,qBAE/E,GAAI1f,EAAEijB,mBAAmBD,EAAc,KAAOhjB,EAAEkjB,kBAC9C,OAAOljB,EAAEkjB,kBAAkBF,GAG7B,GAAIhjB,EAAEmjB,oBACJ,OAAOnjB,EAAEmjB,oBAAoBH,GAG/B,OAAOhjB,EAAEojB,0BAA0BJ,IA5GrC3jB,EAAQgkB,sBA+GR,WACE,IAAML,EAAgB,CAAC9hB,KAAKsC,IAAI,cAAckc,oBAAqBxe,KAAKsC,IAAI,aAAakc,qBAEzF,GAAI1f,EAAEijB,mBAAmBD,EAAc,KAAOhjB,EAAEkjB,kBAC9C,OAAOljB,EAAEkjB,kBAAkBF,GAG7B,GAAIhjB,EAAEmjB,oBACJ,OAAOnjB,EAAEmjB,oBAAoBH,GAG/B,OAAOhjB,EAAEojB,0BAA0BJ,IAzHrC3jB,EAAQikB,mBA4HR,WACE,OAAOpiB,KAAKsC,IAAI,eAAe2P,MAAMuM,qBA5HvCrgB,EAAQkkB,wBA+HR,WACE,OAAOriB,KAAKsC,IAAI,cAAckc,qBA/HhCrgB,EAAQ6L,qBAkIR,WACE,OAAOhK,KAAKsC,IAAI,SAASkc,qBAlI3BrgB,EAAQ+L,iBAqIR,SAA0BxJ,GACxB,IAAM0J,EAAW1J,EAAK0J,SAEtB,GAAiB,OAAbA,GAAkC,OAAbA,EACvB,OAAOtL,EAAEuiB,wBAxIbljB,EAAQmkB,cA4IR,WACE,OAAOxjB,EAAEkgB,wBA5IX7gB,EAAQokB,eA+IR,WACE,OAAOzjB,EAAEuiB,wBA/IXljB,EAAQqkB,eAkJR,WACE,OAAO1jB,EAAE0iB,yBAlJXrjB,EAAQskB,YAqJR,WACE,OAAO3jB,EAAE4jB,6BArJXvkB,EAAQwkB,cAwJR,WACE,OAAO7jB,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,YAxJ9CxN,EAAQykB,iBA2JR,WACE,OAAO9jB,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,YA3J9CxN,EAAQ4iB,gBAAkBA,EAC1B5iB,EAAQ0kB,YAAcA,EACtB1kB,EAAQ2kB,iBAAmB3kB,EAAQ0M,gBAAkB1M,EAAQ4kB,oBAAsB5kB,EAAQ6kB,wBAA0B7kB,EAAQ8kB,mBAsK7H,WACE,OAAOnkB,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,cAtK9CxN,EAAQ+kB,eA8KR,WACE,IACEpb,EACE9H,KAAKU,KADPoH,OAGF,GAAIqb,EAAarb,GACf,OAAOhJ,EAAEskB,oBAAoBtkB,EAAEkgB,wBAC1B,GAAIqE,EAAYvb,IAAWwb,EAAexb,GAC/C,OAAOhJ,EAAEskB,oBAAoBtkB,EAAE6f,qBAC1B,GAAI4E,EAAgBzb,GACzB,OAAOhJ,EAAEskB,oBAAoBtkB,EAAE0kB,oBAAoB,CAAC1kB,EAAEkgB,uBAAwBlgB,EAAE6f,uBAGlF,OAAO8E,EAAYzjB,KAAKsC,IAAI,YA1L9BnE,EAAQulB,yBA6LR,WACE,OAAOD,EAAYzjB,KAAKsC,IAAI,SA7L9BrE,OAAOC,eAAeC,EAAS,aAAc,CAC3C8a,YAAY,EACZ3W,IAAK,WACH,OAAOqhB,EAAkBtlB,WAI7B,IAAIS,EAAIJ,EAAQ,IAEZilB,EAAoBjlB,EAAQ,KAqBhC,SAASsiB,EAAmBtgB,GAC1B,OAAOA,EAAK+d,eA0Hd,SAASsC,IACP,OAAOjiB,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,UAG9C,SAASkX,IACP,OAAO9B,IA5HTC,EAAmBzB,aAAc,EA+HjCsD,EAAYtD,aAAc,EAM1B,IAAM8D,EAAcvkB,EAAE8kB,2BAA2B,cAC3CT,EAAerkB,EAAE8kB,2BAA2B,eAC5CN,EAAiBxkB,EAAE8kB,2BAA2B,iBAC9CL,EAAkBzkB,EAAE8kB,2BAA2B,kBAsBrD,SAASH,EAAY3b,GAGnB,IAFAA,EAASA,EAAO+b,WAELzS,aAAc,CACvB,GAAItJ,EAAOgc,GAAG,SACZ,OAAIhc,EAAOgc,GAAG,aACLhlB,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,kBAErC7M,EAAEoiB,sBAAsBpiB,EAAE6M,WAAW,YAG9C,GAAI7D,EAAOpH,KAAKqjB,WACd,OAAOjc,EAAOpH,KAAKqjB,c,6CCtO3B9lB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,QAIR,SAAkBqC,GAChB,IAAKV,KAAKmF,eAAgB,OAC1B,IAAMqE,EAAUxJ,KAAKc,MAAM2I,WAAW/I,EAAKwE,MAE3C,GAAIsE,EACF,OAAIA,EAAQmC,WAAW8S,eACdjV,EAAQmC,WAAW8S,eAahC,SAAoDjV,EAAS7H,EAAMuD,GACjE,IAAMN,EAAQ,GACRof,EAA6B,GAC/B7a,EAAqB8a,EAA4Bza,EAAS7H,EAAMqiB,GAC9DE,EAAWC,EAAyB3a,EAAS7H,EAAMuD,GAEzD,GAAIgf,EAAU,CACZ,IAAME,EAAyBH,EAA4Bza,EAAS0a,EAASG,aAC7Elb,EAAqBA,EAAmBqU,QAAO,SAAA7b,GAAI,OAAIyiB,EAAuBphB,QAAQrB,GAAQ,KAC9FiD,EAAM3B,KAAKihB,EAASzF,gBAGtB,GAAItV,EAAmB7B,OAAQ,CAC7B6B,EAAqBA,EAAmBmb,OAAON,GADlB,UAGL7a,GAHK,IAG7B,2BAA4C,KAAjCob,EAAiC,QAC1C3f,EAAM3B,KAAKshB,EAAU/F,sBAJM,+BAQ/B,IAAK5Z,EAAM0C,OACT,OAGF,GAAIxI,EAAEijB,mBAAmBnd,EAAM,KAAO9F,EAAEkjB,kBACtC,OAAOljB,EAAEkjB,kBAAkBpd,GAG7B,GAAI9F,EAAEmjB,oBACJ,OAAOnjB,EAAEmjB,oBAAoBrd,GAG/B,OAAO9F,EAAEojB,0BAA0Btd,GA3CxB4f,CAA2Chb,EAASxJ,KAAMU,EAAKwE,MAI1E,GAAkB,cAAdxE,EAAKwE,KACP,OAAOpG,EAAEogB,qBACJ,GAAkB,QAAdxe,EAAKwE,MAAgC,aAAdxE,EAAKwE,KACrC,OAAOpG,EAAEuiB,uBACA3gB,EAAKwE,MAlBlB,IAAIpG,EAAIJ,EAAQ,IAwDhB,SAASulB,EAA4Bza,EAAS7H,EAAM8iB,GAClD,IAAMjX,EAAahE,EAAQL,mBAAmBoD,QAE9C,OADAiB,EAAW3L,QAAQ2H,EAAQ7H,MACpB6L,EAAWgQ,QAAO,SAAA+G,GAGvB,IAAMG,GAFNH,EAAYA,EAAUV,WAEGc,gCAAgChjB,GAGzD,OADI8iB,GAAwB,YAAXC,GAAsBD,EAAUxhB,KAAKshB,GACpC,WAAXG,KAIX,SAASE,EAAoC1f,EAAMvD,GACjD,IAGIkjB,EAyBAC,EACAC,EA7BE3a,EAAWzI,EAAKjB,KAAK0J,SACrBoF,EAAQ7N,EAAKW,IAAI,SAASuhB,UAC1Bne,EAAO/D,EAAKW,IAAI,QAAQuhB,UAa9B,GAVIne,EAAKb,aAAa,CACpBK,SAEA2f,EAASrV,EACAA,EAAM3K,aAAa,CAC5BK,WAEA2f,EAASnf,GAGPmf,EACF,MAAiB,QAAbza,EACKya,EAAOrG,oBAGZ1f,EAAEkmB,gCAAgChiB,QAAQoH,IAAa,EAClDtL,EAAEuiB,4BAGX,EAGF,IAAiB,QAAbjX,GAAmC,OAAbA,KAItB1E,EAAKoK,kBAAkB,CACzB1F,SAAU,YAEV0a,EAAapf,EACbqf,EAAWvV,GACFA,EAAMM,kBAAkB,CACjC1F,SAAU,aAEV0a,EAAatV,EACbuV,EAAWrf,GAGRof,GACAA,EAAWxiB,IAAI,YAAYuC,aAAa,CAC3CK,WAEF6f,EAAWA,EAASlB,WACNlc,aAAd,CACA,IAAMsd,EAAYF,EAASrkB,KAAKtC,MAChC,GAAyB,kBAAd6mB,EACX,OAAOnmB,EAAEomB,kCAAkCD,IAuB7C,SAASd,EAAyB3a,EAAS7H,EAAMuD,GAC/C,IAAMmf,EArBR,SAAkC7a,EAAS7H,EAAMuD,GAG/C,IAFA,IAAI5E,EAEGA,EAAaqB,EAAKrB,YAAY,CACnC,GAAIA,EAAW6kB,iBAAmB7kB,EAAW8kB,0BAA2B,CACtE,GAAiB,SAAbzjB,EAAKlB,IACP,OAGF,OAAOH,EAGT,GAAIA,EAAW8Q,cACT9Q,EAAWA,WAAWQ,MAAM2I,WAAWvE,KAAUsE,EAAS,OAGhE7H,EAAOrB,GAKW+kB,CAAyB7b,EAAS7H,EAAMuD,GAC5D,GAAKmf,EAAL,CAKA,IAJA,IACMhiB,EAAQ,CADDgiB,EAAY/hB,IAAI,SAEvBsC,EAAQ,GAELmH,EAAI,EAAGA,EAAI1J,EAAMiF,OAAQyE,IAAK,CACrC,IAAMpK,EAAOU,EAAM0J,GAEnB,GAAIpK,EAAK2jB,sBACoB,OAAvB3jB,EAAKjB,KAAK0J,WACZ/H,EAAMY,KAAKtB,EAAKW,IAAI,SACpBD,EAAMY,KAAKtB,EAAKW,IAAI,gBAEjB,GAAIX,EAAK4jB,qBAAsB,CACpC,IAAM5kB,EAAOikB,EAAoC1f,EAAMvD,GACnDhB,GAAMiE,EAAM3B,KAAKtC,IAIzB,OAAIiE,EAAM0C,OACJxI,EAAEijB,mBAAmBnd,EAAM,KAAO9F,EAAEkjB,kBAC/B,CACLvD,eAAgB3f,EAAEkjB,kBAAkBpd,GACpCyf,eAIAvlB,EAAEmjB,oBACG,CACLxD,eAAgB3f,EAAEmjB,oBAAoBrd,GACtCyf,eAIG,CACL5F,eAAgB3f,EAAEojB,0BAA0Btd,GAC5Cyf,eAIGF,EAAyBE,EAAanf,M,4CC/L/CjH,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETH,OAAOC,eAAeC,EAAS,WAAY,CACzC8a,YAAY,EACZ3W,IAAK,WACH,OAAOoR,EAAMrV,WAGjBJ,OAAOC,eAAeC,EAAS,QAAS,CACtC8a,YAAY,EACZ3W,IAAK,WACH,OAAOzD,EAAOR,WAGlBJ,OAAOC,eAAeC,EAAS,MAAO,CACpC8a,YAAY,EACZ3W,IAAK,WACH,OAAOkjB,EAAKnnB,WAGhBF,EAAQsnB,SAAWtnB,EAAQE,aAAU,EAErC,IAAIqnB,EAAWhnB,EAAQ,KAEnB+mB,EAAW/mB,EAAQ,KAEvBP,EAAQsnB,SAAWA,EAEnB,IAAI3mB,EAAIJ,EAAQ,IAEZinB,EAAQjnB,EAAQ,KAEhBgV,EAAQhV,EAAQ,KAEhBG,EAASH,EAAQ,KAEjB8mB,EAAO9mB,EAAQ,KAEnB,SAASkS,EAAS7Q,GAA6C,IAArCI,EAAqC,uDAA9B,GAAIW,EAA0B,uCAAnBZ,EAAmB,uCAAZI,EAAY,uCAC7D,GAAKP,EAAL,CAEA,IAAKI,EAAKylB,UAAY9kB,GACA,YAAhBf,EAAOY,MAAsC,SAAhBZ,EAAOY,KACtC,MAAM,IAAIU,MAAM,0EAA4E,2CAA5E,OAAuHtB,EAAOY,KAA9H,kBAAqJ,iCAIpK7B,EAAEgV,aAAa/T,EAAOY,QAI3B8kB,EAASI,QAAQ1lB,GACjByQ,EAASlQ,KAAKX,EAAQI,EAAMW,EAAOZ,EAAOI,KAG5C,IAAI+C,EAAWuN,EA+Bf,SAASkV,EAAkBnkB,EAAMzB,GAC3ByB,EAAKjB,KAAKC,OAAST,EAAMS,OAC3BT,EAAMuK,KAAM,EACZ9I,EAAK2S,QAjCTnW,EAAQE,QAAUgF,EAClBuN,EAAS6U,SAAWA,EACpB7U,EAASmV,OAASN,EAASM,OAC3BnV,EAASiV,QAAUJ,EAASI,QAE5BjV,EAASoV,MAAQ,SAAUtlB,EAAM+P,GAC/B,OAAO3R,EAAEmnB,aAAavlB,EAAM+P,IAG9BG,EAASlQ,KAAO,SAAUA,EAAMP,EAAMW,EAAOZ,EAAOI,EAAYD,GAC9D,IAAM+C,EAAOtE,EAAEgV,aAAapT,EAAKC,MACjC,GAAKyC,EAAL,CACA,IAHwE,EAGlEvC,EAAU,IAAI6kB,EAASrnB,QAAQyC,EAAOX,EAAMD,EAAOI,GAHe,IAKtD8C,GALsD,IAKxE,2BAAwB,KAAb3C,EAAa,QACtB,KAAIJ,IAAYA,EAASI,KACrBI,EAAQ6P,MAAMhQ,EAAMD,GAAM,QAPwC,iCAW1EmQ,EAASsV,UAAY,SAAUxlB,EAAMP,GACnCrB,EAAEqnB,iBAAiBzlB,EAAMP,GACzBwlB,EAAMhkB,KAAK6d,OAAO9e,IAGpBkQ,EAASuV,iBAAmB,SAAUC,EAAMjmB,GAE1C,OADArB,EAAEmnB,aAAaG,EAAMxV,EAASsV,UAAW/lB,GAClCimB,GAUTxV,EAASyV,QAAU,SAAUD,EAAMzlB,EAAM2lB,GACvC,GAAqB,MAAjBA,GAAyBA,EAAczT,SAASuT,EAAKzlB,MAAO,OAAO,EACvE,GAAIylB,EAAKzlB,OAASA,EAAM,OAAO,EAC/B,IAAMT,EAAQ,CACZuK,KAAK,EACL9J,KAAMA,GAOR,OALAiQ,EAASwV,EAAM,CACbR,SAAS,EACTW,SAAUD,EACV7V,MAAOqV,GACN,KAAM5lB,GACFA,EAAMuK,KAGfmG,EAAS+U,MAAQA,G,6CC7GjB1nB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQqoB,oBA+CR,SAA6B5R,GAC3B,IAAI6R,EAEJzmB,KAAKuU,SACLK,EAAQ5U,KAAK0mB,gBAAgB9R,GAC7B9V,EAAE6nB,uBAAuB/R,EAAM,GAAI5U,KAAKU,MACxC5B,EAAE8nB,wBAAwBhS,EAAMA,EAAMtN,OAAS,GAAItH,KAAKU,MACL,OAAlD+lB,EAAiB1nB,EAAO4C,KAAKW,IAAItC,KAAKD,UAA4B0mB,EAAejH,OAAOxf,KAAKU,MAC9FV,KAAKU,KAAOV,KAAKO,UAAUP,KAAKS,KAAO,KACvC,IAAM4B,EAAQrC,KAAK6mB,YAAYjS,GAE3B5U,KAAKU,KACPV,KAAK8mB,UAEL9mB,KAAK+mB,SAGP,OAAO1kB,GA/DTlE,EAAQ6oB,wBAkER,SAAiCC,GAC/BjnB,KAAKuU,SAEL,IACE0S,EAAc,IAAH,OAAOA,EAAP,KACXA,GAAc,EAAIC,EAAQ3L,OAAO0L,GACjC,MAAOE,GACP,IAAMlhB,EAAMkhB,EAAIlhB,IAYhB,MAVIA,IACFkhB,EAAIplB,SAAW,yCAA0C,EAAIqlB,EAAWC,kBAAkBJ,EAAa,CACrGK,MAAO,CACLC,KAAMthB,EAAIshB,KACVC,OAAQvhB,EAAIuhB,OAAS,KAGzBL,EAAIjlB,KAAO,8BAGPilB,EAOR,OAJAF,EAAcA,EAAY5a,QAAQ+C,KAAK,GAAGlH,WAE1CtJ,EAAOP,QAAQ8nB,iBAAiBc,GAEzBjnB,KAAKynB,YAAYR,IA3F1B9oB,EAAQspB,YA8FR,SAAqBR,GAGnB,GAFAjnB,KAAKuU,SAEDvU,KAAK0nB,QACP,MAAM,IAAIrmB,MAAM,yDAGd4lB,aAAuBU,EAAQtpB,UACjC4oB,EAAcA,EAAYvmB,MAG5B,IAAKumB,EACH,MAAM,IAAI5lB,MAAM,6EAGlB,GAAIrB,KAAKU,OAASumB,EAChB,MAAO,CAACjnB,MAGV,GAAIA,KAAKgR,cAAgBlS,EAAEkS,UAAUiW,GACnC,MAAM,IAAI5lB,MAAM,sEAGlB,GAAIwT,MAAMC,QAAQmS,GAChB,MAAM,IAAI5lB,MAAM,2FAGlB,GAA2B,kBAAhB4lB,EACT,MAAM,IAAI5lB,MAAM,6FAGlB,IAAIumB,EAAW,GAEX5nB,KAAK6nB,WAAW,cAAgB/oB,EAAEgH,aAAamhB,KAC5CjnB,KAAK8nB,0CAA6C9nB,KAAK+nB,qCAAqCd,IAAiBjnB,KAAKM,WAAWiH,+BAChI0f,EAAcnoB,EAAEkpB,oBAAoBf,GACpCW,EAAW,eAIf,GAAI5nB,KAAK6nB,WAAW,eAAiB/oB,EAAEyG,YAAY0hB,KAC5CjnB,KAAK8nB,2CAA6C9nB,KAAK+nB,qCAAqCd,GAC/F,OAAOjnB,KAAKioB,gCAAgC,CAAChB,IAIjD,IAAMiB,EAAUloB,KAAKU,KAEjBwnB,IACFppB,EAAEqpB,iBAAiBlB,EAAaiB,GAChCppB,EAAEspB,eAAeF,IAQnB,OALAloB,KAAKqoB,aAAapB,GAElBjnB,KAAKW,KAAOsmB,EAAYtmB,KACxBX,KAAKsoB,WACLtoB,KAAK8mB,UACE,CAACc,EAAW5nB,KAAKsC,IAAIslB,GAAY5nB,OAvJ1C7B,EAAQkqB,aA0JR,SAAsB3nB,GACpB,IAAI6nB,EAEJ,IAAKvoB,KAAKO,UACR,MAAM,IAAIoO,eAAe,sBAGvB3O,KAAK4B,OACP9C,EAAE2C,SAASzB,KAAKD,OAAQC,KAAKS,IAAK,CAACC,IAEnC5B,EAAE2C,SAASzB,KAAKD,OAAQC,KAAKS,IAAKC,GAGpCV,KAAKJ,MAAL,uBAAmC,MAARc,OAAe,EAASA,EAAKC,OACJ,OAAnD4nB,EAAkBxpB,EAAO4C,KAAKW,IAAItC,KAAKD,UAA4BwoB,EAAgB/lB,IAAI9B,EAAMV,MAAMwf,OAAOxf,KAAKU,MAChHV,KAAKU,KAAOV,KAAKO,UAAUP,KAAKS,KAAOC,GAxKzCvC,EAAQ8pB,gCA2KR,SAAyCrT,GACvC5U,KAAKuU,SACL,IAAMiU,EAAuB1pB,EAAE0pB,qBAAqB5T,EAAO5U,KAAKc,OAEhE,GAAI0nB,EACF,OAAOxoB,KAAKynB,YAAYe,GAAsB,GAAGlmB,IAAI,eAGvD,IAAMmmB,EAAiBzoB,KAAK2I,oBACtB+f,EAAkC,MAAlBD,OAAyB,EAASA,EAAe3E,GAAG,SACpE6E,EAAsC,MAAlBF,OAAyB,EAASA,EAAe3E,GAAG,aACxEvjB,EAAYzB,EAAE8pB,wBAAwB,GAAI9pB,EAAE+pB,eAAejU,IACjE5U,KAAKynB,YAAY3oB,EAAE8O,eAAerN,EAAW,KAC7CP,KAAK4Q,SAASkY,GACd,IAd8C,EAcxCC,EAAoB/oB,KAAKsC,IAAI,UAAU0mB,uBAdC,IAgB3BD,GAhB2B,IAgB9C,2BAAsC,KAA3BpnB,EAA2B,QACpC,GAAKA,EAAKsnB,wBAAV,CACA,IAAMC,EAAOvnB,EAAKkb,YAAW,SAAAlb,GAAI,OAAIA,EAAKuP,YAE1C,GAAIgY,EAAM,CACR,IAAIpe,EAAMoe,EAAKvX,QAAQ,kCAEvB,GAAK7G,EAMHA,EAAMhM,EAAE6M,WAAWb,EAAI5F,UANf,CACR,IAAM4C,EAAS9H,KAAKsC,IAAI,UACxBwI,EAAMhD,EAAOhH,MAAMqoB,8BAA8B,OACjDrhB,EAAOxF,IAAI,QAAQ8mB,cAAc,OAAQtqB,EAAEuqB,gBAAgBvqB,EAAE4M,UAAUZ,KACvEoe,EAAKpX,QAAQ,iCAAkChH,GAKjDnJ,EAAKW,IAAI,cAAcmlB,YAAY3oB,EAAEwqB,qBAAqB,IAAKxqB,EAAE4M,UAAUZ,GAAMnJ,EAAKjB,KAAKwH,kBAE3FvG,EAAK8lB,YAAY3oB,EAAEuqB,gBAAgB1nB,EAAKjB,KAAKwH,eAlCH,8BAsC9C,IAAMJ,EAAS9H,KAAKsC,IAAI,UACxBwF,EAAOyhB,4BAEP,IAAMC,EAAsBd,GAAiB9pB,EAAOP,QAAQgoB,QAAQrmB,KAAKsC,IAAI,eAAe5B,KAAM,kBAAmB5B,EAAE2qB,gBAEjHC,EAAsBf,GAAqB/pB,EAAOP,QAAQgoB,QAAQrmB,KAAKsC,IAAI,eAAe5B,KAAM,kBAAmB5B,EAAE2qB,gBAEvHD,IACF1hB,EAAOtF,IAAI,SAAS,GAEfknB,GACH1pB,KAAKynB,YAAY3oB,EAAE6qB,gBAAgB3pB,KAAKU,QAIxCgpB,IACF5hB,EAAOtF,IAAI,aAAa,GACxBxC,KAAKynB,YAAY3oB,EAAE8qB,gBAAgB5pB,KAAKU,MAAM,KAGhD,OAAOoH,EAAOxF,IAAI,cApOpBnE,EAAQ0rB,cAuOR,SAAuBjV,GAGrB,GAFA5U,KAAKuU,SAEDM,MAAMC,QAAQF,GAAQ,CACxB,GAAIC,MAAMC,QAAQ9U,KAAKO,WAAY,CACjCqU,EAAQ5U,KAAK0mB,gBAAgB9R,GAE7B,IAAMvS,EAAQrC,KAAK8pB,sBAAsBlV,GAGzC,OADA5U,KAAK+mB,SACE1kB,EAEP,OAAOrC,KAAKwmB,oBAAoB5R,GAGlC,OAAO5U,KAAKynB,YAAY7S,IApP5B,IAAIwS,EAAa1oB,EAAQ,KAErBE,EAASF,EAAQ,IAEjBipB,EAAUjpB,EAAQ,KAElBK,EAASL,EAAQ,KAEjBwoB,EAAUxoB,EAAQ,KAElBI,EAAIJ,EAAQ,IAEVoqB,EAAwB,CAC5Bve,SAD4B,SACnB5I,GACPA,EAAKoa,QAGPgO,oBAL4B,SAKRpoB,GAClB,GAAuB,QAAnBA,EAAKjB,KAAKqM,KAAd,CAGA,IAFA,IAAM1C,EAAW1I,EAAKkI,wBAEtB,MAAkB5L,OAAOmF,KAAKiH,GAA9B,eAAyC,CAApC,IAAM5J,EAAG,KACZkB,EAAKb,MAAMmC,KAAK,CACdgF,GAAIoC,EAAS5J,KAIjB,IAVwB,EAUlBupB,EAAQ,GAVU,IAYHroB,EAAKjB,KAAKiJ,cAZP,IAYxB,2BAA6C,KAAlCjB,EAAkC,QACvCA,EAAO9C,MACTokB,EAAM/mB,KAAKnE,EAAEkpB,oBAAoBlpB,EAAEwqB,qBAAqB,IAAK5gB,EAAOT,GAAIS,EAAO9C,SAd3D,8BAkBxBjE,EAAK6kB,oBAAoBwD,O,kCC/C7B,Y,YAEA/rB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ8rB,eAKR,WACE,IAAMC,EAAMlqB,KAAKmqB,WACjB,GAAID,EAAIE,UAAW,QAASF,EAAI9rB,OANlCD,EAAQgsB,SA6XR,WACE,IAAMjqB,EAAQ,CACZkqB,WAAW,EACXC,UAAW,KACXC,KAAM,IAAI/nB,KAERnE,EAAQmsB,EAAevqB,KAAME,GAC5BA,EAAMkqB,YAAWhsB,OAAQ+C,GAC9B,MAAO,CACLipB,UAAWlqB,EAAMkqB,UACjBI,MAAOtqB,EAAMmqB,UACbjsB,MAAOA,IAvYX,IAAMqsB,EAAgB,CAAC,SAAU,SAAU,QACrCC,EAAkB,CAAC,UAOzB,SAASF,EAAM7oB,EAAMzB,GACdA,EAAMkqB,YACXlqB,EAAMmqB,UAAY1oB,EAClBzB,EAAMkqB,WAAY,GAGpB,SAASG,EAAe5oB,EAAMzB,GAC5B,IACEQ,EACEiB,EADFjB,KAGA4pB,EACEpqB,EADFoqB,KAGF,GAAIA,EAAK7f,IAAI/J,GAAO,CAClB,IAAMiqB,EAAWL,EAAKhoB,IAAI5B,GAE1B,OAAIiqB,EAASC,SACJD,EAASvsB,WAEhBosB,EAAM7oB,EAAMzB,GAId,IAAM2qB,EAAO,CACXD,UAAU,GAEZN,EAAK9nB,IAAI9B,EAAMmqB,GAEf,IAAM7pB,EAWV,SAAmBW,EAAMzB,GACvB,IAAKA,EAAMkqB,UAAW,OAEtB,GAAIzoB,EAAKmpB,uBAAwB,CAC/B,IAAMd,EAAQroB,EAAKW,IAAI,eACvB,OAAOioB,EAAeP,EAAMA,EAAM1iB,OAAS,GAAIpH,GAGjD,GAAIyB,EAAKopB,mBAAqBppB,EAAKqpB,oBAAsBrpB,EAAKspB,mBAC5D,OAAOtpB,EAAKjB,KAAKtC,MAGnB,GAAIuD,EAAKupB,gBACP,OAAO,KAGT,GAAIvpB,EAAKwO,oBACP,OAAOgb,EAAexpB,EAAMA,EAAKjB,KAAK0qB,OAAQlrB,GAGhD,GAAIyB,EAAKoO,8BAAgCpO,EAAKW,IAAI,OAAO8C,qBAAsB,CAC7E,IAAMwC,EAASjG,EAAKW,IAAI,cAGpB4C,EAEA0C,EAHFlH,KACEwE,KAGE2C,EAAWlG,EAAKW,IAAI,gBAE1B,GAAIsF,EAAO/C,gBAA2B,WAATK,IAAsBvD,EAAKb,MAAM2I,WAAWvE,IAAS2C,EAAShD,gBAAyC,QAAvBgD,EAASnH,KAAKwE,KACzH,OAAOimB,EAAexpB,EAAMA,EAAKjB,KAAKwP,MAAMkb,OAAQlrB,GAAO,GAI/D,GAAIyB,EAAKyjB,0BAA2B,CAClC,IAAMiG,EAAad,EAAe5oB,EAAKW,IAAI,QAASpC,GACpD,IAAKA,EAAMkqB,UAAW,OAEtB,OACSG,EADLc,EACoB1pB,EAAKW,IAAI,cAETX,EAAKW,IAAI,aAFepC,GAMlD,GAAIyB,EAAK2pB,sBACP,OAAOf,EAAe5oB,EAAKW,IAAI,cAAepC,GAGhD,GAAIyB,EAAKyD,uBAAyBzD,EAAKrB,WAAWwgB,iBAAiB,CACjEhZ,OAAQnG,EAAKjB,OACX,CACF,IAAMmH,EAAWlG,EAAKW,IAAI,YACpBsF,EAASjG,EAAKW,IAAI,UAExB,GAAIsF,EAAOD,aAAeE,EAAShD,eAAgB,CACjD,IAAMzG,EAAQwJ,EAAOlH,KAAKtC,MACpBuC,SAAcvC,EAEpB,GAAa,WAATuC,GAA8B,WAATA,EACvB,OAAOvC,EAAMyJ,EAASnH,KAAKwE,OAKjC,GAAIvD,EAAKkE,yBAA0B,CACjC,IAAM2D,EAAU7H,EAAKb,MAAM2I,WAAW9H,EAAKjB,KAAKwE,MAEhD,GAAIsE,GAAWA,EAAQL,mBAAmB7B,OAAS,EACjD,OAAOkjB,EAAMhhB,EAAQ7H,KAAMzB,GAG7B,GAAIsJ,GAAW7H,EAAKjB,KAAK4mB,MAAQ9d,EAAQ7H,KAAKjB,KAAK6qB,IACjD,OAAOf,EAAMhhB,EAAQ7H,KAAMzB,GAG7B,GAAe,MAAXsJ,GAAmBA,EAAQiK,SAC7B,OAAOjK,EAAQpL,MAEf,GAAuB,cAAnBuD,EAAKjB,KAAKwE,KACZ,OAAOsE,EAAUghB,EAAMhhB,EAAQ7H,KAAMzB,QAASiB,EACzC,GAAuB,aAAnBQ,EAAKjB,KAAKwE,KACnB,OAAOsE,EAAUghB,EAAMhhB,EAAQ7H,KAAMzB,GAAS0d,IACzC,GAAuB,QAAnBjc,EAAKjB,KAAKwE,KACnB,OAAOsE,EAAUghB,EAAMhhB,EAAQ7H,KAAMzB,GAASsrB,IAGhD,IAAMZ,EAAWjpB,EAAKkiB,UAEtB,OAAI+G,IAAajpB,EACR6oB,EAAM7oB,EAAMzB,GAEZqqB,EAAeK,EAAU1qB,GAKtC,GAAIyB,EAAKmO,kBAAkB,CACzB2b,QAAQ,IACN,CACF,GAA2B,SAAvB9pB,EAAKjB,KAAK0J,SACZ,OAGF,IAAMpC,EAAWrG,EAAKW,IAAI,YAE1B,GAA2B,WAAvBX,EAAKjB,KAAK0J,WAA0BpC,EAASoJ,cAAgBpJ,EAASkH,WACxE,MAAO,WAGT,IAAMwc,EAAMnB,EAAeviB,EAAU9H,GACrC,IAAKA,EAAMkqB,UAAW,OAEtB,OAAQzoB,EAAKjB,KAAK0J,UAChB,IAAK,IACH,OAAQshB,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,SACH,cAAcA,GAIpB,GAAI/pB,EAAKgM,oBAAqB,CAC5B,IAD4B,EACtBge,EAAM,GACNC,EAAQjqB,EAAKW,IAAI,YAFK,IAITspB,GAJS,IAI5B,2BAA0B,KAClBC,EADkB,QACD1B,WAEvB,IAAI0B,EAAUzB,UAGZ,OAAOI,EAAMqB,EAAUrB,MAAOtqB,GAF9ByrB,EAAI1oB,KAAK4oB,EAAUztB,QARK,8BAc5B,OAAOutB,EAGT,GAAIhqB,EAAKgF,qBAAsB,CAC7B,IAD6B,EACvBoN,EAAM,GACN+X,EAAQnqB,EAAKW,IAAI,cAFM,IAIVwpB,GAJU,IAI7B,2BAA0B,KAAfnc,EAAe,QACxB,GAAIA,EAAKoc,kBAAoBpc,EAAKqc,kBAChC,OAAOxB,EAAM7a,EAAMzP,GAGrB,IACIO,EADYkP,EAAKrN,IAAI,OAGzB,GAAIqN,EAAKjP,KAAKkP,SAAU,CAGtB,KAFAnP,EAAMA,EAAI0pB,YAEDC,UACP,OAAOI,EAAM/pB,EAAI+pB,MAAOtqB,GAG1BO,EAAMA,EAAIrC,WAEVqC,EADSA,EAAIoE,eACPpE,EAAIC,KAAKwE,KAETzE,EAAIC,KAAKtC,MAGjB,IACIA,EADcuR,EAAKrN,IAAI,SACL6nB,WAEtB,IAAK/rB,EAAMgsB,UACT,OAAOI,EAAMpsB,EAAMosB,MAAOtqB,GAG5B9B,EAAQA,EAAMA,MACd2V,EAAItT,GAAOrC,GAlCgB,8BAqC7B,OAAO2V,EAGT,GAAIpS,EAAK2jB,sBAAuB,CAC9B,IAAM2G,EAAe/rB,EAAMkqB,UACrB1kB,EAAO6kB,EAAe5oB,EAAKW,IAAI,QAASpC,GACxCgsB,EAAgBhsB,EAAMkqB,UAC5BlqB,EAAMkqB,UAAY6B,EAClB,IAAMzc,EAAQ+a,EAAe5oB,EAAKW,IAAI,SAAUpC,GAC1CisB,EAAiBjsB,EAAMkqB,UAE7B,OAAQzoB,EAAKjB,KAAK0J,UAChB,IAAK,KAEH,GADAlK,EAAMkqB,UAAY8B,MAAoBxmB,GAAQymB,IACzCjsB,EAAMkqB,UAAW,OACtB,OAAO1kB,GAAQ8J,EAEjB,IAAK,KAEH,GADAtP,EAAMkqB,UAAY8B,KAAmBxmB,GAAQymB,IACxCjsB,EAAMkqB,UAAW,OACtB,OAAO1kB,GAAQ8J,GAIrB,GAAI7N,EAAK4jB,qBAAsB,CAC7B,IAAM7f,EAAO6kB,EAAe5oB,EAAKW,IAAI,QAASpC,GAC9C,IAAKA,EAAMkqB,UAAW,OACtB,IAAM5a,EAAQ+a,EAAe5oB,EAAKW,IAAI,SAAUpC,GAChD,IAAKA,EAAMkqB,UAAW,OAEtB,OAAQzoB,EAAKjB,KAAK0J,UAChB,IAAK,IACH,OAAO1E,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,KACH,OAAO6K,KAAK+R,IAAI1mB,EAAM8J,GAExB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,MACH,OAAO9J,IAAS8J,EAElB,IAAK,MACH,OAAO9J,IAAS8J,EAElB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,IACH,OAAO9J,EAAO8J,EAEhB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,KACH,OAAO9J,GAAQ8J,EAEjB,IAAK,MACH,OAAO9J,IAAS8J,GAItB,GAAI7N,EAAKmf,mBAAoB,CAC3B,IACIjgB,EACAwrB,EAFEvkB,EAASnG,EAAKW,IAAI,UAQxB,GAJIwF,EAAOjD,iBAAmBlD,EAAKb,MAAM2I,WAAW3B,EAAOpH,KAAKwE,OAASulB,EAAcznB,QAAQ8E,EAAOpH,KAAKwE,OAAS,IAClHmnB,EAAOC,EAAOxkB,EAAOpH,KAAKwE,OAGxB4C,EAAO1C,qBAAsB,CAC/B,IAAMwC,EAASE,EAAOxF,IAAI,UACpBuF,EAAWC,EAAOxF,IAAI,YAO5B,GALIsF,EAAO/C,gBAAkBgD,EAAShD,gBAAkB4lB,EAAcznB,QAAQ4E,EAAOlH,KAAKwE,OAAS,GAAKwlB,EAAgB1nB,QAAQ6E,EAASnH,KAAKwE,MAAQ,IAEpJmnB,GADAxrB,EAAUyrB,EAAO1kB,EAAOlH,KAAKwE,OACd2C,EAASnH,KAAKwE,OAG3B0C,EAAOD,aAAeE,EAAShD,eAAgB,CACjD,IAAMlE,SAAciH,EAAOlH,KAAKtC,MAEnB,WAATuC,GAA8B,WAATA,IAEvB0rB,GADAxrB,EAAU+G,EAAOlH,KAAKtC,OACPyJ,EAASnH,KAAKwE,QAKnC,GAAImnB,EAAM,CACR,IAAMte,EAAOpM,EAAKW,IAAI,aAAa6K,KAAI,SAAAue,GAAG,OAAInB,EAAemB,EAAKxrB,MAClE,IAAKA,EAAMkqB,UAAW,OACtB,OAAOiC,EAAKvT,MAAMjY,EAASkN,IAI/Byc,EAAM7oB,EAAMzB,GApUEqsB,CAAU5qB,EAAMzB,GAO5B,OALIA,EAAMkqB,YACRS,EAAKD,UAAW,EAChBC,EAAKzsB,MAAQ4C,GAGRA,EAgUX,SAASmqB,EAAexpB,EAAMypB,EAAQlrB,GAAoB,MAAbssB,EAAa,wDACpDrR,EAAM,GACNpP,EAAI,EACFie,EAAQroB,EAAKW,IAAI,eAHiC,IAKrC8oB,GALqC,IAKxD,2BAA2B,KAAhB1b,EAAgB,QACzB,IAAKxP,EAAMkqB,UAAW,MACtBjP,GAAOqR,EAAM9c,EAAKtR,MAAMouB,IAAM9c,EAAKtR,MAAMquB,OACzC,IAAMC,EAAO1C,EAAMje,KACf2gB,IAAMvR,GAAOC,OAAOmP,EAAemC,EAAMxsB,MATS,8BAYxD,GAAKA,EAAMkqB,UACX,OAAOjP,K,mDC9XTld,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQwuB,cAUR,WACE,IAAIlsB,EAEJ,GAAIT,KAAKoF,qBACP3E,EAAMT,KAAKU,KAAKmH,aACX,KAAI7H,KAAK6P,eAAgB7P,KAAKwL,WAGnC,MAAM,IAAImD,eAAe,QAFzBlO,EAAMT,KAAKU,KAAKD,IAKbT,KAAKU,KAAKkP,UACT9Q,EAAE+F,aAAapE,KAAMA,EAAM3B,EAAE8tB,cAAcnsB,EAAIyE,OAGrD,OAAOzE,GAxBTtC,EAAQkT,YA2BR,WACE,IAAMjC,EAAOpP,KAAKsC,IAAI,QAChBuqB,EAAWzd,EAAK1O,KAEtB,GAAImU,MAAMC,QAAQ1F,GAChB,MAAM,IAAI/N,MAAM,iDAGlB,IAAKwrB,EACH,MAAM,IAAIxrB,MAAM,qCAGlB,GAAI+N,EAAK2B,mBACP,OAAO8b,EAGT,IAEIpsB,EACAD,EAHEssB,EAAa,GACfC,EAAa,OAIb3d,EAAK7J,eACP/E,EAAU,OACVC,EAAM,EACNqsB,EAAW7pB,KAAKmM,EAAK1O,QAErBqsB,GAAc,UAEV/sB,KAAKoR,cACP3Q,EAAM,WACNqsB,EAAW7pB,KAAKnE,EAAEuqB,gBAAgBja,EAAK1O,SAEvCD,EAAM,aACNqsB,EAAW7pB,KAAKnE,EAAEkpB,oBAAoB5Y,EAAK1O,SAI/CV,KAAKU,KAAK0O,KAAOtQ,EAAE+pB,eAAeiE,GAClC,IAAMxsB,EAAaN,KAAKsC,IAAIyqB,GAE5B,OADA3d,EAAK3M,MAAMnC,EAAYE,EAAUF,EAAWI,KAAKF,GAAWF,EAAWI,KAAMF,EAASC,GAC/ET,KAAKU,MAlEdvC,EAAQ6uB,wBAqER,WACE,IAAKhtB,KAAKitB,4BAA6B,OACvCjtB,KAAKupB,6BAtEPprB,EAAQ+uB,0BAyER,WACE,IAAKltB,KAAKitB,8BAAgCjtB,KAAKwK,yBAA2BxK,KAAKuJ,wBAC7E,MAAMvJ,KAAKmtB,oBAAoB,kDAGjCC,EAAyBptB,OA7E3B7B,EAAQorB,0BAgFR,WAIQ,6DAAJ,GAAI,IAHN8D,wBAGM,aAFNC,qBAEM,aADNC,mBACM,OADSD,EACT,EACN,IAAKttB,KAAKitB,4BACR,MAAMjtB,KAAKmtB,oBAAoB,+DAGjC,IAAMK,EAAcJ,EAAyBptB,KAAMutB,EAAaF,GAIhE,GAHArtB,KAAKqR,cACLrR,KAAKU,KAAKC,KAAO,sBAEZ4sB,EAAa,CAChB,IAAME,EAAeD,EAAc,KAAOxtB,KAAKM,WAAWQ,MAAM2K,sBAAsB,gBAElFgiB,GACFztB,KAAKM,WAAWQ,MAAMmC,KAAK,CACzBgF,GAAIwlB,EACJ7nB,KAAM9G,EAAE4uB,iBAAiB,MAI7B1tB,KAAKsC,IAAI,QAAQuP,iBAAiB,OAAQ/S,EAAEkpB,oBAAoBlpB,EAAE8O,eAAe5N,KAAKF,IAAImO,UAAU,iBAAkB,CAACnP,EAAE6uB,iBAAkBF,EAAe3uB,EAAE6M,WAAW8hB,EAAavoB,MAAQpG,EAAE6M,WAAW6hB,OACzMxtB,KAAKynB,YAAY3oB,EAAE8O,eAAe9O,EAAE+O,kBAAiB,EAAI+f,EAAoBvvB,SAAS2B,MAAM,IAASA,KAAKU,KAAM5B,EAAE6M,WAAW,SAAU,CAAC8hB,EAAe3uB,EAAE6M,WAAW8hB,EAAavoB,MAAQpG,EAAE6uB,sBAtG/L,IAAI7uB,EAAIJ,EAAQ,IAEZkvB,EAAsBlvB,EAAQ,KAwGlC,SAAS0uB,EAAyBS,GAAqD,IAA7CN,IAA6C,yDAAzBF,IAAyB,yDAC/ES,EAAYD,EAAOhR,YAAW,SAAAE,GAClC,OAAOA,EAAE3L,eAAiB2L,EAAEkQ,6BAA+BlQ,EAAE/L,aAAe+L,EAAEgR,gBAAgB,CAC5FC,QAAQ,OAGNC,EAAuE,iBAAzC,MAAbH,OAAoB,EAASA,EAAUptB,KAAKqM,MAEnE,GAAI+gB,EAAUC,kBACZ,MAAMF,EAAOV,oBAAoB,mDAGnC,IAgGIK,EAhGJ,EAMIU,EAAoBL,GALtBM,EADF,EACEA,UACAC,EAFF,EAEEA,eACAC,EAHF,EAGEA,eACAC,EAJF,EAIEA,WACAC,EALF,EAKEA,WAGF,GAAIN,GAAiBM,EAAWjnB,OAAS,EAAG,CAC1C,IAAK+lB,EACH,MAAMkB,EAAW,GAAGpB,oBAAoB,kDAG1C,IAAMqB,EAAgB,GACtBV,EAAUld,SAAS,CACjBrG,SADiB,SACRkkB,GACHA,EAAMxB,6BACVwB,EAAM1S,QAGR2S,cANiB,SAMHD,GACZA,EAAM1S,QAGRmH,eAViB,SAUFuL,GACRA,EAAMnsB,IAAI,UAAUoK,WACzB8hB,EAAcvrB,KAAKwrB,MAIvB,IAAME,EAAeC,EAAgBd,GACrCU,EAActU,SAAQ,SAAA2U,GACpB,IAAM/mB,EAAShJ,EAAE6M,WAAWgjB,GAC5B7mB,EAAO7B,IAAM4oB,EAAUnuB,KAAKoH,OAAO7B,IACnC4oB,EAAUvsB,IAAI,UAAUmlB,YAAY3f,MAIxC,GAAIsmB,EAAe9mB,OAAS,EAAG,CAC7B,IAAMwnB,EAAmBrlB,EAAWqkB,EAAW,aAAa,kBAAMhvB,EAAE6M,WAAW,gBAC/EyiB,EAAelU,SAAQ,SAAA6U,GACrB,IAAMC,EAAUlwB,EAAE6M,WAAWmjB,GAC7BE,EAAQ/oB,IAAM8oB,EAAeruB,KAAKuF,IAClC8oB,EAAetH,YAAYuH,MAI/B,GAAIX,EAAe/mB,OAAS,EAAG,CAC7B,IAAM2nB,EAAmBxlB,EAAWqkB,EAAW,aAAa,kBAAMhvB,EAAEowB,aAAapwB,EAAE6M,WAAW,OAAQ7M,EAAE6M,WAAW,cACnH0iB,EAAenU,SAAQ,SAAAiV,GACrB,IAAMC,EAAYtwB,EAAE6M,WAAWsjB,GAC/BG,EAAUnpB,IAAMkpB,EAAYzuB,KAAKuF,IACjCkpB,EAAY1H,YAAY2H,MAI5B,GAAId,EAAWhnB,OAAS,EAAG,CACzB,IAAK+lB,EACH,MAAMiB,EAAW,GAAGnB,oBAAoB,4CAG1C,IAAMkC,EAAiBf,EAAWgB,QAAO,SAACC,EAAKC,GAAN,OAAoBD,EAAIjL,OAAOmL,EAAyBD,MAAa,IAC9GH,EAAenV,SAAQ,SAAAsV,GACrB,IAAM/uB,EAAM+uB,EAAU9uB,KAAKkP,SAAW,GAAK4f,EAAUltB,IAAI,YAAY5B,KAAKwE,KACpEwqB,EAAeF,EAAUlvB,WAAWqvB,uBAAuB,CAC/DjqB,KAAM8pB,EAAU9uB,OAEZkvB,EAASJ,EAAUlvB,WAAWwgB,iBAAiB,CACnDhZ,OAAQ0nB,EAAU9uB,OAEdiuB,EAAekB,EAAoB/B,EAAW4B,EAAcjvB,GAC5DsN,EAAO,GAMb,GAJIyhB,EAAU9uB,KAAKkP,UACjB7B,EAAK9K,KAAKusB,EAAUltB,IAAI,YAAY5B,MAGlCgvB,EAAc,CAChB,IAAMtxB,EAAQoxB,EAAUlvB,WAAWI,KAAK8O,MACxCzB,EAAK9K,KAAK7E,GAGZ,IAAMwa,EAAO9Z,EAAE8O,eAAe9O,EAAE6M,WAAWgjB,GAAe5gB,GAEtD6hB,GACFJ,EAAUlvB,WAAWuR,iBAAiB,YAAa/S,EAAE6uB,kBACrD6B,EAAU/H,YAAY3oB,EAAE+O,iBAAiB+K,EAAM9Z,EAAE6M,WAAW,UAC5DwiB,EAAUlrB,KAAKusB,EAAUlvB,WAAWgC,IAAI,iBAC/BotB,EACTF,EAAUlvB,WAAWmnB,YAAY7O,GAEjC4W,EAAU/H,YAAY7O,MAoB5B,OAbIuV,EAAU7mB,OAAS,IAAMimB,KAC3BC,EAAcsC,EAAehC,EAAWG,IAEpCV,GAAeU,GAAiB8B,EAAcjC,MAChDK,EAAUjU,SAAQ,SAAA8V,GAChB,IAAMC,EAAUD,EAAUE,QAAUpxB,EAAEqxB,cAAc3C,GAAe1uB,EAAE6M,WAAW6hB,GAChFyC,EAAQhqB,IAAM+pB,EAAUtvB,KAAKuF,IAC7B+pB,EAAUvI,YAAYwI,MAEnB1C,IAAaC,EAAc,QAI7BA,EAGT,SAASiC,EAAyBD,GAChC,GAAIA,EAAUlvB,WAAWqvB,0BAAmE,MAAvCH,EAAUlvB,WAAWI,KAAK0J,SAAkB,CAC/F,IAAMgmB,EAAiBZ,EAAUlvB,WAC3B+vB,EAAKD,EAAe1vB,KAAK0J,SAASmC,MAAM,GAAI,GAC5CnO,EAAQgyB,EAAe1vB,KAAK8O,MAGlC,GAFA4gB,EAAe1vB,KAAK0J,SAAW,IAE3BolB,EAAU9uB,KAAKkP,SAAU,CAC3B,IAAM0gB,EAAMd,EAAU1uB,MAAMqoB,8BAA8B,OAC1DiH,EAAe9tB,IAAI,QAAQmlB,YAAY3oB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ9I,EAAEwqB,qBAAqB,IAAKgH,EAAKd,EAAU9uB,KAAKmH,WAAW,IAC5IuoB,EAAe9tB,IAAI,SAASmlB,YAAY3oB,EAAEyxB,iBAAiBF,EAAIvxB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ9I,EAAE6M,WAAW2kB,EAAIprB,OAAO,GAAO9G,SAExIgyB,EAAe9tB,IAAI,QAAQmlB,YAAY3oB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ4nB,EAAU9uB,KAAKmH,WAChGuoB,EAAe9tB,IAAI,SAASmlB,YAAY3oB,EAAEyxB,iBAAiBF,EAAIvxB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ9I,EAAE6M,WAAW6jB,EAAU9uB,KAAKmH,SAAS3C,OAAQ9G,IAGxJ,MAAO,CAACgyB,EAAe9tB,IAAI,QAAS8tB,EAAe9tB,IAAI,SAASA,IAAI,SAC/D,GAAIktB,EAAUlvB,WAAWkwB,qBAAsB,CACpD,IAAMC,EAAajB,EAAUlvB,WACvBgwB,EAAMd,EAAU1uB,MAAMqoB,8BAA8B,OACpDuH,EAAclB,EAAU9uB,KAAKkP,SAAW4f,EAAU1uB,MAAMqoB,8BAA8B,QAAU,KAChGznB,EAAQ,CAAC5C,EAAEwqB,qBAAqB,IAAKgH,EAAKxxB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ8oB,EAAc5xB,EAAEwqB,qBAAqB,IAAKoH,EAAalB,EAAU9uB,KAAKmH,UAAY2nB,EAAU9uB,KAAKmH,SAAU2nB,EAAU9uB,KAAKkP,WAAY9Q,EAAEwqB,qBAAqB,IAAKxqB,EAAE+O,iBAAiB2hB,EAAU9uB,KAAKkH,OAAQ8oB,EAAc5xB,EAAE6M,WAAW+kB,EAAYxrB,MAAQsqB,EAAU9uB,KAAKmH,SAAU2nB,EAAU9uB,KAAKkP,UAAW9Q,EAAEyxB,iBAAiB,IAAKzxB,EAAE6M,WAAW2kB,EAAIprB,MAAOpG,EAAEkP,eAAe,MASzc,OAPKwhB,EAAUlvB,WAAWI,KAAK+qB,QAC7B/pB,EAAMuB,KAAKnE,EAAE6M,WAAW2kB,EAAIprB,OAG9BurB,EAAWhJ,YAAY3oB,EAAE6xB,mBAAmBjvB,IAGrC,CAFM+uB,EAAWnuB,IAAI,uBACdmuB,EAAWnuB,IAAI,uBAI/B,MAAO,CAACktB,GAGV,SAASO,EAAcjC,GACrB,OAAOA,EAAU8C,mBAAqB9C,EAAUxtB,WAAWA,WAAWI,KAAKyO,WAG7E,SAAS2gB,EAAehC,EAAWG,GACjC,OAAOxkB,EAAWqkB,EAAW,QAAQ,SAAAN,GACnC,IAAKS,IAAkB8B,EAAcjC,GAAY,OAAOhvB,EAAE6uB,iBAC1D,IAAMkD,EAAS,IAAIxc,QACnByZ,EAAUld,SAAS,CACjBrG,SADiB,SACRkkB,GACHA,EAAMxB,6BACVwB,EAAM1S,QAGR2S,cANiB,SAMHD,GACZA,EAAM1S,QAGRmH,eAViB,SAUFuL,GACRA,EAAMnsB,IAAI,UAAUoK,YACrBmkB,EAAOpmB,IAAIgkB,EAAM/tB,QACrBmwB,EAAOnc,IAAI+Z,EAAM/tB,MACjB+tB,EAAMjI,oBAAoB,CAACiI,EAAM/tB,KAAM5B,EAAEwqB,qBAAqB,IAAKxqB,EAAE6M,WAAW6hB,GAAc1uB,EAAE6M,WAAW,mBAOnH,SAASijB,EAAgBd,GACvB,OAAOrkB,EAAWqkB,EAAW,aAAa,WACxC,IAAMgD,EAAchD,EAAUhtB,MAAM2K,sBAAsB,QAC1D,OAAO3M,EAAE8pB,wBAAwB,CAAC9pB,EAAEiyB,YAAYD,IAAehyB,EAAE8O,eAAe9O,EAAEkyB,QAAS,CAAClyB,EAAEmyB,cAAcnyB,EAAE6M,WAAWmlB,EAAY5rB,aAIzI,SAAS2qB,EAAoB/B,EAAW4B,EAAcwB,GAEpD,OAAOznB,EAAWqkB,EAAD,oBADN4B,EAAe,MAAQ,MACjB,YAA+BwB,GAAY,KAAM,WAChE,IACIC,EADEC,EAAW,GAGjB,GAAIF,EACFC,EAASryB,EAAE+O,iBAAiB/O,EAAEkyB,QAASlyB,EAAE6M,WAAWulB,QAC/C,CACL,IAAM5hB,EAASwe,EAAUhtB,MAAM2K,sBAAsB,QACrD2lB,EAASvvB,QAAQyN,GACjB6hB,EAASryB,EAAE+O,iBAAiB/O,EAAEkyB,QAASlyB,EAAE6M,WAAW2D,EAAOpK,OAAO,GAGpE,GAAIwqB,EAAc,CAChB,IAAM2B,EAAavD,EAAUhtB,MAAM2K,sBAAsB,SACzD2lB,EAASnuB,KAAKouB,GACdF,EAASryB,EAAEwqB,qBAAqB,IAAK6H,EAAQryB,EAAE6M,WAAW0lB,EAAWnsB,OAGvE,OAAOpG,EAAE8pB,wBAAwBwI,EAAUD,MAI/C,SAAS1nB,EAAWqkB,EAAWrtB,EAAKmF,GAClC,IAAM0rB,EAAW,WAAa7wB,EAC1BG,EAAOktB,EAAUnc,QAAQ2f,GAE7B,IAAK1wB,EAAM,CACT,IAAMqH,EAAK6lB,EAAUhtB,MAAM2K,sBAAsBhL,GACjDG,EAAOqH,EAAG/C,KACV4oB,EAAUhc,QAAQwf,EAAU1wB,GAC5BktB,EAAUhtB,MAAMmC,KAAK,CACnBgF,GAAIA,EACJrC,KAAMA,EAAKhF,KAIf,OAAOA,EAGT,SAASstB,EAAoBL,GAC3B,IAAMM,EAAY,GACZC,EAAiB,GACjBC,EAAiB,GACjBC,EAAa,GACbC,EAAa,GAqDnB,OApDAV,EAAOjd,SAAS,CACd8d,cADc,SACAD,GACZA,EAAM1S,QAGRxR,SALc,SAKLkkB,GACHA,EAAMxB,6BACVwB,EAAM1S,QAGRwV,eAVc,SAUC9C,GACbN,EAAUlrB,KAAKwrB,IAGjB+C,cAdc,SAcA/C,GACY,SAApBA,EAAM/tB,KAAKwE,OAEVupB,EAAMnuB,WAAWwE,sBAAsB,CAC1C8C,OAAQ6mB,EAAM/tB,QACT+tB,EAAMnuB,WAAWmxB,oBAAoB,CAC1CvsB,KAAMupB,EAAM/tB,SAKdytB,EAAUlrB,KAAKwrB,IAGjBvL,eA5Bc,SA4BCuL,GACTA,EAAMnsB,IAAI,UAAUoK,WAAW6hB,EAAWtrB,KAAKwrB,IAGrDiD,iBAhCc,SAgCGjD,GACXA,EAAMnsB,IAAI,UAAUoK,WAAW4hB,EAAWrrB,KAAKwrB,IAGrD9pB,qBApCc,SAoCO8pB,GACK,cAApBA,EAAM/tB,KAAKwE,MACfkpB,EAAenrB,KAAKwrB,IAGtBkD,aAzCc,SAyCDlD,GACNA,EAAMnsB,IAAI,QAAQuC,aAAa,CAClCK,KAAM,SAEHupB,EAAMnsB,IAAI,YAAYuC,aAAa,CACtCK,KAAM,YAERmpB,EAAeprB,KAAKwrB,MAIjB,CACLN,YACAC,iBACAC,iBACAC,aACAC,gB,6CCjaJtwB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ6R,eAuBR,SAAwB4hB,EAASC,GAC/B,OAAO/yB,EAAEkR,eAAehQ,KAAKU,KAAMkxB,EAASC,IAvB9C1zB,EAAQsM,IAAMA,EACdtM,EAAQ0O,SAmCR,WACE,OAAO7M,KAAKc,MAAM+L,SAAS7M,KAAKU,OAnClCvC,EAAQ2zB,KAyCR,SAAcrxB,GACZ,OAAQT,KAAKyK,IAAIhK,IAzCnBtC,EAAQ4zB,OA4CR,SAAgBtxB,EAAKrC,GACnB,OAAO4B,KAAKU,KAAKD,KAASrC,GA5C5BD,EAAQ0pB,WA+CR,SAAoBlnB,GAClB,OAAO7B,EAAEkzB,OAAOhyB,KAAKW,KAAMA,IA/C7BxC,EAAQ2pB,uCAkDR,WACE,OAAqB,SAAb9nB,KAAKS,KAA+B,SAAbT,KAAKS,MAAmBT,KAAKM,WAAW2xB,SAlDzE9zB,EAAQ4pB,qCAqDR,SAA8Cd,GAC5C,GAAiB,SAAbjnB,KAAKS,MAAmBT,KAAKM,WAAW2sB,4BAC1C,OAAO,EAGT,GAAIjtB,KAAK8F,eACP,OAAOhH,EAAEiS,iBAAiBkW,GACrB,GAAIjnB,KAAK+Q,mBACd,OAAOjS,EAAEgH,aAAamhB,GAGxB,OAAO,GA/DT9oB,EAAQ+zB,mBAkER,SAA4BC,GAC1B,IAAIxwB,EAAO3B,KACP8d,GAAQ,EAEZ,EAAG,CACD,IAAMvd,EAAYoB,EAAKpB,UAEvB,GAAIoB,EAAKyP,eAAiB0M,EACxB,QAASqU,EAKX,GAFArU,GAAQ,EAEJjJ,MAAMC,QAAQvU,IAAcoB,EAAKlB,MAAQF,EAAU+G,OAAS,EAC9D,OAAO,SAED3F,EAAOA,EAAKrB,cAAgBqB,EAAKqP,aAE3C,OAAO,GAnFT7S,EAAQi0B,mBAsFR,WACE,OAAIpyB,KAAKM,WAAW8N,uBAAwBtP,EAAEiS,iBAAiB/Q,KAAKO,YAG3DzB,EAAEuzB,wBAAwBxf,SAAS7S,KAAKS,MAzFnDtC,EAAQm0B,iBA6FR,SAA0BC,EAAcC,GACtC,IAAKxyB,KAAK6F,yBAA0B,CAClC,IAAK7F,KAAKoF,sBAAwBpF,KAAKyyB,gCAAkCzyB,KAAKU,KAAKkP,SAAW9Q,EAAEisB,gBAAgB/qB,KAAKU,KAAKmH,SAAU,CAClIzJ,MAAOo0B,IACJxyB,KAAKU,KAAKmH,SAAS3C,OAASstB,GAAa,CAC5C,IAAM5qB,EAAS5H,KAAKsC,IAAI,UACxB,OAAOsF,EAAO/B,0BAA4B+B,EAAO0qB,iBAAiBC,EAAc,KAGlF,OAAO,EAGT,IAAM/oB,EAAUxJ,KAAKc,MAAM2I,WAAWzJ,KAAKU,KAAKwE,MAChD,IAAKsE,GAA4B,WAAjBA,EAAQuD,KAAmB,OAAO,EAClD,IAAMpL,EAAO6H,EAAQ7H,KACf5B,EAAS4B,EAAKrB,WACpB,IAAKP,EAAOsG,sBAAuB,OAAO,EAE1C,GAAItG,EAAOW,KAAK0G,OAAOhJ,QAAUm0B,EAG/B,OAAO,EAFP,IAAKC,EAAY,OAAO,EAK1B,GAAI7wB,EAAK+wB,4BAA6C,YAAfF,EACrC,OAAO,EAGT,GAAI7wB,EAAKgxB,8BAA+C,MAAfH,EACvC,OAAO,EAGT,GAAI7wB,EAAK8E,qBAAuB3H,EAAE+F,aAAalD,EAAKjB,KAAKkyB,SAAU,CACjE1tB,KAAMstB,IAEN,OAAO,EAGT,OAAO,GAlITr0B,EAAQ00B,UAqIR,WACE,IAAMnyB,EAAOV,KAAKU,KAElB,GAAIA,EAAK6qB,IAAK,CACZ,IAAMrpB,EAAOlC,KAAKF,IAAIgzB,UACtB,GAAI5wB,EAAM,OAAOA,EAAKqK,MAAM7L,EAAK4mB,MAAO5mB,EAAK6qB,KAG/C,MAAO,IA5ITptB,EAAQ40B,wBA+IR,SAAiClO,GAC/B,MAAwD,UAAjD7kB,KAAK2kB,gCAAgCE,IA/I9C1mB,EAAQwmB,gCAwMR,SAAyCE,GACvC,IAAMmO,EAAa,CACjBhzB,KAAMizB,EAAiBjzB,MACvB6kB,OAAQoO,EAAiBpO,IAG3B,GAAImO,EAAWnO,OAAOnkB,OAASsyB,EAAWhzB,KAAKU,KAC7C,OAAOV,KAAKkzB,kDAAkDF,EAAWnO,QAG3E,IAMIsO,EANE9wB,EAAQ,CACZwiB,OAAQA,EAAO5G,cACfje,KAAMA,KAAKie,eAEb,GAAI5b,EAAMwiB,OAAO7hB,QAAQhD,OAAS,EAAG,MAAO,QAC5C,GAAIqC,EAAMrC,KAAKgD,QAAQ6hB,IAAW,EAAG,MAAO,SAE5C,IAAMuO,EAAc,CAClBvO,OAAQ,EACR7kB,KAAM,GAGR,MAAQmzB,GAAcC,EAAYpzB,KAAOqC,EAAMrC,KAAKsH,QAAQ,CAC1D,IAAM3F,EAAOU,EAAMrC,KAAKozB,EAAYpzB,MACpCozB,EAAYvO,OAASxiB,EAAMwiB,OAAO7hB,QAAQrB,GAEtCyxB,EAAYvO,QAAU,EACxBsO,EAAaxxB,EAEbyxB,EAAYpzB,OAIhB,IAAKmzB,EACH,MAAM,IAAI9xB,MAAM,6FAGlB,GAAIgyB,EAA2BhxB,EAAMrC,KAAMozB,EAAYpzB,KAAO,IAAMqzB,EAA2BhxB,EAAMwiB,OAAQuO,EAAYvO,OAAS,GAChI,MAAO,UAGT,IAAMyO,EAAa,CACjBtzB,KAAMqC,EAAMrC,KAAKozB,EAAYpzB,KAAO,GACpC6kB,OAAQxiB,EAAMwiB,OAAOuO,EAAYvO,OAAS,IAG5C,GAAIyO,EAAWzO,OAAOrkB,SAAW8yB,EAAWtzB,KAAKQ,SAAW8yB,EAAWzO,OAAOtkB,YAAc+yB,EAAWtzB,KAAKO,UAC1G,OAAO+yB,EAAWzO,OAAOpkB,IAAM6yB,EAAWtzB,KAAKS,IAAM,SAAW,QAGlE,IAAM2C,EAAOtE,EAAEgV,aAAaqf,EAAWxyB,MACjC4yB,EAAc,CAClBvzB,KAAMoD,EAAKJ,QAAQswB,EAAWtzB,KAAKud,WACnCsH,OAAQzhB,EAAKJ,QAAQswB,EAAWzO,OAAOtH,YAEzC,OAAOgW,EAAY1O,OAAS0O,EAAYvzB,KAAO,SAAW,SA9P5D7B,EAAQ+0B,kDAmQR,SAA2DrO,GACzD,IAAKA,EAAOtb,yBAA2Bsb,EAAOvkB,WAAWiG,sBACvD,MAAO,UAGT,IAAMiD,EAAUqb,EAAO/jB,MAAM2I,WAAWob,EAAOnkB,KAAKuH,GAAG/C,MACvD,IAAKsE,EAAQR,WAAY,MAAO,SAChC,IACIwqB,EAR6D,EAO3DngB,EAAiB7J,EAAQ6J,eAPkC,IAU9CA,GAV8C,IAUjE,2BAAmC,KAAxB1R,EAAwB,QAEjC,MAD0BA,EAAK0a,MAAK,SAAA1a,GAAI,OAAIA,EAAKjB,OAASmkB,EAAOnkB,QACjE,CAEA,GAAiB,WAAbiB,EAAKlB,MAAqBkB,EAAKrB,WAAWwgB,mBAC5C,MAAO,UAGT,IAAI2S,EAA2BhpB,IAAI9I,EAAKjB,MAAxC,CACA+yB,EAA2B/e,IAAI/S,EAAKjB,MAEpC,IAAMgkB,EAAS1kB,KAAK2kB,gCAAgChjB,GAIpD,GAFA8xB,EAA2BjU,OAAO7d,EAAKjB,MAEnC8yB,GAAaA,IAAc9O,EAC7B,MAAO,UAEP8O,EAAY9O,KA5BiD,8BAgCjE,OAAO8O,GAlSTr1B,EAAQ0lB,QAqSR,SAAiB6P,EAAW9I,GAC1B,OAAO5qB,KAAK2zB,SAASD,EAAW9I,IAAa5qB,MArS/C7B,EAAQw1B,SAwSR,SAAkBD,EAAW9I,GAC3B,GAAIA,GAAYA,EAAS5nB,QAAQhD,OAAS,EAAG,OAI7C,IAHA4qB,EAAWA,GAAY,IACd3nB,KAAKjD,MAEVA,KAAK6e,wBACP,GAAI7e,KAAKsC,IAAI,MAAMuC,eACjB,OAAO7E,KAAKsC,IAAI,QAAQuhB,QAAQ6P,EAAW9I,QAExC,GAAI5qB,KAAK6F,yBAA0B,CACxC,IAAM2D,EAAUxJ,KAAKc,MAAM2I,WAAWzJ,KAAKU,KAAKwE,MAChD,IAAKsE,EAAS,OACd,IAAKA,EAAQmD,SAAU,OACvB,GAAqB,WAAjBnD,EAAQuD,KAAmB,OAE/B,GAAIvD,EAAQ7H,OAAS3B,KAAM,CACzB,IAAM4zB,EAAMpqB,EAAQ7H,KAAKkiB,QAAQ6P,EAAW9I,GAC5C,GAAI5qB,KAAKqc,MAAK,SAAAtc,GAAM,OAAIA,EAAOW,OAASkzB,EAAIlzB,QAAO,OACnD,OAAOkzB,OAEJ,IAAI5zB,KAAK6zB,uBACd,OAAO7zB,KAAKsC,IAAI,cAAcuhB,QAAQ6P,EAAW9I,GAC5C,GAAI8I,GAAa1zB,KAAKoF,qBAAsB,CACjD,IAAM0uB,EAAY9zB,KAAK2sB,gBACvB,IAAK7tB,EAAE6I,UAAUmsB,GAAY,OAC7B,IAAMC,EAAaD,EAAU11B,MACvBymB,EAAS7kB,KAAKsC,IAAI,UAAUuhB,QAAQ6P,EAAW9I,GAErD,GAAI/F,EAAOle,qBAAsB,CAC/B,IAD+B,EACzBmlB,EAAQjH,EAAOviB,IAAI,cADM,IAGZwpB,GAHY,IAG/B,2BAA0B,KAAfnc,EAAe,QACxB,GAAKA,EAAKE,aAAV,CACA,IAAMpP,EAAMkP,EAAKrN,IAAI,OACjBqT,EAAQhG,EAAKmiB,KAAK,aAAerxB,EAAIoE,aAAa,CACpDK,KAAM6uB,IAKR,GAHApe,EAAQA,GAASlV,EAAIkH,UAAU,CAC7BvJ,MAAO21B,IAEE,OAAOpkB,EAAKrN,IAAI,SAASuhB,QAAQ6P,EAAW9I,KAZ1B,oCAc1B,GAAI/F,EAAOlX,sBAAwBqmB,OAAOD,GAAa,CAC5D,IACMrkB,EADQmV,EAAOviB,IAAI,YACNyxB,GACnB,GAAIrkB,EAAM,OAAOA,EAAKmU,QAAQ6P,EAAW9I,OApV/CzsB,EAAQ81B,qBAyVR,WACE,GAAIj0B,KAAK6E,eAAgB,CACvB,IAAM2E,EAAUxJ,KAAKc,MAAM2I,WAAWzJ,KAAKU,KAAKwE,MAChD,QAAKsE,GACEA,EAAQmD,SAGjB,GAAI3M,KAAK2H,YACP,OAAI3H,KAAKk0B,qBAILl0B,KAAKmQ,qBACAnQ,KAAKsC,IAAI,eAAe6xB,OAAM,SAAAjsB,GAAU,OAAIA,EAAW+rB,2BAMlE,GAAIj0B,KAAK8P,oBACP,MAA2B,SAAvB9P,KAAKU,KAAK0J,UAIPpK,KAAKsC,IAAI,YAAY2xB,uBAG9B,GAAIj0B,KAAKulB,qBACP,OAAOvlB,KAAKsC,IAAI,QAAQ2xB,wBAA0Bj0B,KAAKsC,IAAI,SAAS2xB,uBAGtE,OAAO,GAvXT91B,EAAQi2B,eA0XR,WAqBE,SApBcp0B,KAAKgR,YAAchR,KAAOA,KAAKM,YAClB+b,MAAK,SAAA1a,GAC9B,GAAIA,EAAKqP,UAAU,CACjBqjB,WAAY,WACV,OAAO,EACX,GAAI1yB,EAAKuN,UAAW,OAAO,EAC3B,IAAKvN,EAAKqP,cAAgBrP,EAAKyP,aAAc,OAAO,EAEpD,GAAIzP,EAAKsrB,8BAAgCtrB,EAAKW,IAAI,QAAQyO,mBACxD,OAAO,EAGT,IAXsC,EAWhC3B,EAAOzN,EAAKyP,aAAezP,EAAKjB,KAAK0O,KAAOzN,EAAKjB,KAXjB,IAad0O,EAAKklB,YAbS,IAatC,2BAAyC,CACvC,GAA8B,eADS,QACzBl2B,MAAMA,MAClB,OAAO,GAf2B,mCA3X1CD,EAAQ2lB,QAAK,EAEb,IAAIhlB,EAAIJ,EAAQ,IAMhB,SAAS+L,EAAIhK,GACX,IAAMO,EAAMhB,KAAKU,MAAQV,KAAKU,KAAKD,GAEnC,OAAIO,GAAO6T,MAAMC,QAAQ9T,KACdA,EAAIsG,SAEJtG,EAQb,IAAM8iB,EAAKrZ,EAsHX,SAASwoB,EAAiBtxB,GACxB,OAAQA,EAAKb,MAAM6H,qBAAuBhH,EAAKb,MAAM8H,oBAAoBjH,KAG3E,SAAS4yB,EAAqB5zB,EAAMF,GAClC,OAAQE,GACN,IAAK,oBACH,MAAe,UAARF,EAET,IAAK,wBACL,IAAK,cACH,MAAe,eAARA,GAAgC,cAARA,EAEjC,IAAK,iBACL,IAAK,mBACL,IAAK,iBACL,IAAK,iBACH,MAAe,SAARA,EAET,IAAK,eACH,MAAe,SAARA,GAA0B,WAARA,EAE3B,IAAK,kBACH,MAAe,UAARA,EAET,IAAK,eACH,MAAe,YAARA,EAET,IAAK,oBACH,MAAe,UAARA,EAET,IAAK,2BACH,MAAe,aAARA,EAET,IAAK,yBACH,MAAe,cAARA,EAET,QACE,OAAO,GAIb,SAAS4yB,EAA2BhxB,EAAOmyB,GACzC,IAAK,IAAIzoB,EAAI,EAAGA,EAAIyoB,EAAUzoB,IAAK,CACjC,IAAMpK,EAAOU,EAAM0J,GAEnB,GAAIwoB,EAAqB5yB,EAAK5B,OAAOY,KAAMgB,EAAK4b,WAC9C,OAAO,EAIX,OAAO,EAxKTpf,EAAQ2lB,GAAKA,EAqOb,IAAM2P,EAA6B,IAAIpf,S,6CClRvCpW,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQya,KAyBR,SAAcnY,GACZ,IAAMN,EAAOH,KAAKG,KAGlB,GAFAH,KAAKJ,MAAMa,GAEPT,KAAKU,MACHV,KAAKy0B,MAAMt0B,EAAKM,IAAO,OAAO,EAGpC,GAAIT,KAAKU,KACP,OAAOV,KAAKy0B,MAAMt0B,EAAKH,KAAKU,KAAKC,OAASR,EAAKH,KAAKU,KAAKC,MAAMF,IAGjE,OAAO,GApCTtC,EAAQs2B,MAuCR,SAAeC,GACb,IAAKA,EAAK,OAAO,EADC,UAGDA,GAHC,IAGlB,2BAAsB,KAAX5xB,EAAW,QACpB,GAAKA,EAAL,CACA,IAAMpC,EAAOV,KAAKU,KAClB,IAAKA,EAAM,OAAO,EAClB,IAAMkzB,EAAM9wB,EAAG8V,KAAK5Y,KAAKE,MAAOF,KAAMA,KAAKE,OAE3C,GAAI0zB,GAAsB,kBAARA,GAAwC,oBAAbA,EAAIe,KAC/C,MAAM,IAAItzB,MAAM,gNAGlB,GAAIuyB,EACF,MAAM,IAAIvyB,MAAJ,sDAAyDyB,IAGjE,GAAI9C,KAAKU,OAASA,EAAM,OAAO,EAC/B,GAAIV,KAAKI,eAAiB,EAAG,OAAO,IAlBpB,8BAqBlB,OAAO,GA3DTjC,EAAQy2B,cAAgBz2B,EAAQ02B,aA8DhC,WACE,IAAIC,EAEEvO,EAAyD,OAA7CuO,EAAsB90B,KAAKG,KAAKomB,UAAoBuO,EAAsB90B,KAAKG,KAAK40B,UACtG,OAAOxO,GAAYA,EAASvjB,QAAQhD,KAAKU,KAAKC,OAAS,GAjEzDxC,EAAQuS,MAoER,WACE,IAAK1Q,KAAKU,KACR,OAAO,EAGT,GAAIV,KAAK60B,eACP,OAAO,EAGT,GAAI70B,KAAKG,KAAK60B,YAAch1B,KAAKG,KAAK60B,WAAWh1B,MAC/C,OAAO,EAGT,GAAIA,KAAKg1B,YAAch1B,KAAK4Y,KAAK,UAAY5Y,KAAKg1B,WAEhD,OADAh1B,KAAKJ,MAAM,WACJI,KAAKi1B,WAQd,OALAj1B,KAAKJ,MAAM,qBAEXhB,EAAOP,QAAQqC,KAAKV,KAAKU,KAAMV,KAAKG,KAAMH,KAAKc,MAAOd,KAAKE,MAAOF,KAAMA,KAAKK,UAE7EL,KAAK4Y,KAAK,QACH5Y,KAAKi1B,YA1Fd92B,EAAQ4d,KA6FR,WACE/b,KAAKg1B,YAAa,GA7FpB72B,EAAQ6d,QAgGR,SAAiBvb,GACM,MAAjBT,KAAKK,WACPL,KAAKK,SAAW,IAGlBL,KAAKK,SAASI,IAAO,GApGvBtC,EAAQmW,KAuGR,WACEtU,KAAKI,gBAAkBunB,EAAQrpB,YAAcqpB,EAAQppB,aAvGvDJ,EAAQmqB,SA0GR,WACE,GAAItoB,KAAKG,MAAQH,KAAKG,KAAKylB,QAAS,OACpC,IAEIf,EAFAljB,EAAO3B,KAAKM,WACC,QAAbN,KAAKS,KAAiBkB,EAAK6J,aAAY7J,EAAOA,EAAKrB,YAGvD,KAAOqB,IAASkjB,GAAQ,CACtB,GAAIljB,EAAKxB,MAAQwB,EAAKxB,KAAKylB,QAAS,OACpCf,EAASljB,EAAKb,MACda,EAAOA,EAAKrB,WAGdN,KAAKc,MAAQd,KAAKk1B,SAASrQ,GACvB7kB,KAAKc,OAAOd,KAAKc,MAAM8E,QAtH7BzH,EAAQg3B,WAyHR,SAAoBt0B,GACG,MAAjBb,KAAKK,WACPL,KAAKK,SAAW,IAGlBL,KAAKI,eAAiB,EAElBS,IACFb,KAAKa,QAAUA,EACfb,KAAKE,MAAQW,EAAQX,MACrBF,KAAKG,KAAOU,EAAQV,MAItB,OADAH,KAAKsoB,WACEtoB,MAtIT7B,EAAQoW,OAyIR,WACE,GAAIvU,KAAK0nB,QAAS,OAElB1nB,KAAKo1B,gBAELp1B,KAAKq1B,cAELr1B,KAAKs1B,cA/IPn3B,EAAQi3B,cAkJR,WACMp1B,KAAKM,aACPN,KAAKD,OAASC,KAAKM,WAAWI,OAnJlCvC,EAAQm3B,WAuJR,WACE,IAAKt1B,KAAKO,UAAW,OACrB,GAAIP,KAAKU,OAASV,KAAKO,UAAUP,KAAKS,KAAM,OAE5C,GAAIoU,MAAMC,QAAQ9U,KAAKO,YACrB,IAAK,IAAIwL,EAAI,EAAGA,EAAI/L,KAAKO,UAAU+G,OAAQyE,IACzC,GAAI/L,KAAKO,UAAUwL,KAAO/L,KAAKU,KAC7B,OAAOV,KAAKu1B,OAAOxpB,QAIvB,cAAkB9N,OAAOmF,KAAKpD,KAAKO,WAAnC,eAA+C,CAA1C,IAAME,EAAG,KACZ,GAAIT,KAAKO,UAAUE,KAAST,KAAKU,KAC/B,OAAOV,KAAKu1B,OAAO90B,GAKzBT,KAAKS,IAAM,MAxKbtC,EAAQk3B,YA2KR,WACE,IAAKr1B,KAAKD,SAAWC,KAAK4B,OAAQ,OAClC,IAAM4zB,EAAex1B,KAAKD,OAAOC,KAAKQ,SACtC,GAAIR,KAAKO,YAAci1B,EAAc,OACrCx1B,KAAKO,UAAYi1B,GAAgB,MA9KnCr3B,EAAQs3B,eAiLR,WACkB,MAAZz1B,KAAKS,KAAgBT,KAAKO,WAAaP,KAAKO,UAAUP,KAAKS,OAAST,KAAKU,MAC3EV,KAAK01B,gBAlLTv3B,EAAQwW,WAsLR,WACE3U,KAAKC,SAASgS,MAEVjS,KAAKC,SAASqH,OAAS,EACzBtH,KAAKm1B,WAAWn1B,KAAKC,SAASD,KAAKC,SAASqH,OAAS,IAErDtH,KAAKm1B,gBAAWh0B,IA3LpBhD,EAAQqW,YA+LR,SAAqB3T,GACnBb,KAAKC,SAASgD,KAAKpC,GACnBb,KAAKm1B,WAAWt0B,IAhMlB1C,EAAQsE,MAmMR,SAAenC,EAAYC,EAAWC,EAASC,GAC7CT,KAAKQ,QAAUA,EACfR,KAAKO,UAAYA,EACjBP,KAAKM,WAAaA,GAAcN,KAAKM,WACrCN,KAAKu1B,OAAO90B,IAtMdtC,EAAQo3B,OAyMR,SAAgB90B,GACd,IAAIk1B,EAEJ31B,KAAKS,IAAMA,EACXT,KAAKU,KAAOV,KAAKO,UAAUP,KAAKS,KAChCT,KAAKW,KAAmC,OAA3Bg1B,EAAa31B,KAAKU,WAAgB,EAASi1B,EAAWh1B,MA7MrExC,EAAQ2oB,QAgNR,WAAqC,IAApB8O,EAAoB,uDAAN51B,KAC7B,GAAI41B,EAAYlO,QAAS,OAEzB,IAHmC,EAG7BznB,EAAWD,KAAKC,SAHa,IAKbA,GALa,IAKnC,2BAAgC,KAArBY,EAAqB,QAC9BA,EAAQg1B,WAAWD,IANc,gCA/MrCz3B,EAAQ23B,kBAyNR,WACE,IAAIn0B,EAAO3B,KACPC,EAAWD,KAAKC,SAEpB,MAAQA,EAASqH,SACf3F,EAAOA,EAAKrB,aAEZL,EAAW0B,EAAK1B,SAGlB,OAAOA,GAjOT,IAAIrB,EAASF,EAAQ,IAEjBipB,EAAUjpB,EAAQ,M,6CC1BtBT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ4oB,OAaR,WACE,IAAIgP,EAEJ/1B,KAAKg2B,mBAELh2B,KAAKuU,SAE6B,OAA3BwhB,EAAa/1B,KAAKG,OAAiB41B,EAAWnQ,SACnD5lB,KAAKi2B,mBAGP,GAAIj2B,KAAKk2B,oBAGP,YAFAl2B,KAAK01B,eAKP11B,KAAKm2B,4BAELn2B,KAAKo2B,UAELp2B,KAAK01B,gBAjCPv3B,EAAQ83B,iBAoCR,WAA4B,WACpB5rB,EAAWrK,KAAK6J,wBACtB5L,OAAOmF,KAAKiH,GAAU6P,SAAQ,SAAAhV,GAAI,OAAI,EAAKpE,MAAMu1B,cAAcnxB,OArCjE/G,EAAQ+3B,kBAwCR,WAA6B,UACVI,EAAcC,OADJ,IAC3B,2BAAsC,CACpC,IAAIzzB,EADgC,SAC7B9C,KAAMA,KAAKM,YAAa,OAAO,GAFb,gCAvC7BnC,EAAQi4B,QA6CR,WACMvhB,MAAMC,QAAQ9U,KAAKO,YACrBP,KAAKO,UAAUiV,OAAOxV,KAAKS,IAAK,GAChCT,KAAKw2B,kBAAkBx2B,KAAKS,KAAM,IAElCT,KAAKqoB,aAAa,OAjDtBlqB,EAAQu3B,aAqDR,WACE11B,KAAKI,gBAAkBxB,EAAON,YAAcM,EAAOJ,QAC/CwB,KAAKD,QAAQhB,EAAO4C,KAAKW,IAAItC,KAAKD,QAAQyf,OAAOxf,KAAKU,MAC1DV,KAAKU,KAAO,MAvDdvC,EAAQ63B,iBA0DR,WACE,GAAIh2B,KAAK0nB,QACP,MAAM1nB,KAAKmtB,oBAAoB,+CA1DnC,IAAImJ,EAAgB53B,EAAQ,KAExBK,EAASL,EAAQ,KAEjBE,EAASF,EAAQ,M,iCCdrBT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQo4B,WAAQ,EAgChBp4B,EAAQo4B,MA/BM,CAAC,SAAUpe,EAAMpY,GAG7B,GAFkC,SAAboY,EAAK1X,MAAmBV,EAAO02B,WAAa12B,EAAO22B,iBAAgC,gBAAbve,EAAK1X,KAAyBV,EAAOwG,uBAAsC,SAAb4R,EAAK1X,KAAkBV,EAAOqO,sBAAyC,iBAAjB+J,EAAK3X,SAA8BT,EAAOyF,yBAA+D,IAApCzF,EAAOW,KAAKiJ,aAAarC,QAA6B,eAAb6Q,EAAK1X,KAAwBV,EAAOkpB,wBAI/V,OADAlpB,EAAOgnB,UACA,GAER,SAAU5O,EAAMpY,GACjB,GAAIA,EAAO+qB,wBAA6D,IAAnC/qB,EAAOW,KAAK0P,YAAY9I,OAE3D,OADAvH,EAAO0nB,YAAY1nB,EAAOW,KAAK0P,YAAY,KACpC,GAER,SAAU+H,EAAMpY,GACjB,GAAIA,EAAOwP,WAOT,MANiB,SAAb4I,EAAK1X,IACPV,EAAO0nB,YAAY1nB,EAAOW,KAAK8O,OAE/BzP,EAAO0nB,YAAY1nB,EAAOW,KAAKgF,OAG1B,GAER,SAAUyS,EAAMpY,GACjB,GAAIA,EAAOolB,kBAAiC,eAAbhN,EAAK1X,KAAqC,cAAb0X,EAAK1X,MAAqC,SAAb0X,EAAK1X,MAAmBV,EAAOmR,UAAYnR,EAAOktB,6BAKzI,OAJA9U,EAAKsP,YAAY,CACf9mB,KAAM,iBACNyO,KAAM,MAED,K,6DChCXnR,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQw4B,aAmBR,SAAsBC,GACpB52B,KAAKg2B,mBAEL,IAAMphB,EAAQ5U,KAAK0mB,gBAAgBkQ,GAGjCt2B,EACEN,KADFM,WAGF,GAAIA,EAAW2oB,yBAA2B3oB,EAAW8N,sBAAwB9N,EAAW6G,4BAA8B7G,EAAWiH,8BAAgCvH,KAAKsc,gBACpK,OAAOhc,EAAWq2B,aAAa/hB,GAC1B,GAAI5U,KAAK6nB,WAAW,gBAAkB7nB,KAAK62B,gBAAkBv2B,EAAWqF,kBAAiC,SAAb3F,KAAKS,IAEtG,OADIT,KAAKU,MAAMkU,EAAM3R,KAAKjD,KAAKU,MACxBV,KAAKioB,gCAAgCrT,GACvC,GAAIC,MAAMC,QAAQ9U,KAAKO,WAC5B,OAAOP,KAAK82B,uBAAuBliB,GAC9B,GAAI5U,KAAKoyB,qBAAsB,CACpC,IAAM1xB,EAAOV,KAAKU,KACZq2B,EAA0Br2B,KAAUV,KAAKipB,yBAA8C,MAAnBvoB,EAAKwH,YAE/E,OADAlI,KAAKynB,YAAY3oB,EAAE+pB,eAAekO,EAA0B,CAACr2B,GAAQ,KAC9DV,KAAK6R,iBAAiB,OAAQ+C,GAErC,MAAM,IAAIvT,MAAM,2GAxCpBlD,EAAQ64B,iBA4CR,SAA0BC,EAAMriB,GAAO,MACrC5U,KAAKw2B,kBAAkBS,EAAMriB,EAAMtN,QACnC,IAAMjF,EAAQ,IACd,EAAArC,KAAKO,WAAUiV,OAAf,SAAsByhB,EAAM,GAA5B,SAAkCriB,KAElC,IAAK,IAAI7I,EAAI,EAAGA,EAAI6I,EAAMtN,OAAQyE,IAAK,CACrC,IAAMmrB,EAAKD,EAAOlrB,EACZpK,EAAO3B,KAAKm3B,WAAWD,GAC7B70B,EAAMY,KAAKtB,GAEP3B,KAAKa,SAAWb,KAAKa,QAAQ+S,OAC/BjS,EAAK6S,YAAYxU,KAAKa,SAM1B,IAFA,IAAMZ,EAAWD,KAAK81B,oBAEtB,MAAmBzzB,EAAnB,eAA0B,CAArB,IAAMV,EAAI,KACbA,EAAK2mB,WACL3mB,EAAK/B,MAAM,aAFa,UAIFK,GAJE,IAIxB,2BAAgC,SACtB41B,WAAWl0B,GAAM,IALH,+BAS1B,OAAOU,GArETlE,EAAQ24B,uBAwER,SAAgCliB,GAC9B,OAAO5U,KAAKg3B,iBAAiBh3B,KAAKS,IAAKmU,IAxEzCzW,EAAQ2rB,sBA2ER,SAA+BlV,GAC7B,OAAO5U,KAAKg3B,iBAAiBh3B,KAAKS,IAAM,EAAGmU,IA3E7CzW,EAAQ0oB,YA8ER,SAAqB+P,GACnB52B,KAAKg2B,mBAEL,IAAMphB,EAAQ5U,KAAK0mB,gBAAgBkQ,GAGjCt2B,EACEN,KADFM,WAGF,GAAIA,EAAW2oB,yBAA2B3oB,EAAW8N,sBAAwB9N,EAAW6G,4BAA8B7G,EAAWiH,8BAAgCvH,KAAKsc,gBACpK,OAAOhc,EAAWumB,YAAYjS,EAAMzH,KAAI,SAAAzM,GACtC,OAAO5B,EAAEgH,aAAapF,GAAQ5B,EAAEkpB,oBAAoBtnB,GAAQA,MAEzD,GAAIV,KAAK6nB,WAAW,gBAAkB7nB,KAAK62B,iBAAmBv2B,EAAWu2B,gBAAkBv2B,EAAWqF,kBAAiC,SAAb3F,KAAKS,IAAgB,CACpJ,GAAIT,KAAKU,KAAM,CACb,IAAMA,EAAOV,KAAKU,KAEhBI,EACEd,KADFc,MAGF,GAAIA,EAAMa,KAAKuH,YAIb,OAHApK,EAAEs4B,iBAAiB12B,GACnBV,KAAKynB,YAAY3oB,EAAE8O,eAAe9O,EAAE8pB,wBAAwB,GAAIloB,GAAO,KACvEV,KAAKsC,IAAI,eAAeukB,YAAYjS,GAC7B,CAAC5U,MAGNM,EAAWkL,SAAS,CACtBoE,UAAU,EACVnP,IAAKC,MAELI,EAAQA,EAAMf,QAGhB,IAAMs3B,EAAOv2B,EAAMqoB,gCACnBvU,EAAM/S,QAAQ/C,EAAEkpB,oBAAoBlpB,EAAEwqB,qBAAqB,IAAKxqB,EAAE4M,UAAU2rB,GAAO32B,KACnFkU,EAAM3R,KAAKnE,EAAEkpB,oBAAoBlpB,EAAE4M,UAAU2rB,KAG/C,OAAOr3B,KAAKioB,gCAAgCrT,GACvC,GAAIC,MAAMC,QAAQ9U,KAAKO,WAC5B,OAAOP,KAAK8pB,sBAAsBlV,GAC7B,GAAI5U,KAAKoyB,qBAAsB,CACpC,IAAM1xB,EAAOV,KAAKU,KACZq2B,EAA0Br2B,KAAUV,KAAKipB,yBAA8C,MAAnBvoB,EAAKwH,YAE/E,OADAlI,KAAKynB,YAAY3oB,EAAE+pB,eAAekO,EAA0B,CAACr2B,GAAQ,KAC9DV,KAAKopB,cAAc,OAAQxU,GAElC,MAAM,IAAIvT,MAAM,2GA7HpBlD,EAAQq4B,kBAiIR,SAA2Bc,EAAWC,GACpC,IAAKv3B,KAAKD,OAAQ,OAElB,IAHiD,EAG3CsC,EAAQtD,EAAO4C,KAAKW,IAAItC,KAAKD,QAHc,IAK1BsC,GAL0B,IAKjD,2BAA8B,KAAhBV,EAAgB,gBACxBA,EAAKlB,KAAO62B,IACd31B,EAAKlB,KAAO82B,IAPiC,gCAhInDp5B,EAAQuoB,gBA4IR,SAAyB9R,GACvB,IAAKA,EACH,MAAO,GAGJC,MAAMC,QAAQF,KACjBA,EAAQ,CAACA,IAGX,IAAK,IAAI7I,EAAI,EAAGA,EAAI6I,EAAMtN,OAAQyE,IAAK,CACrC,IAAMrL,EAAOkU,EAAM7I,GACf3K,OAAG,EAYP,GAVKV,EAEsB,kBAATA,EAChBU,EAAM,6BACIV,EAAKC,KAEND,aAAgB9B,EAAOP,UAChC+C,EAAM,gDAFNA,EAAM,iBAJNA,EAAM,iBASJA,EAAK,CACP,IAAMT,EAAOkU,MAAMC,QAAQpU,GAAQ,eAAiBA,EACpD,MAAM,IAAIW,MAAJ,oBAAuBD,EAAvB,8BAAgD2K,EAAhD,wBAAiEpL,KAI3E,OAAOiU,GAxKTzW,EAAQ0T,iBA2KR,SAA0BrR,EAASoU,GAajC,OAZA5U,KAAKg2B,mBAELphB,EAAQ5U,KAAK0mB,gBAAgB9R,GAEhBhW,EAAOP,QAAQiE,IAAI,CAC9BhC,WAAYN,KACZD,OAAQC,KAAKU,KACbH,UAAWP,KAAKU,KAAKF,GACrBA,UACAC,IAAK,IACJ00B,WAAWn1B,KAAKa,SAEPi2B,uBAAuBliB,IAvLrCzW,EAAQirB,cA0LR,SAAuB5oB,EAASoU,GAC9B5U,KAAKg2B,mBAEL,IAAMwB,EAAgBx3B,KAAK0mB,gBAAgB9R,GAErCrU,EAAYP,KAAKU,KAAKF,GAU5B,OARa5B,EAAOP,QAAQiE,IAAI,CAC9BhC,WAAYN,KACZD,OAAQC,KAAKU,KACbH,UAAWA,EACXC,UACAC,IAAKF,EAAU+G,SACd6tB,WAAWn1B,KAAKa,SAEP2lB,oBAAoBgR,IAxMlCr5B,EAAQs5B,MA2MR,WAAmC,IAApB32B,EAAoB,uDAAZd,KAAKc,MACpB42B,EAAU,IAAIC,EAASt5B,QAAQ2B,KAAMc,GAC3C,OAAO42B,EAAQE,OA3MjB,IAAI74B,EAASL,EAAQ,KAEjBi5B,EAAWj5B,EAAQ,KAEnBE,EAASF,EAAQ,KAEjBI,EAAIJ,EAAQ,K,qECpBhBT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAElB,IAAIS,EAAIJ,EAAQ,IAEVm5B,EAAmB,CACvBlzB,qBADuB,SACFhD,EAAMzB,GACzB,IAAIyB,EAAKoD,oBAAqBjG,EAAEkG,MAAMC,YAAYtD,EAAKjB,KAAKwE,OAAUvD,EAAKrB,WAAWwE,wBAAtF,CAIA,GAAuB,SAAnBnD,EAAKjB,KAAKwE,KAAiB,CAC7B,IAAIpE,EAAQa,EAAKb,MAEjB,GACE,GAAIA,EAAMa,KAAKyP,eAAiBtQ,EAAMa,KAAKsrB,4BACzC,YAEKnsB,EAAQA,EAAMf,QAEnBe,GAAOZ,EAAM43B,kBAAkB70B,KAAKnC,EAAMa,MAGhD,IAAM6H,EAAU7H,EAAKb,MAAM2I,WAAW9H,EAAKjB,KAAKwE,MAChD,GAAKsE,EAAL,CAlBgC,UAoBRA,EAAQL,oBApBA,IAoBhC,2BAAoD,CAClD,GADkD,QACpCrI,QAAU0I,EAAQ7H,KAAKb,MAGnC,OAFAZ,EAAM63B,gBAAiB,OACvBp2B,EAAK2S,QAvBuB,8BA4B5B9K,IAAYtJ,EAAMY,MAAM2I,WAAW9H,EAAKjB,KAAKwE,QACjDhF,EAAMmK,SAAS1I,EAAKjB,KAAKwE,MAAQsE,OAK/BwuB,E,WACJ,WAAYr2B,EAAMb,GAAO,UACvBd,KAAK83B,uBAAoB,EACzB93B,KAAKqK,cAAW,EAChBrK,KAAK+3B,oBAAiB,EACtB/3B,KAAKi4B,YAAS,EACdj4B,KAAKc,WAAQ,EACbd,KAAK2B,UAAO,EACZ3B,KAAKk4B,iBAAc,EACnBl4B,KAAK83B,kBAAoB,GACzB93B,KAAKqK,SAAW,GAChBrK,KAAK+3B,gBAAiB,EACtB/3B,KAAKi4B,OAAS,GACdj4B,KAAKc,MAAQA,EACbd,KAAK2B,KAAOA,EACZ3B,KAAKk4B,aAAc,E,2CAGrB,SAAkBp3B,GAChB,cAAkB7C,OAAOmF,KAAKpD,KAAKqK,UAAnC,eAA8C,CAAzC,IAAM5J,EAAG,KACN+I,EAAUxJ,KAAKqK,SAAS5J,GAE9B,IAAKK,EAAMgb,wBAAwBrb,EAAK+I,EAAQmC,YAC9C,OAAO,EAIX,OAAO,I,iCAGT,WACE,IAAI7K,EAAQd,KAAK2B,KAAKb,MAEtB,EAAG,CACD,IAAId,KAAKm4B,kBAAkBr3B,GAGzB,MAGF,GALEd,KAAKi4B,OAAOh1B,KAAKnC,GAKfd,KAAK83B,kBAAkB90B,QAAQlC,EAAMa,OAAS,EAChD,YAEKb,EAAQA,EAAMf,U,+BAGzB,WACE,IAAI4B,EAAO3B,KAAKo4B,qBAEhB,GAAKz2B,EAAL,CACA,IAAI02B,EAAc12B,EAAKb,MAMvB,GAJIu3B,EAAY12B,OAASA,IACvB02B,EAAc12B,EAAKb,MAAMf,QAGvBs4B,EAAY12B,KAAKqP,aAAeqnB,EAAY12B,KAAKyP,aACnD,cAAmBnT,OAAOmF,KAAKpD,KAAKqK,UAApC,eAA+C,CAA1C,IAAMnF,EAAI,KACb,GAAKmzB,EAAY3lB,cAAcxN,GAA/B,CACA,IAAMsE,EAAUxJ,KAAKqK,SAASnF,GAE9B,GAAqB,UAAjBsE,EAAQuD,MAA+C,WAA3BvD,EAAQ7H,KAAK4b,UAM7C,GAF0Bvd,KAAKs4B,2BAA2B9uB,EAAQ7H,MAE5ClB,KAAOkB,EAAKlB,IAAK,CACrCT,KAAKk4B,aAAc,EACnBv2B,EAAO6H,EAAQ7H,KAFsB,UAIT6H,EAAQL,oBAJC,IAIrC,2BAAwD,KAA7CovB,EAA6C,QAClDv4B,KAAKs4B,2BAA2BC,GAAe93B,IAAMkB,EAAKlB,MAC5DkB,EAAO42B,IAN0B,iCAa3C,OAAO52B,K,gCAGT,WACE,IACMb,EADSd,KAAKi4B,OACChmB,MACrB,GAAKnR,EAEL,GAAIA,EAAMa,KAAKyP,aAAc,CAC3B,IAAIpR,KAAKw4B,oBAAoB13B,GAS3B,OAAOd,KAAKy4B,+BARZ,GAAIz4B,KAAKc,QAAUA,EAAO,OAG1B,IAFA,IAAM43B,EAAS53B,EAAMa,KAAKW,IAAI,QAAQA,IAAI,QAEjCyJ,EAAI,EAAGA,EAAI2sB,EAAOpxB,OAAQyE,IACjC,IAAI2sB,EAAO3sB,GAAGrL,KAAK8Q,YACnB,OAAOknB,EAAO3sB,QAKb,GAAIjL,EAAMa,KAAKqP,YACpB,OAAOhR,KAAKy4B,iC,0CAIhB,WACE,IAAM33B,EAAQd,KAAKi4B,OAAOhmB,MAC1B,GAAInR,EAAO,OAAOd,KAAKs4B,2BAA2Bx3B,EAAMa,Q,wCAG1D,SAA2BA,GACzB,GACE,IAAKA,EAAKrB,YAAcuU,MAAMC,QAAQnT,EAAKpB,YAAcoB,EAAK4D,cAC5D,OAAO5D,QAEFA,EAAOA,EAAKrB,c,iCAGvB,SAAoBQ,GAClB,cAAmB7C,OAAOmF,KAAKpD,KAAKqK,UAApC,eAA+C,CAA1C,IAAMnF,EAAI,KACb,GAAKpE,EAAM4R,cAAcxN,GAAzB,CACA,IAAMsE,EAAUxJ,KAAKqK,SAASnF,GAC9B,GAAqB,UAAjBsE,EAAQuD,MAAoBvD,EAAQmD,SAAU,OAAO,GAG3D,OAAO,I,iBAGT,WAEE,GADA3M,KAAK2B,KAAKiP,SAASinB,EAAkB73B,OACjCA,KAAK+3B,eAAT,CACA/3B,KAAK24B,sBACL,IAAMC,EAAW54B,KAAK64B,oBACtB,GAAKD,GACDA,EAASjwB,sBAAwB3I,KAAK2B,KAAKgH,oBAA/C,CACA,IAAImC,EAAM8tB,EAAS93B,MAAM2K,sBAAsB,OACzCsG,EAAajT,EAAEkT,mBAAmBlH,EAAK9K,KAAK2B,KAAKjB,MAEvD,EAAmBk4B,EADF54B,KAAKk4B,YAAc,cAAgB,gBACd,CAACU,EAAS/Z,uBAAyB9M,EAAajT,EAAE8S,oBAAoB,MAAO,CAACG,MAA7G+mB,EAAP,UACM/4B,EAASC,KAAK2B,KAAKrB,WAOzB,OALIP,EAAO82B,gBAAkB72B,KAAK2B,KAAKpB,YAAcR,EAAOW,KAAKq4B,WAC/DjuB,EAAMhM,EAAEk6B,uBAAuBluB,IAGjC9K,KAAK2B,KAAK8lB,YAAY3oB,EAAE4M,UAAUZ,IAC3B8tB,EAAS/Z,uBAAyBia,EAASx2B,IAAI,QAAUw2B,EAASx2B,IAAI,6B,KAKjFnE,EAAQE,QAAU25B,G,6CCjMlB/5B,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ86B,YAoCR,WACE,GAAiB,SAAbj5B,KAAKS,IACP,OAAOT,KAAKm3B,WAAW,SAClB,GAAiB,UAAbn3B,KAAKS,IACd,OAAOT,KAAKm3B,WAAW,QAGzB,OAAO,MA1CTh5B,EAAQ6qB,qBAkMR,WAOE,OANgBkQ,EAAsBl5B,KAAM,CAC1Cm5B,cAAc,EACdC,qBAAqB,EACrBC,cAAc,IAGDlsB,KAAI,SAAAgJ,GAAC,OAAIA,EAAExU,SAxM5BxD,EAAQg5B,WA2MR,SAAoB12B,GAClB,OAAO7B,EAAOP,QAAQiE,IAAI,CACxBhC,WAAYN,KAAKM,WACjBP,OAAQC,KAAKD,OACbQ,UAAWP,KAAKO,UAChBC,QAASR,KAAKQ,QACdC,IAAKA,IACJ00B,WAAWn1B,KAAKa,UAjNrB1C,EAAQm7B,eAoNR,WACE,OAAOt5B,KAAKm3B,WAAWn3B,KAAKS,IAAM,IApNpCtC,EAAQo7B,eAuNR,WACE,OAAOv5B,KAAKm3B,WAAWn3B,KAAKS,IAAM,IAvNpCtC,EAAQq7B,mBA0NR,WACE,IAAIC,EAAOz5B,KAAKS,IACZi5B,EAAU15B,KAAKm3B,aAAasC,GAC1BE,EAAW,GAEjB,KAAOD,EAAQh5B,MACbi5B,EAAS12B,KAAKy2B,GACdA,EAAU15B,KAAKm3B,aAAasC,GAG9B,OAAOE,GAnOTx7B,EAAQy7B,mBAsOR,WACE,IAAIH,EAAOz5B,KAAKS,IACZi5B,EAAU15B,KAAKm3B,aAAasC,GAC1BE,EAAW,GAEjB,KAAOD,EAAQh5B,MACbi5B,EAAS12B,KAAKy2B,GACdA,EAAU15B,KAAKm3B,aAAasC,GAG9B,OAAOE,GA/OTx7B,EAAQmE,IAkPR,SAAa7B,GAAqB,IAAhBI,IAAgB,0DAChB,IAAZA,IAAkBA,EAAUb,KAAKa,SACrC,IAAMa,EAAQjB,EAAIqZ,MAAM,KAExB,OAAqB,IAAjBpY,EAAM4F,OACDtH,KAAK65B,QAAQp5B,EAAKI,GAElBb,KAAK85B,YAAYp4B,EAAOb,IAxPnC1C,EAAQ07B,QA4PR,SAAiBp5B,EAAKI,GAAS,WACvBH,EAAOV,KAAKU,KACZH,EAAYG,EAAKD,GAEvB,OAAIoU,MAAMC,QAAQvU,GACTA,EAAU4M,KAAI,SAAC4sB,EAAGhuB,GACvB,OAAOnN,EAAOP,QAAQiE,IAAI,CACxB9B,QAASC,EACTH,WAAY,EACZP,OAAQW,EACRH,UAAWA,EACXE,IAAKsL,IACJopB,WAAWt0B,MAGTjC,EAAOP,QAAQiE,IAAI,CACxBhC,WAAYN,KACZD,OAAQW,EACRH,UAAWG,EACXD,IAAKA,IACJ00B,WAAWt0B,IA/QlB1C,EAAQ27B,YAmRR,SAAqBp4B,EAAOb,GAC1B,IADmC,EAC/Bc,EAAO3B,KADwB,IAGhB0B,GAHgB,IAGnC,2BAA0B,KAAfs4B,EAAe,QAEtBr4B,EADW,MAATq4B,EACKr4B,EAAKrB,WAERuU,MAAMC,QAAQnT,GACTA,EAAKq4B,GAELr4B,EAAKW,IAAI03B,EAAMn5B,IAVO,8BAenC,OAAOc,GAjSTxD,EAAQ0L,sBAoSR,SAA+BowB,GAC7B,OAAOn7B,EAAE+K,sBAAsB7J,KAAKU,KAAMu5B,IApS5C97B,EAAQ0Q,2BAuSR,SAAoCorB,GAClC,OAAOn7B,EAAE+P,2BAA2B7O,KAAKU,KAAMu5B,IAvSjD97B,EAAQ+7B,0BA0SR,WAA0E,IAAvCD,EAAuC,wDAAnBE,EAAmB,wDAClEx4B,EAAO3B,KACTo6B,EAAS,GAAG9V,OAAO3iB,GACjB6M,EAAMvQ,OAAOgD,OAAO,MAE1B,KAAOm5B,EAAO9yB,QAAQ,CACpB,IAAMW,EAAKmyB,EAAOC,QAClB,GAAKpyB,GACAA,EAAGvH,KAAR,CACA,IAAM0C,EAAOtE,EAAE+K,sBAAsBzG,KAAK6E,EAAGvH,KAAKC,MAElD,GAAIsH,EAAGpD,eACL,GAAIo1B,EAAY,CACd,IAAMK,EAAO9rB,EAAIvG,EAAGvH,KAAKwE,MAAQsJ,EAAIvG,EAAGvH,KAAKwE,OAAS,GAEtDo1B,EAAKr3B,KAAKgF,QAEVuG,EAAIvG,EAAGvH,KAAKwE,MAAQ+C,OAMxB,GAAIA,EAAG1B,sBAAP,CACE,IAAMiB,EAAcS,EAAG3F,IAAI,eAEvBkF,EAAY8U,iBACd8d,EAAOn3B,KAAKuE,OAJhB,CAUA,GAAI2yB,EAAW,CACb,GAAIlyB,EAAGsB,wBAAyB,CAC9B6wB,EAAOn3B,KAAKgF,EAAG3F,IAAI,OACnB,SAGF,GAAI2F,EAAGuC,uBACL,SAIJ,GAAIpH,EACF,IAAK,IAAI2I,EAAI,EAAGA,EAAI3I,EAAKkE,OAAQyE,IAAK,CACpC,IAAMtL,EAAM2C,EAAK2I,GACX0iB,EAAQxmB,EAAG3F,IAAI7B,IAEjBoU,MAAMC,QAAQ2Z,IAAUA,EAAM/tB,QAChC05B,EAASA,EAAO9V,OAAOmK,OAM/B,OAAOjgB,GAjWTrQ,EAAQo8B,+BAoWR,SAAwCN,GACtC,OAAOj6B,KAAKk6B,0BAA0BD,GAAY,IAnWpD,IAAIr7B,EAASF,EAAQ,KAEjBI,EAAIJ,EAAQ,IA6BhB,SAAS87B,EAAqB74B,EAAM84B,EAAS55B,GAC3C,OAAIc,EAAa84B,EAAQnW,OAAO4U,EAAsBv3B,EAAMd,IACrD45B,EAmCT,SAASC,EAAwBC,GAC/BA,EAAYzgB,SAAQ,SAAA5E,GAClBA,EAAE3U,KAjEmB,KAqEzB,SAASi6B,EAAuCD,EAAaE,GAC3DF,EAAYzgB,SAAQ,SAAA5E,GACdA,EAAE3T,KAAKm5B,iBAAiB,CAC1B3sB,MAAO,SAEH0sB,EACFvlB,EAAE3T,KAAK8lB,YAAY3oB,EAAEyP,gBAAgB,OAAQzP,EAAEkP,eAAe,KAE9DsH,EAAE3T,KAAKolB,aAMf,SAASgU,EAA2B14B,EAAOxB,GACzC,IAAI85B,EAAc,GAElB,GAAI95B,EAAQs4B,aAGV,IAFA,IAAI6B,EAAwB,GAEnBjvB,EAAI,EAAGA,EAAI1J,EAAMiF,OAAQyE,IAAK,CACrC,IAAMpK,EAAOU,EAAM0J,GACbkvB,EAAah9B,OAAOyE,OAAO,GAAI7B,EAAS,CAC5Cw4B,cAAc,IAGZ13B,EAAKoP,qBAAuBlQ,EAAQw4B,cAAgBx4B,EAAQu4B,qBAC5D6B,EAAW7B,qBAAsB,EAEnC6B,EAAW7B,qBAAsB,EAGnC,IAAM8B,EAAuBhC,EAAsBv3B,EAAMs5B,GAEzD,GAAIC,EAAqB5zB,OAAS,GAAK4zB,EAAqB/G,OAAM,SAAA7e,GAAC,OAvGhD,IAuGoDA,EAAE3U,QAA4B,CAC/Fq6B,EAAsB1zB,OAAS,GAAK4zB,EAAqB/G,OAAM,SAAA7e,GAAC,OAAIA,EAAE3T,KAAKm5B,iBAAiB,CAC9F3sB,MAAO,WAEPusB,EAAwBM,GACxBL,EAAcA,EAAYrW,OAAO0W,GAE7BA,EAAsBG,MAAK,SAAA7lB,GAAC,OAAIA,EAAE3T,KAAK2a,qBACzCqe,EAAcA,EAAYrW,OAAO4W,GACjCN,EAAuCM,GAAsB,IAG/DN,EAAuCM,GAAsB,KAE7DP,EAAcA,EAAYrW,OAAO4W,GAE5Br6B,EAAQu4B,qBACXwB,EAAuCM,GAAsB,IAIjE,MAGEnvB,IAAM1J,EAAMiF,OAAS,EACvBqzB,EAAcA,EAAYrW,OAAO4W,IAEjCP,EAAcA,EAAYrW,OAAO4W,EAAqB1d,QAAO,SAAAlI,GAAC,OAlI7C,IAkIiDA,EAAE3U,SACpEq6B,EAAwBE,EAAqB1d,QAAO,SAAAlI,GAAC,OApInC,IAoIuCA,EAAE3U,cAGtD0B,EAAMiF,SACfqzB,EAAcA,EAAYrW,OAAO4U,EAAsB72B,EAAMA,EAAMiF,OAAS,GAAIzG,KAGlF,OAAO85B,EAGT,SAASzB,EAAsBv3B,EAAMd,GACnC,IAAI45B,EAAU,GAEd,GAAI94B,EAAKwjB,gBACPsV,EAAUD,EAAqB74B,EAAKW,IAAI,cAAem4B,EAAS55B,GAChE45B,EAAUD,EAAqB74B,EAAKW,IAAI,aAAcm4B,EAAS55B,QAC1D,GAAIc,EAAKy5B,kBAAoBz5B,EAAKswB,SAAWtwB,EAAK80B,WAAa90B,EAAKyM,qBACzEqsB,EAAUD,EAAqB74B,EAAKW,IAAI,QAASm4B,EAAS55B,QACrD,GAAIc,EAAKqP,aAAerP,EAAKoP,mBAClC0pB,EAAUA,EAAQnW,OAAOyW,EAA2Bp5B,EAAKW,IAAI,QAASzB,QACjE,IAAIc,EAAKyP,aACd,OAAO8nB,EAAsBv3B,EAAKW,IAAI,QAASzB,GACtCc,EAAK05B,kBACdZ,EAAUD,EAAqB74B,EAAKW,IAAI,SAAUm4B,EAAS55B,GAC3D45B,EAAUD,EAAqB74B,EAAKW,IAAI,WAAYm4B,EAAS55B,IACpDc,EAAKwP,gBACdspB,EAAUD,EAAqB74B,EAAKW,IAAI,QAASm4B,EAAS55B,GACjDc,EAAKsP,oBACdwpB,EAhIJ,SAAmC/d,EAAO+d,EAAS55B,GAGjD,IAFA,IAAIm6B,EAAwB,GAEnBjvB,EAAI,EAAGA,EAAI2Q,EAAMpV,OAAQyE,IAAK,CACrC,IADqC,EAG/BuvB,EAAkBpC,EAFPxc,EAAM3Q,GAEiClL,GAElD06B,EAAoB,GACpBC,EAAmB,GANY,IAQrBF,GARqB,IAQrC,2BAAiC,KAAtBhmB,EAAsB,QA3CX,IA4ChBA,EAAE3U,MACJ46B,EAAkBt4B,KAAKqS,GA5CN,IA+CfA,EAAE3U,MACJ66B,EAAiBv4B,KAAKqS,IAdW,8BAkBjCimB,EAAkBj0B,SACpB0zB,EAAwBO,GAG1Bd,EAAUA,EAAQnW,OAAOkX,GAI3B,OADUf,EAAQnW,OAAO0W,GAoGbS,CAA0B95B,EAAKW,IAAI,SAAUm4B,EAAS55B,GACvDc,EAAK+0B,eACd+D,EAAUA,EAAQnW,OAAOyW,EAA2Bp5B,EAAKW,IAAI,cAAe,CAC1E62B,cAAc,EACdC,qBAAqB,EACrBC,cAAc,KAEP13B,EAAKm5B,mBACdL,EAAQx3B,KA9JZ,SAAyBtB,GACvB,MAAO,CACLhB,KAXqB,EAYrBgB,QA2Ja+5B,CAAgB/5B,IAE7B84B,EAAQx3B,KAvKZ,SAA0BtB,GACxB,MAAO,CACLhB,KALsB,EAMtBgB,QAoKag6B,CAAiBh6B,IAGhC,OAAO84B,I,iCCnMTx8B,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQg4B,0BAMR,WACE,GAAwB,kBAAbn2B,KAAKS,IAAkB,OAClC,IAAMC,EAAOV,KAAKU,KAClB,IAAKA,EAAM,OACX,IAAMk7B,EAAWl7B,EAAKm7B,iBAChBC,EAAUp7B,EAAKq7B,gBACrB,IAAKH,IAAaE,EAAS,OAC3B,IAAMtjB,EAAOxY,KAAKm3B,WAAWn3B,KAAKS,IAAM,GAClCu7B,EAAOh8B,KAAKm3B,WAAWn3B,KAAKS,IAAM,GAClCw7B,EAAUC,QAAQ1jB,EAAK9X,MACvBy7B,EAAUD,QAAQF,EAAKt7B,MAEzBu7B,IAAYE,EACd3jB,EAAK4jB,YAAY,WAAYR,GACpBO,IAAYF,GACrBD,EAAKI,YAAY,UAAWN,IApBhC39B,EAAQk+B,WAwBR,SAAoB17B,EAAM27B,EAAS/U,GACjCzoB,EAAEu9B,WAAWr8B,KAAKU,KAAMC,EAAM27B,EAAS/U,IAxBzCppB,EAAQi+B,YA2BR,SAAqBz7B,EAAM47B,GACzBz9B,EAAEs9B,YAAYp8B,KAAKU,KAAMC,EAAM47B,IA1BjC,IAAIz9B,EAAIJ,EAAQ,K,6CCPhBT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ0nB,QAAUA,EAClB1nB,EAAQ4nB,OAASA,EACjB5nB,EAAQq+B,MAiIR,SAAe/W,GAGb,IAH6C,IAAtBgX,EAAsB,uDAAb,GAAIC,EAAS,uCACvCC,EAAc,GAEX5wB,EAAI,EAAGA,EAAI0Z,EAASne,OAAQyE,IAAK,CACxC,IAAMvK,EAAUikB,EAAS1Z,GACnB7L,EAAQu8B,EAAO1wB,GACrB8Z,EAAQrkB,GAER,cAAmBvD,OAAOmF,KAAK5B,GAA/B,eAAyC,CAApC,IAAMb,EAAI,KACTi8B,EAAcp7B,EAAQb,IAEtBT,GAASw8B,KACXE,EAAcC,EAAuBD,EAAa18B,EAAOw8B,IAG3D,IAAMI,EAAcH,EAAYh8B,GAAQg8B,EAAYh8B,IAAS,GAC7Do8B,EAAUD,EAAaF,IAI3B,OAAOD,GAnJT,IAAIl+B,EAAeC,EAAQ,KAEvBI,EAAIJ,EAAQ,IAEhB,SAASmnB,EAAQrkB,GACf,GAAIA,EAAQgP,UAAW,OAAOhP,EAC9BA,EAAQgP,WAAY,EAEpB,cAAuBvS,OAAOmF,KAAK5B,GAAnC,eAA6C,CAAxC,IAAMw7B,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMt7B,EAAQs7B,EAASljB,MAAM,KAC7B,GAAqB,IAAjBpY,EAAM4F,OAAV,CACA,IAAMotB,EAAMlzB,EAAQw7B,UACbx7B,EAAQw7B,GAL4B,UAOxBt7B,GAPwB,IAO3C,2BAA0B,CACxBF,EADwB,SACRkzB,GARyB,iCAY7C3O,EAAOvkB,UACAA,EAAQ07B,WAgKjB,SAA+BnpB,GAC7B,cAAkB9V,OAAOmF,KAAK2Q,GAA9B,eAAoC,CAA/B,IAAMtT,EAAG,KACZ,IAAIw8B,EAAgBx8B,GAApB,CACA,IAAMi0B,EAAM3gB,EAAItT,GAEG,oBAARi0B,IACT3gB,EAAItT,GAAO,CACTgQ,MAAOikB,MAtKbyI,CAAsB37B,GACtB47B,EAAqB57B,GAErB,cAAuBvD,OAAOmF,KAAK5B,GAAnC,eAA6C,CAAxC,IAAMw7B,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMN,EAAUj+B,EAAau+B,GAC7B,GAAKN,EAAL,CAGA,IAFA,IAAMhI,EAAMlzB,EAAQw7B,GAEpB,MAAmB/+B,OAAOmF,KAAKsxB,GAA/B,eAAqC,CAAhC,IAAM/zB,EAAI,KACb+zB,EAAI/zB,GAAQ08B,EAAUX,EAAShI,EAAI/zB,IAKrC,UAFOa,EAAQw7B,GAEXN,EAAQ93B,MAAO,WACE83B,EAAQ93B,OADV,IACjB,2BAAkC,KAAvBjE,EAAuB,QAC5Ba,EAAQb,GACVo8B,EAAUv7B,EAAQb,GAAO+zB,GAEzBlzB,EAAQb,GAAQ+zB,GALH,oCASjBqI,EAAUv7B,EAASkzB,KAIvB,cAAuBz2B,OAAOmF,KAAK5B,GAAnC,eAA6C,CAAxC,IAAMw7B,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMtI,EAAMlzB,EAAQw7B,GAChBM,EAAUx+B,EAAEy+B,mBAAmBP,GAC7BQ,EAAgB1+B,EAAE2+B,gBAAgBT,GAOxC,GALIQ,IACFlwB,QAAQowB,MAAR,8BAAqCV,EAArC,uCAA4EQ,IAC5EF,EAAU,CAACE,IAGRF,EAAL,QACO97B,EAAQw7B,GAZ4B,UAcvBM,GAduB,IAc3C,2BAA6B,KAAlBK,EAAkB,QACrBhT,EAAWnpB,EAAQm8B,GAErBhT,EACFoS,EAAUpS,EAAU+J,GAEpBlzB,EAAQm8B,GAAS1/B,OAAOyE,OAAO,GAAIgyB,IApBI,iCAyB7C,cAAuBz2B,OAAOmF,KAAK5B,GAAnC,eAA6C,CAAxC,IAAMw7B,EAAQ,KACbC,EAAgBD,IACpBI,EAAqB57B,EAAQw7B,IAG/B,OAAOx7B,EAGT,SAASukB,EAAOvkB,GACd,IAAIA,EAAQo8B,UAAZ,CAEA,GAAuB,oBAAZp8B,EACT,MAAM,IAAIH,MAAM,6HAGlB,cAAuBpD,OAAOmF,KAAK5B,GAAnC,eAA6C,CAAxC,IAAMw7B,EAAQ,KAKjB,GAJiB,UAAbA,GAAqC,SAAbA,GAC1Ba,EAAuBb,EAAUx7B,EAAQw7B,KAGvCC,EAAgBD,GAApB,CAEA,GAAIl+B,EAAE8D,MAAMI,QAAQg6B,GAAY,EAC9B,MAAM,IAAI37B,MAAJ,kDAAqD27B,EAArD,+BAGR,IAAMvX,EAAWjkB,EAAQw7B,GAEzB,GAAwB,kBAAbvX,EACT,cAAyBxnB,OAAOmF,KAAKqiB,GAArC,eAAgD,CAA3C,IAAMqY,EAAU,KACnB,GAAmB,UAAfA,GAAyC,SAAfA,EAG5B,MAAM,IAAIz8B,MAAM,8DAAgE,GAAhE,OAAmE27B,EAAnE,0CAA6Gc,IAF7HD,EAAuB,GAAD,OAAIb,EAAJ,YAAgBc,GAAcrY,EAASqY,MAQrEt8B,EAAQo8B,WAAY,GAGtB,SAASC,EAAuBl8B,EAAMX,GACpC,IADyC,EACnC0zB,EAAM,GAAGpQ,OAAOtjB,GADmB,IAGxB0zB,GAHwB,IAGzC,2BAAsB,KAAX5xB,EAAW,QACpB,GAAkB,oBAAPA,EACT,MAAM,IAAIC,UAAJ,wCAA+CpB,EAA/C,6BAAwEmB,KALzC,+BAiC3C,SAAS+5B,EAAuBkB,EAAY79B,EAAOw8B,GAGjD,IAFA,IAAMsB,EAAa,GADuC,aAGrD,IAAMv9B,EAAG,KACRi0B,EAAMqJ,EAAWt9B,GACrB,IAAKoU,MAAMC,QAAQ4f,GAAM,iBACzBA,EAAMA,EAAIvnB,KAAI,SAAUrK,GACtB,IAAIm7B,EAAQn7B,EAgBZ,OAdI5C,IACF+9B,EAAQ,SAAUt8B,GAChB,OAAOmB,EAAG8V,KAAK1Y,EAAOyB,EAAMzB,KAI5Bw8B,IACFuB,EAAQvB,EAAQx8B,EAAMO,IAAKA,EAAKw9B,IAG9BA,IAAUn7B,IACZm7B,EAAM1kB,SAAW,kBAAMzW,EAAGyW,aAGrB0kB,KAETD,EAAWv9B,GAAOi0B,GAtBpB,MAAkBz2B,OAAOmF,KAAK26B,GAA9B,eAA2C,IAyB3C,OAAOC,EAgBT,SAASZ,EAAqBrpB,GACxBA,EAAItD,QAAUoE,MAAMC,QAAQf,EAAItD,SAAQsD,EAAItD,MAAQ,CAACsD,EAAItD,QACzDsD,EAAI1K,OAASwL,MAAMC,QAAQf,EAAI1K,QAAO0K,EAAI1K,KAAO,CAAC0K,EAAI1K,OAG5D,SAASg0B,EAAUX,EAAS55B,GAC1B,IAAMm7B,EAAQ,SAAUt8B,GACtB,GAAI+6B,EAAQv5B,UAAUxB,GACpB,OAAOmB,EAAGgW,MAAM9Y,KAAMk+B,YAM1B,OAFAD,EAAM1kB,SAAW,kBAAMzW,EAAGyW,YAEnB0kB,EAGT,SAAShB,EAAgBx8B,GACvB,MAAe,MAAXA,EAAI,KACI,UAARA,GAA2B,SAARA,GAA0B,eAARA,IAE7B,aAARA,GAA8B,YAARA,GAA6B,aAARA,GAA8B,cAARA,IAOvE,SAASs8B,EAAUoB,EAAMC,GACvB,cAAkBngC,OAAOmF,KAAKg7B,GAA9B,eAAoC,CAA/B,IAAM39B,EAAG,KACZ09B,EAAK19B,GAAO,GAAG6jB,OAAO6Z,EAAK19B,IAAQ,GAAI29B,EAAI39B,O,qDCvO/CxC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,E,IAEZggC,E,mEACJ,c,sBAEA,c,uBAEA,WACE,MAAM,IAAIh9B,MAAM,mD,wBAGlB,SAAWX,EAAMU,GAAwB,IAAnBC,EAAmB,uDAAX0B,UAC5B,OAAO,IAAI1B,EAAMD,O,KAKrBjD,EAAQE,QAAUggC","file":"static/js/vendors-runtime-traverse.283b9b21.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar t = require(\"@babel/types\");\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar t = require(\"@babel/types\");\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = require(\"@babel/types\");\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    callee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    callee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = require(\"@babel/types\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = require(\"@babel/types\");\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = require(\"@babel/types\");\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar t = require(\"@babel/types\");\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}