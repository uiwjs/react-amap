{"version":3,"sources":["../../node_modules/@babel/traverse/lib/cache.js","../../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../../node_modules/@babel/traverse/lib/scope/index.js","../../node_modules/@babel/traverse/lib/scope/binding.js","../../node_modules/@babel/traverse/lib/visitors.js","../../node_modules/@babel/traverse/lib/context.js","../../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../../node_modules/@babel/traverse/lib/path/ancestry.js","../../node_modules/@babel/traverse/lib/path/inference/index.js","../../node_modules/@babel/traverse/lib/path/inference/inferers.js","../../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../../node_modules/@babel/traverse/lib/path/replacement.js","../../node_modules/@babel/traverse/lib/path/evaluation.js","../../node_modules/@babel/traverse/lib/path/conversion.js","../../node_modules/@babel/traverse/lib/path/introspection.js","../../node_modules/@babel/traverse/lib/path/context.js","../../node_modules/@babel/traverse/lib/path/removal.js","../../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../../node_modules/@babel/traverse/lib/path/modification.js","../../node_modules/@babel/traverse/lib/path/lib/hoister.js","../../node_modules/@babel/traverse/lib/path/family.js","../../node_modules/@babel/traverse/lib/path/comments.js","../../node_modules/@babel/traverse/lib/hub.js","../../node_modules/@babel/traverse/lib/index.js","../../node_modules/@babel/traverse/lib/path/index.js"],"names":["Object","defineProperty","exports","value","clear","clearPath","clearScope","scope","path","WeakMap","Var","User","Statement","SpreadProperty","Scope","RestProperty","ReferencedMemberExpression","ReferencedIdentifier","Referenced","Pure","NumericLiteralTypeAnnotation","Generated","ForAwaitStatement","Flow","Expression","ExistentialTypeParam","BlockScoped","BindingIdentifier","_t","require","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isScope","isStatement","isVar","isVariableDeclaration","isCompatTag","react","types","checkPath","opts","node","parent","name","parentPath","grandparent","left","init","isReferencedIdentifier","loc","isUser","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await","default","_renamer","_index","_binding","_globals","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","parts","type","source","specifiers","length","declaration","local","push","object","property","callee","properties","argument","key","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","declar","get","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","declarations","decl","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","this","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","hub","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","buildError","TypeError","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","label","isLabeledStatement","registerLabel","declare","specifier","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","superClass","body","method","right","elements","elem","prop","computed","tag","quasi","expressions","val","crawl","create","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","declarator","pop","Error","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","indexOf","explode","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","verify","virtualTypes","DEPRECATED_KEYS","FLIPPED_ALIAS_KEYS","TYPES","nodeType","shouldIgnoreKey","split","fns","__esModule","obj","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","deprecatedKey","trace","alias","existing","assign","_verified","validateVisitorMethods","visitorKey","concat","fn","oldVisitor","newVisitor","Array","isArray","newFn","call","toString","apply","arguments","dest","src","_path","VISITOR_KEYS","TraversalContext","queue","priorityQueue","listKey","container","notPriority","shouldVisit","visitQueue","visited","WeakSet","stop","resync","contexts","pushContext","add","popContext","nodes","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","assignmentExpression","toExpression","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","findParent","getAncestry","paths","getDeepestCommonAncestorFrom","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestries","ancestry","first","depthLoop","shouldMatch","getEarliestCommonAncestorFrom","deepest","earliest","parentKey","p","getStatementParent","isFile","inType","candidateTypes","isAncestor","maybeDescendant","isDescendant","maybeAncestor","_getTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","anyTypeAnnotation","voidTypeAnnotation","typeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","getTypeAnnotation","delete","baseTypeStrictlyMatches","rightArg","isAnyTypeAnnotation","isFlowBaseAnnotation","couldBeBaseType","isUnionTypeAnnotation","type2","_isBaseType","isTypeAnnotation","isBaseType","baseName","soft","genericName","isGenericTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isVoidTypeAnnotation","ArrayExpression","BinaryExpression","NUMBER_BINARY_OPERATORS","numberTypeAnnotation","BOOLEAN_BINARY_OPERATORS","booleanTypeAnnotation","unionTypeAnnotation","BooleanLiteral","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","ConditionalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","genericTypeAnnotation","enumerable","_infererReference","LogicalExpression","NewExpression","NullLiteral","nullLiteralTypeAnnotation","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","VariableDeclarator","_type","isCallExpression","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","typeValue","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_replaceWith","_pathCache$get2","inList","validate","debug","replaceExpressionWithStatements","nodesAsSequenceExpression","toSequenceExpression","replaceWith","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","arrowFunctionToExpression","newCallee","needToAwaitFunction","hasType","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_verifyNodeList","_containerInsertAfter","remove","replaceWithMultiple","replacement","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","oldNode","inheritsComments","removeComments","setScope","requeue","_pathCache$get","inheritLeadingComments","inheritTrailingComments","insertAfter","replaceWithSourceString","_parser","parse","err","message","_codeFrame","codeFrameColumns","start","line","column","code","removeProperties","evaluate","confident","deoptPath","seen","evaluateCached","undefined","deopt","evaluateTruthy","res","VALID_CALLEES","INVALID_METHODS","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","context","func","global","_evaluate","raw","str","cooked","expr","String","allowInsertArrow","specCompliant","noNewArrows","buildCodeFrameError","hoistFunctionEnvironment","thisBinding","fnPath","checkBinding","objectExpression","thisExpression","_helperFunctionName","arrowFunctionToShadowed","bodyNode","statements","stringPath","setup","toComputedKey","stringLiteral","unwrapFunctionEnvironment","_helperEnvironmentVisitor","_visitors","binaryExpression","conditionalExpression","jsxIdentifier","metaProperty","restElement","sequenceExpression","spreadElement","_super","super","getSuperCallsVisitor","child","allSuperCalls","arrowParent","thisEnvFn","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","superBinding","getSuperBinding","superCall","argumentsBinding","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","assignSuperThisVisitor","supers","argsBinding","propName","fnBody","argsList","valueIdent","cacheKey","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","Identifier","curr","MetaProperty","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","_resolve","dangerous","ret","isTypeCastExpression","targetKey","targetName","match","isnt","isNaN","isFor","equals","getSource","getCode","isCompletionRecord","allowInsideFunction","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isType","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","pattern","allowPartial","_matchesPattern","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","willIMaybeExecuteBefore","isExecutionUncertain","maxIndex","_call","then","_traverseFlags","_getQueueContexts","_resyncKey","setKey","_resyncList","newContainer","_resyncParent","_resyncRemoved","_markRemoved","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","setContext","pathToQueue","maybeQueue","skipKeys","_this$node","noScope","getScope","shouldSkip","SHOULD_SKIP","SHOULD_STOP","currentContext","shouldStop","restoreContext","_assertUnremoved","_callRemovalHooks","_removalHooks","hooks","REMOVED","_remove","splice","updateSiblingKeys","_removeFromScope","removeBinding","_this$opts","shareCommentsWithSiblings","self","isWhile","isSwitchCase","_containerInsert","from","to","getSibling","_containerInsertBefore","msg","hoist","hoister","_hoister","run","nodes_","isJSXElement","assertExpression","temp","shouldInsertCurrentNode","insertBefore","verifiedNodes","fromIndex","incrementBy","_t2","jsxExpressionContainer","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","_getKey","_","_getPattern","part","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","getBindingIdentifierPaths","duplicates","outerOnly","search","shift","_getBindingIdentifiers","_ids","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","r","getNextSibling","getOpposite","getOuterBindingIdentifierPaths","_getOuterBindingIdentifiers","getPrevSibling","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","addComment","content","_addComment","addComments","comments","_addComments","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","Hub","_hub","_scope","_context","cache","traverseFast","_default","hasDenylistedType","cheap","clearNode","tree","denylistTypes","_debug","t","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","def","SyntaxError","enabled","getPathLocation","v","targetNode","prototype","typeKey","virtualType"],"mappings":"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","file":"static/js/vendors-runtime-traverse.86e68385.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.merge = merge;\nexports.verify = verify;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  DEPRECATED_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  TYPES\n} = _t;\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.find = find;\nexports.findParent = findParent;\nexports.getAncestry = getAncestry;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.inType = inType;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\n\nvar _t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createFlowUnionType,\n  createTSUnionType,\n  createTypeAnnotationBasedOnTypeof,\n  createUnionTypeAnnotation,\n  isTSTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(\"+\", identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports._resolve = _resolve;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.equals = equals;\nexports.getSource = getSource;\nexports.has = has;\nexports.is = void 0;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.isNodeType = isNodeType;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.matchesPattern = matchesPattern;\nexports.referencesImport = referencesImport;\nexports.resolve = resolve;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\n\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._call = _call;\nexports._getQueueContexts = _getQueueContexts;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncParent = _resyncParent;\nexports._resyncRemoved = _resyncRemoved;\nexports.call = call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.requeue = requeue;\nexports.resync = resync;\nexports.setContext = setContext;\nexports.setKey = setKey;\nexports.setScope = setScope;\nexports.setup = setup;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.visit = visit;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction restoreContext(path, context) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  const currentContext = this.context;\n\n  if (this.shouldSkip || this.call(\"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  restoreContext(this, currentContext);\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  restoreContext(this, currentContext);\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._assertUnremoved = _assertUnremoved;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._markRemoved = _markRemoved;\nexports._remove = _remove;\nexports._removeFromScope = _removeFromScope;\nexports.remove = remove;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addComment = addComment;\nexports.addComments = addComments;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar _t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;"],"sourceRoot":""}