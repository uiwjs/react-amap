{"version":3,"file":"static/js/micromark-vendor.a9c7ecfb.chunk.js","mappings":"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","sources":["../../node_modules/micromark/lib/preprocess.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/setext-underline.js","../../node_modules/remark/node_modules/micromark/dist/initialize/document.js","../../node_modules/remark/node_modules/micromark/dist/util/combine-extensions.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/definition.js","../../node_modules/remark/node_modules/micromark/dist/character/markdown-space.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/heading-atx.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/label-end.js","../../node_modules/remark/node_modules/micromark/dist/parse.js","../../node_modules/remark/node_modules/micromark/dist/postprocess.js","../../node_modules/remark/node_modules/micromark/dist/util/miniflat.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/content.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/code-fenced.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/thematic-break.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/partial-blank-line.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/block-quote.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/line-ending.js","../../node_modules/remark/node_modules/micromark/dist/character/unicode-whitespace.js","../../node_modules/remark/node_modules/micromark/dist/util/size-chunks.js","../../node_modules/remark/node_modules/micromark/dist/util/regex-check.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/code-indented.js","../../node_modules/remark/node_modules/micromark/dist/util/serialize-chunks.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/label-start-image.js","../../node_modules/remark/node_modules/micromark/dist/util/resolve-all.js","../../node_modules/remark/node_modules/micromark/dist/preprocess.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/code-text.js","../../node_modules/remark/node_modules/micromark/dist/constant/assign.js","../../node_modules/remark/node_modules/micromark/dist/util/create-tokenizer.js","../../node_modules/remark/node_modules/micromark/dist/util/prefix-size.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/factory-destination.js","../../node_modules/remark/node_modules/micromark/dist/constant/unicode-punctuation-regex.js","../../node_modules/remark/node_modules/micromark/dist/initialize/text.js","../../node_modules/remark/node_modules/micromark/dist/constant/html-block-names.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/factory-title.js","../../node_modules/remark/node_modules/micromark/dist/constant/has-own-property.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/html-text.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-atext.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/hard-break-escape.js","../../node_modules/remark/node_modules/micromark/dist/character/unicode-punctuation.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/html-flow.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-alpha.js","../../node_modules/remark/node_modules/micromark/dist/util/subtokenize.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/autolink.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/factory-whitespace.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/label-start-link.js","../../node_modules/remark/node_modules/micromark/dist/util/classify-character.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/list.js","../../node_modules/remark/node_modules/micromark/dist/constructs.js","../../node_modules/micromark/lib/initialize/content.js","../../node_modules/micromark/lib/initialize/document.js","../../node_modules/micromark/lib/initialize/flow.js","../../node_modules/micromark/lib/initialize/text.js","../../node_modules/micromark/lib/constructs.js","../../node_modules/micromark/lib/create-tokenizer.js","../../node_modules/micromark/lib/parse.js","../../node_modules/remark/node_modules/micromark/dist/util/safe-from-int.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/character-escape.js","../../node_modules/remark/node_modules/micromark/dist/constant/splice.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/factory-space.js","../../node_modules/remark/node_modules/micromark/dist/character/markdown-line-ending-or-space.js","../../node_modules/remark/node_modules/micromark/dist/initialize/flow.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/attention.js","../../node_modules/remark/node_modules/micromark/dist/util/move-point.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/factory-label.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-punctuation.js","../../node_modules/remark/node_modules/micromark/dist/util/normalize-identifier.js","../../node_modules/remark/node_modules/micromark/dist/character/markdown-line-ending.js","../../node_modules/remark/node_modules/micromark/dist/util/slice-chunks.js","../../node_modules/remark/node_modules/micromark/dist/util/chunked-splice.js","../../node_modules/remark/node_modules/micromark/dist/constant/from-char-code.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-control.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-digit.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-hex-digit.js","../../node_modules/remark/node_modules/micromark/dist/util/shallow.js","../../node_modules/remark/node_modules/micromark/dist/tokenize/character-reference.js","../../node_modules/remark/node_modules/micromark/dist/character/ascii-alphanumeric.js","../../node_modules/micromark/lib/postprocess.js","../../node_modules/remark/node_modules/micromark/dist/constant/html-raw-names.js","../../node_modules/remark/node_modules/micromark/dist/initialize/content.js","../../node_modules/remark/node_modules/micromark/dist/util/chunked-push.js"],"sourcesContent":["/**\n * @import {Chunk, Code, Encoding, Value} from 'micromark-util-types'\n */\n\n/**\n * @callback Preprocessor\n *   Preprocess a value.\n * @param {Value} value\n *   Value.\n * @param {Encoding | null | undefined} [encoding]\n *   Encoding when `value` is a typed array (optional).\n * @param {boolean | null | undefined} [end=false]\n *   Whether this is the last chunk (default: `false`).\n * @returns {Array<Chunk>}\n *   Chunks.\n */\n\nconst search = /[\\0\\t\\n\\r]/g;\n\n/**\n * @returns {Preprocessor}\n *   Preprocess a value.\n */\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean | undefined} */\n  let start = true;\n  /** @type {boolean | undefined} */\n  let atCarriageReturn;\n  return preprocessor;\n\n  /** @type {Preprocessor} */\n  // eslint-disable-next-line complexity\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = [];\n    /** @type {RegExpMatchArray | null} */\n    let match;\n    /** @type {number} */\n    let next;\n    /** @type {number} */\n    let startPosition;\n    /** @type {number} */\n    let endPosition;\n    /** @type {Code} */\n    let code;\n    value = buffer + (typeof value === 'string' ? value.toString() : new TextDecoder(encoding || undefined).decode(value));\n    startPosition = 0;\n    buffer = '';\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++;\n      }\n      start = undefined;\n    }\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5);\n          atCarriageReturn = undefined;\n        }\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n        switch (code) {\n          case 0:\n            {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n          case 9:\n            {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n              while (column++ < next) chunks.push(-1);\n              break;\n            }\n          case 10:\n            {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n      startPosition = endPosition + 1;\n    }\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5);\n      if (buffer) chunks.push(buffer);\n      chunks.push(null);\n    }\n    return chunks;\n  }\n}","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar shallow = require('../util/shallow.js')\nvar factorySpace = require('./factory-space.js')\n\nvar setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length\n  var content\n  var text\n  var definition\n  var heading // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  heading = {\n    type: 'setextHeading',\n    start: shallow(events[text][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = shallow(events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var marker\n  var paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!self.lazy && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = setextUnderline\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('../tokenize/factory-space.js')\nvar partialBlankLine = require('../tokenize/partial-blank-line.js')\n\nvar tokenize = initializeDocument\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n}\nvar lazyFlowConstruct = {\n  tokenize: tokenizeLazyFlow\n}\n\nfunction initializeDocument(effects) {\n  var self = this\n  var stack = []\n  var continued = 0\n  var inspectConstruct = {\n    tokenize: tokenizeInspect,\n    partial: true\n  }\n  var inspectResult\n  var childFlow\n  var childToken\n  return start\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1]\n      return effects.attempt(\n        stack[continued][0].continuation,\n        documentContinue,\n        documentContinued\n      )(code)\n    }\n\n    return documentContinued(code)\n  }\n\n  function documentContinue(code) {\n    continued++\n    return start(code)\n  }\n\n  function documentContinued(code) {\n    // If we’re in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code)\n    }\n\n    self.interrupt =\n      childFlow &&\n      childFlow.currentConstruct &&\n      childFlow.currentConstruct.interruptible\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState])\n    self.containerState = undefined\n    return documentContinued(code)\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'))\n      return flowStart(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      continueFlow(effects.exit('chunkFlow'))\n      return effects.check(inspectConstruct, documentAfterPeek)\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(\n      inspectResult.continued,\n      inspectResult && inspectResult.flowEnd\n    )\n    continued = 0\n    return start(code)\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.lazy = inspectResult && inspectResult.lazy\n    childFlow.defineSkip(token.start)\n    childFlow.write(self.sliceStream(token))\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length // Close the flow.\n\n    if (childFlow && end) {\n      childFlow.write([null])\n      childToken = childFlow = undefined\n    } // Exit open containers.\n\n    while (index-- > size) {\n      self.containerState = stack[index][1]\n      stack[index][0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0\n    inspectResult = {}\n    return inspectStart\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1]\n        return effects.attempt(\n          stack[subcontinued][0].continuation,\n          inspectContinue,\n          inspectLess\n        )(code)\n      } // If we’re continued but in a concrete flow, we can’t have more\n      // containers.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true\n        return inspectDone(code)\n      }\n\n      self.interrupt =\n        childFlow.currentConstruct && childFlow.currentConstruct.interruptible\n      self.containerState = {}\n      return effects.attempt(\n        containerConstruct,\n        inspectFlowEnd,\n        inspectDone\n      )(code)\n    }\n\n    function inspectContinue(code) {\n      subcontinued++\n      return self.containerState._closeFlow\n        ? inspectFlowEnd(code)\n        : inspectStart(code)\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {}\n        return effects.attempt(\n          containerConstruct,\n          inspectFlowEnd, // Maybe flow, or a blank line?\n          effects.attempt(\n            lazyFlowConstruct,\n            inspectFlowEnd,\n            effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)\n          )\n        )(code)\n      } // Otherwise we’re interrupting.\n\n      return inspectFlowEnd(code)\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length\n      inspectResult.lazy = true\n      inspectResult.flowContinue = true\n      return inspectDone(code)\n    } // We’re done with flow if we have more containers, or an interruption.\n\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true\n      return inspectDone(code)\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued\n      self.interrupt = self.containerState = undefined\n      return ok(code)\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.lazy(this.parser.constructs.flow, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nvar hasOwnProperty = require('../constant/has-own-property.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar miniflat = require('./miniflat.js')\n\nfunction combineExtensions(extensions) {\n  var all = {}\n  var index = -1\n\n  while (++index < extensions.length) {\n    extension(all, extensions[index])\n  }\n\n  return all\n}\n\nfunction extension(all, extension) {\n  var hook\n  var left\n  var right\n  var code\n\n  for (hook in extension) {\n    left = hasOwnProperty.call(all, hook) ? all[hook] : (all[hook] = {})\n    right = extension[hook]\n\n    for (code in right) {\n      left[code] = constructs(\n        miniflat(right[code]),\n        hasOwnProperty.call(left, code) ? left[code] : []\n      )\n    }\n  }\n}\n\nfunction constructs(list, existing) {\n  var index = -1\n  var before = []\n\n  while (++index < list.length) {\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  chunkedSplice(existing, 0, 0, before)\n  return existing\n}\n\nmodule.exports = combineExtensions\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar normalizeIdentifier = require('../util/normalize-identifier.js')\nvar factoryDestination = require('./factory-destination.js')\nvar factoryLabel = require('./factory-label.js')\nvar factorySpace = require('./factory-space.js')\nvar factoryWhitespace = require('./factory-whitespace.js')\nvar factoryTitle = require('./factory-title.js')\n\nvar definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\nvar titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  var self = this\n  var identifier\n  return start\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (self.parser.defined.indexOf(identifier) < 0) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n\nmodule.exports = definition\n","'use strict'\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\nmodule.exports = markdownSpace\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar factorySpace = require('./factory-space.js')\n\nvar headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\nfunction resolveHeadingAtx(events, context) {\n  var contentEnd = events.length - 2\n  var contentStart = 3\n  var content\n  var text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  var self = this\n  var size = 0\n  return start\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n\nmodule.exports = headingAtx\n","'use strict'\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar chunkedPush = require('../util/chunked-push.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar normalizeIdentifier = require('../util/normalize-identifier.js')\nvar resolveAll = require('../util/resolve-all.js')\nvar shallow = require('../util/shallow.js')\nvar factoryDestination = require('./factory-destination.js')\nvar factoryLabel = require('./factory-label.js')\nvar factoryTitle = require('./factory-title.js')\nvar factoryWhitespace = require('./factory-whitespace.js')\n\nvar labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\nvar resourceConstruct = {\n  tokenize: tokenizeResource\n}\nvar fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\nvar collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1\n  var token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      !token._used &&\n      (token.type === 'labelImage' ||\n        token.type === 'labelLink' ||\n        token.type === 'labelEnd')\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length\n  var offset = 0\n  var group\n  var label\n  var text\n  var token\n  var open\n  var close\n  var media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: shallow(events[open][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  }\n  label = {\n    type: 'label',\n    start: shallow(events[open][1].start),\n    end: shallow(events[close][1].end)\n  }\n  text = {\n    type: 'labelText',\n    start: shallow(events[open + offset + 2][1].end),\n    end: shallow(events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = chunkedPush(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = chunkedPush(media, [['enter', text, context]]) // Between.\n\n  media = chunkedPush(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = chunkedPush(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = chunkedPush(media, events.slice(close + 1)) // Media close.\n\n  media = chunkedPush(media, [['exit', group, context]])\n  chunkedSplice(events, open, events.length, media)\n  return events\n}\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var labelStart\n  var defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // It’s a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined =\n      self.parser.defined.indexOf(\n        normalizeIdentifier(\n          self.sliceSerialize({\n            start: labelStart.end,\n            end: self.now()\n          })\n        )\n      ) > -1\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      3\n    )(code)\n  }\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  function afterLabel(code) {\n    return self.parser.defined.indexOf(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    ) < 0\n      ? nok(code)\n      : ok(code)\n  }\n}\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = labelEnd\n","'use strict'\n\nvar content = require('./initialize/content.js')\nvar document = require('./initialize/document.js')\nvar flow = require('./initialize/flow.js')\nvar text = require('./initialize/text.js')\nvar combineExtensions = require('./util/combine-extensions.js')\nvar createTokenizer = require('./util/create-tokenizer.js')\nvar miniflat = require('./util/miniflat.js')\nvar constructs = require('./constructs.js')\n\nfunction parse(options) {\n  var settings = options || {}\n  var parser = {\n    defined: [],\n    constructs: combineExtensions(\n      [constructs].concat(miniflat(settings.extensions))\n    ),\n    content: create(content),\n    document: create(document),\n    flow: create(flow),\n    string: create(text.string),\n    text: create(text.text)\n  }\n  return parser\n\n  function create(initializer) {\n    return creator\n\n    function creator(from) {\n      return createTokenizer(parser, initializer, from)\n    }\n  }\n}\n\nmodule.exports = parse\n","'use strict'\n\nvar subtokenize = require('./util/subtokenize.js')\n\nfunction postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n\n  return events\n}\n\nmodule.exports = postprocess\n","'use strict'\n\nfunction miniflat(value) {\n  return value === null || value === undefined\n    ? []\n    : 'length' in value\n    ? value\n    : [value]\n}\n\nmodule.exports = miniflat\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar subtokenize = require('../util/subtokenize.js')\nvar factorySpace = require('./factory-space.js')\n\n// No name because it must not be turned off.\nvar content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent,\n  interruptible: true,\n  lazy: true\n}\nvar continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n} // Content is transparent: it’s parsed right now. That way, definitions are also\n// parsed right now: before text in paragraphs (specifically, media) are parsed.\n\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n\nfunction tokenizeContent(effects, ok) {\n  var previous\n  return start\n\n  function start(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return data(code)\n  }\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous = previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous: previous\n    })\n    return data\n  }\n}\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  var self = this\n  return startLookahead\n\n  function startLookahead(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ||\n      prefixSize(self.events, 'linePrefix') < 4\n    ) {\n      return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n    }\n\n    return ok(code)\n  }\n}\n\nmodule.exports = content\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar factorySpace = require('./factory-space.js')\n\nvar codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  var self = this\n  var closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  var initialPrefix = prefixSize(this.events, 'linePrefix')\n  var sizeOpen = 0\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : content(code)\n  }\n\n  function content(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return effects.attempt(\n        closingFenceConstruct,\n        after,\n        initialPrefix\n          ? factorySpace(effects, content, 'linePrefix', initialPrefix + 1)\n          : content\n      )\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return content(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    var size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\nmodule.exports = codeFenced\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  var size = 0\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('thematicBreak')\n    marker = code\n    return atBreak(code)\n  }\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    if (size < 3 || (code !== null && !markdownLineEnding(code))) {\n      return nok(code)\n    }\n\n    effects.exit('thematicBreak')\n    return ok(code)\n  }\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit('thematicBreakSequence')\n    return atBreak(code)\n  }\n}\n\nmodule.exports = thematicBreak\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\n\nvar partialBlankLine = {\n  tokenize: tokenizePartialBlankLine,\n  partial: true\n}\n\nfunction tokenizePartialBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n\nmodule.exports = partialBlankLine\n","'use strict'\n\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit: exit\n}\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    if (code === 62) {\n      if (!self.containerState.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        self.containerState.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n\nmodule.exports = blockQuote\n","'use strict'\n\nvar factorySpace = require('./factory-space.js')\n\nvar lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n\nmodule.exports = lineEnding\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar unicodeWhitespace = regexCheck(/\\s/)\n\nmodule.exports = unicodeWhitespace\n","'use strict'\n\n// Counts tabs based on their expanded size, and CR+LF as one character.\n\nfunction sizeChunks(chunks) {\n  var index = -1\n  var size = 0\n\n  while (++index < chunks.length) {\n    size += typeof chunks[index] === 'string' ? chunks[index].length : 1\n  }\n\n  return size\n}\n\nmodule.exports = sizeChunks\n","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction regexCheck(regex) {\n  return check\n\n  function check(code) {\n    return regex.test(fromCharCode(code))\n  }\n}\n\nmodule.exports = regexCheck\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar factorySpace = require('./factory-space.js')\n\nvar codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented,\n  resolve: resolveCodeIndented\n}\nvar indentedContentConstruct = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n\nfunction resolveCodeIndented(events, context) {\n  var code = {\n    type: 'codeIndented',\n    start: events[0][1].start,\n    end: events[events.length - 1][1].end\n  }\n  chunkedSplice(events, 0, 0, [['enter', code, context]])\n  chunkedSplice(events, events.length, 0, [['exit', code, context]])\n  return events\n}\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  return effects.attempt(indentedContentConstruct, afterPrefix, nok)\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n}\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  var self = this\n  return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)\n\n  function afterPrefix(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)\n    }\n\n    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)\n  }\n}\n\nmodule.exports = codeIndented\n","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction serializeChunks(chunks) {\n  var index = -1\n  var result = []\n  var chunk\n  var value\n  var atTab\n\n  while (++index < chunks.length) {\n    chunk = chunks[index]\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else if (chunk === -5) {\n      value = '\\r'\n    } else if (chunk === -4) {\n      value = '\\n'\n    } else if (chunk === -3) {\n      value = '\\r' + '\\n'\n    } else if (chunk === -2) {\n      value = '\\t'\n    } else if (chunk === -1) {\n      if (atTab) continue\n      value = ' '\n    } else {\n      // Currently only replacement character.\n      value = fromCharCode(chunk)\n    }\n\n    atTab = chunk === -2\n    result.push(value)\n  }\n\n  return result.join('')\n}\n\nmodule.exports = serializeChunks\n","'use strict'\n\nvar labelEnd = require('./label-end.js')\n\nvar labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    /* c8 ignore next */\n    return code === 94 &&\n      /* c8 ignore next */\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? /* c8 ignore next */\n        nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = labelStartImage\n","'use strict'\n\nfunction resolveAll(constructs, events, context) {\n  var called = []\n  var index = -1\n  var resolve\n\n  while (++index < constructs.length) {\n    resolve = constructs[index].resolveAll\n\n    if (resolve && called.indexOf(resolve) < 0) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n\nmodule.exports = resolveAll\n","'use strict'\n\nvar search = /[\\0\\t\\n\\r]/g\n\nfunction preprocess() {\n  var start = true\n  var column = 1\n  var buffer = ''\n  var atCarriageReturn\n  return preprocessor\n\n  function preprocessor(value, encoding, end) {\n    var chunks = []\n    var match\n    var next\n    var startPosition\n    var endPosition\n    var code\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition = match ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        if (code === 0) {\n          chunks.push(65533)\n          column++\n        } else if (code === 9) {\n          next = Math.ceil(column / 4) * 4\n          chunks.push(-2)\n\n          while (column++ < next) chunks.push(-1)\n        } else if (code === 10) {\n          chunks.push(-4)\n          column = 1\n        } // Must be carriage return.\n        else {\n          atCarriageReturn = true\n          column = 1\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5)\n      if (buffer) chunks.push(buffer)\n      chunks.push(null)\n    }\n\n    return chunks\n  }\n}\n\nmodule.exports = preprocess\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n}\n\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4\n  var headEnterIndex = 3\n  var index\n  var enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type =\n          'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  var sizeOpen = 0\n  var size\n  var token\n  return start\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n\nmodule.exports = codeText\n","'use strict'\n\nvar assign = Object.assign\n\nmodule.exports = assign\n","'use strict'\n\nvar assign = require('../constant/assign.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar chunkedPush = require('./chunked-push.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar miniflat = require('./miniflat.js')\nvar resolveAll = require('./resolve-all.js')\nvar serializeChunks = require('./serialize-chunks.js')\nvar shallow = require('./shallow.js')\nvar sliceChunks = require('./slice-chunks.js')\n\n// Create a tokenizer.\n// Tokenizers deal with one type of data (e.g., containers, flow, text).\n// The parser is the object dealing with it all.\n// `initialize` works like other constructs, except that only its `tokenize`\n// function is used, in which case it doesn’t receive an `ok` or `nok`.\n// `from` can be given to set the point before the first character, although\n// when further lines are indented, they must be set with `defineSkip`.\nfunction createTokenizer(parser, initialize, from) {\n  var point = from\n    ? shallow(from)\n    : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }\n  var columnStart = {}\n  var resolveAllConstructs = []\n  var chunks = []\n  var stack = []\n\n  var effects = {\n    consume: consume,\n    enter: enter,\n    exit: exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    }),\n    lazy: constructFactory(onsuccessfulcheck, {\n      lazy: true\n    })\n  } // State and tools for resolving and serializing.\n\n  var context = {\n    previous: null,\n    events: [],\n    parser: parser,\n    sliceStream: sliceStream,\n    sliceSerialize: sliceSerialize,\n    now: now,\n    defineSkip: skip,\n    write: write\n  } // The state function.\n\n  var state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  } // Store where we are in the input stream.\n\n  point._index = 0\n  point._bufferIndex = -1\n  return context\n\n  function write(slice) {\n    chunks = chunkedPush(chunks, slice)\n    main() // Exit if we’re not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n\n    addResult(initialize, 0) // Otherwise, resolve, and exit.\n\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  } //\n  // Tools.\n  //\n\n  function sliceSerialize(token) {\n    return serializeChunks(sliceStream(token))\n  }\n\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  function now() {\n    return shallow(point)\n  }\n\n  function skip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  } //\n  // State management.\n  //\n  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n  // `consume`).\n  // Here is where we walk through the chunks, which either include strings of\n  // several characters, or numerical character codes.\n  // The reason to do this in a loop instead of a call is so the stack can\n  // drain.\n\n  function main() {\n    var chunkIndex\n    var chunk\n\n    while (point._index < chunks.length) {\n      chunk = chunks[point._index] // If we’re in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  } // Deal with one code.\n\n  function go(code) {\n    state = state(code)\n  } // Move a character forward.\n\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    } // Not in a string chunk.\n\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++ // At end of string chunk.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    } // Expose the previous character.\n\n    context.previous = code // Mark as consumed.\n  } // Start a token.\n\n  function enter(type, fields) {\n    var token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  } // Stop a token.\n\n  function exit(type) {\n    var token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  } // Use results.\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  } // Discard results.\n\n  function onsuccessfulcheck(construct, info) {\n    info.restore()\n  } // Factory to attempt/check/interrupt.\n\n  function constructFactory(onreturn, fields) {\n    return hook // Handle either an object mapping codes to constructs, a list of\n    // constructs, or a single construct.\n\n    function hook(constructs, returnState, bogusState) {\n      var listOfConstructs\n      var constructIndex\n      var currentConstruct\n      var info\n      return constructs.tokenize || 'length' in constructs\n        ? handleListOfConstructs(miniflat(constructs))\n        : handleMapOfConstructs\n\n      function handleMapOfConstructs(code) {\n        if (code in constructs || null in constructs) {\n          return handleListOfConstructs(\n            constructs.null\n              ? /* c8 ignore next */\n                miniflat(constructs[code]).concat(miniflat(constructs.null))\n              : constructs[code]\n          )(code)\n        }\n\n        return bogusState(code)\n      }\n\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        return handleConstruct(list[constructIndex])\n      }\n\n      function handleConstruct(construct) {\n        return start\n\n        function start(code) {\n          // To do: not nede to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.indexOf(construct.name) > -1\n          ) {\n            return nok()\n          }\n\n          return construct.tokenize.call(\n            fields ? assign({}, context, fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      function ok(code) {\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      function nok(code) {\n        info.restore()\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n\n        return bogusState\n      }\n    }\n  }\n\n  function addResult(construct, from) {\n    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {\n      resolveAllConstructs.push(construct)\n    }\n\n    if (construct.resolve) {\n      chunkedSplice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  function store() {\n    var startPoint = now()\n    var startPrevious = context.previous\n    var startCurrentConstruct = context.currentConstruct\n    var startEventsIndex = context.events.length\n    var startStack = Array.from(stack)\n    return {\n      restore: restore,\n      from: startEventsIndex\n    }\n\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\nmodule.exports = createTokenizer\n","'use strict'\n\nvar sizeChunks = require('./size-chunks.js')\n\nfunction prefixSize(events, type) {\n  var tail = events[events.length - 1]\n  if (!tail || tail[1].type !== type) return 0\n  return sizeChunks(tail[2].sliceStream(tail[1]))\n}\n\nmodule.exports = prefixSize\n","'use strict'\n\nvar asciiControl = require('../character/ascii-control.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\n// eslint-disable-next-line max-params\nfunction destinationFactory(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  var limit = max || Infinity\n  var balance = 0\n  return start\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (asciiControl(code) || code === 41) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationRaw(code)\n  }\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationEnclosed(code)\n  }\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed\n  }\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString')\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === 92 ? destinationRawEscape : destinationRaw\n  }\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n\nmodule.exports = destinationFactory\n","'use strict'\n\n// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nvar unicodePunctuation = /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\nmodule.exports = unicodePunctuation\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar assign = require('../constant/assign.js')\nvar shallow = require('../util/shallow.js')\n\nvar text = initializeFactory('text')\nvar string = initializeFactory('string')\nvar resolver = {\n  resolveAll: createResolver()\n}\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  function initializeText(effects) {\n    var self = this\n    var constructs = this.parser.constructs[field]\n    var text = effects.attempt(constructs, start, notText)\n    return start\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n\n    function atBreak(code) {\n      var list = constructs[code]\n      var index = -1\n\n      if (code === null) {\n        return true\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (\n            !list[index].previous ||\n            list[index].previous.call(self, self.previous)\n          ) {\n            return true\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  function resolveAllText(events, context) {\n    var index = -1\n    var enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we can’t hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1\n  var chunks\n  var data\n  var chunk\n  var index\n  var bufferIndex\n  var size\n  var tabs\n  var token\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      data = events[eventIndex - 1][1]\n      chunks = context.sliceStream(data)\n      index = chunks.length\n      bufferIndex = -1\n      size = 0\n      tabs = undefined\n\n      while (index--) {\n        chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1);\n        else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        }\n        data.end = shallow(token.start)\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n\nexports.resolver = resolver\nexports.string = string\nexports.text = text\n","'use strict'\n\n// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.\nvar basics = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\nmodule.exports = basics\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\n\nfunction titleFactory(effects, ok, nok, type, markerType, stringType) {\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    marker = code === 40 ? 41 : code\n    return atFirstTitleBreak\n  }\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atTitleBreak(code)\n  }\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return atFirstTitleBreak(marker)\n    }\n\n    if (code === null) {\n      return nok(code)\n    } // Note: blank lines can’t exist in content.\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atTitleBreak, 'linePrefix')\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return title(code)\n  }\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atTitleBreak(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? titleEscape : title\n  }\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return title\n    }\n\n    return title(code)\n  }\n}\n\nmodule.exports = titleFactory\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = own\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  var self = this\n  var marker\n  var buffer\n  var index\n  var returnState\n  return start\n\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  function tagClose(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  function tagOpen(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  function tagOpenAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  } // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(\n      effects,\n      afterPrefix,\n      'linePrefix',\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )\n  }\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = htmlText\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\nmodule.exports = asciiAtext\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\nvar hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('escapeMarker')\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = hardBreakEscape\n","'use strict'\n\nvar unicodePunctuationRegex = require('../constant/unicode-punctuation-regex.js')\nvar regexCheck = require('../util/regex-check.js')\n\n// In fact adds to the bundle size.\n\nvar unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\nmodule.exports = unicodePunctuation\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar fromCharCode = require('../constant/from-char-code.js')\nvar htmlBlockNames = require('../constant/html-block-names.js')\nvar htmlRawNames = require('../constant/html-raw-names.js')\nvar partialBlankLine = require('./partial-blank-line.js')\n\nvar htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\nvar nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n}\n\nfunction resolveToHtmlFlow(events) {\n  var index = events.length\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  var self = this\n  var kind\n  var startTag\n  var buffer\n  var index\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      kind = 3 // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code)\n      kind = 2\n      return commentOpenInside\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      kind = 5\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = 4\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== 47 &&\n        startTag &&\n        htmlRawNames.indexOf(buffer.toLowerCase()) > -1\n      ) {\n        kind = 1\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {\n        kind = 6\n\n        if (code === 47) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = 7 // Do not support complete HTML when interrupting.\n\n      return self.interrupt\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  function completeAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = undefined\n    return completeAttributeValueUnquoted(code)\n  }\n\n  function completeAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === null || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData')\n    return htmlContinueStart(code)\n  }\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return htmlContinueStart\n    }\n\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      buffer += fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    return continuation(code)\n  }\n\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  function done(code) {\n    effects.exit('htmlFlow')\n    return ok(code)\n  }\n}\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.exit('htmlFlowData')\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    return effects.attempt(partialBlankLine, ok, nok)\n  }\n}\n\nmodule.exports = htmlFlow\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAlpha = regexCheck(/[A-Za-z]/)\n\nmodule.exports = asciiAlpha\n","'use strict'\n\nvar assign = require('../constant/assign.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar shallow = require('./shallow.js')\n\nfunction subtokenize(events) {\n  var jumps = {}\n  var index = -1\n  var event\n  var lineIndex\n  var otherIndex\n  var otherEvent\n  var parameters\n  var subevents\n  var more\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1].isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    } // Exit.\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  return !more\n}\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1]\n  var context = events[eventIndex][2]\n  var startPosition = eventIndex - 1\n  var startPositions = []\n  var tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  var childEvents = tokenizer.events\n  var jumps = []\n  var gaps = {}\n  var stream\n  var previous\n  var index\n  var entered\n  var end\n  var adjust // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (token) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== token) {\n      // Empty.\n    }\n\n    startPositions.push(startPosition)\n\n    if (!token._tokenizer) {\n      stream = context.sliceStream(token)\n\n      if (!token.next) {\n        stream.push(null)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(token.start)\n      }\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    } // Unravel the next token.\n\n    previous = token\n    token = token.next\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  token = previous\n  index = childEvents.length\n\n  while (index--) {\n    // Make sure we’ve at least seen something (final eol is part of the last\n    // token).\n    if (childEvents[index][0] === 'enter') {\n      entered = true\n    } else if (\n      // Find a void token that includes a break.\n      entered &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      add(childEvents.slice(index + 1, end))\n      // Help GC.\n      token._tokenizer = token.next = undefined\n      token = token.previous\n      end = index + 1\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = token._tokenizer = token.next = undefined // Do head:\n\n  add(childEvents.slice(0, end))\n  index = -1\n  adjust = 0\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n\n  function add(slice) {\n    var start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    chunkedSplice(events, start, 2, slice)\n  }\n}\n\nmodule.exports = subtokenize\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar asciiAtext = require('../character/ascii-atext.js')\nvar asciiControl = require('../character/ascii-control.js')\n\nvar autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  var size = 1\n  return start\n\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      return end(code)\n    }\n\n    if (code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n\n  function emailValue(code) {\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      effects.consume(code)\n      return code === 45 ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n\n  function end(code) {\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.exit('autolink')\n    return ok\n  }\n}\n\nmodule.exports = autolink\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nfunction whitespaceFactory(effects, ok) {\n  var seen\n  return start\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n\nmodule.exports = whitespaceFactory\n","'use strict'\n\nvar labelEnd = require('./label-end.js')\n\nvar labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  function after(code) {\n    /* c8 ignore next */\n    return code === 94 &&\n      /* c8 ignore next */\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? /* c8 ignore next */\n        nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = labelStartLink\n","'use strict'\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar unicodePunctuation = require('../character/unicode-punctuation.js')\nvar unicodeWhitespace = require('../character/unicode-whitespace.js')\n\n// Classify whether a character is unicode whitespace, unicode punctuation, or\n// anything else.\n// Used for attention (emphasis, strong), whose sequences can open or close\n// based on the class of surrounding characters.\nfunction classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n\nmodule.exports = classifyCharacter\n","'use strict'\n\nvar asciiDigit = require('../character/ascii-digit.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar sizeChunks = require('../util/size-chunks.js')\nvar factorySpace = require('./factory-space.js')\nvar partialBlankLine = require('./partial-blank-line.js')\nvar thematicBreak = require('./thematic-break.js')\n\nvar list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\nvar listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\nvar indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this\n  var initialSize = prefixSize(self.events, 'linePrefix')\n  var size = 0\n  return start\n\n  function start(code) {\n    var kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      partialBlankLine, // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))\n    return ok(code)\n  }\n}\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(partialBlankLine, onBlank, notBlank)\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'listItemIndent') ===\n      self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4 + 1\n  )\n\n  function afterPrefix(code) {\n    return markdownSpace(code) ||\n      !prefixSize(self.events, 'listItemPrefixWhitespace')\n      ? nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = list\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar text$1 = require('./initialize/text.js')\nvar attention = require('./tokenize/attention.js')\nvar autolink = require('./tokenize/autolink.js')\nvar blockQuote = require('./tokenize/block-quote.js')\nvar characterEscape = require('./tokenize/character-escape.js')\nvar characterReference = require('./tokenize/character-reference.js')\nvar codeFenced = require('./tokenize/code-fenced.js')\nvar codeIndented = require('./tokenize/code-indented.js')\nvar codeText = require('./tokenize/code-text.js')\nvar definition = require('./tokenize/definition.js')\nvar hardBreakEscape = require('./tokenize/hard-break-escape.js')\nvar headingAtx = require('./tokenize/heading-atx.js')\nvar htmlFlow = require('./tokenize/html-flow.js')\nvar htmlText = require('./tokenize/html-text.js')\nvar labelEnd = require('./tokenize/label-end.js')\nvar labelStartImage = require('./tokenize/label-start-image.js')\nvar labelStartLink = require('./tokenize/label-start-link.js')\nvar lineEnding = require('./tokenize/line-ending.js')\nvar list = require('./tokenize/list.js')\nvar setextUnderline = require('./tokenize/setext-underline.js')\nvar thematicBreak = require('./tokenize/thematic-break.js')\n\nvar document = {\n  42: list,\n  // Asterisk\n  43: list,\n  // Plus sign\n  45: list,\n  // Dash\n  48: list,\n  // 0\n  49: list,\n  // 1\n  50: list,\n  // 2\n  51: list,\n  // 3\n  52: list,\n  // 4\n  53: list,\n  // 5\n  54: list,\n  // 6\n  55: list,\n  // 7\n  56: list,\n  // 8\n  57: list,\n  // 9\n  62: blockQuote // Greater than\n}\nvar contentInitial = {\n  91: definition // Left square bracket\n}\nvar flowInitial = {\n  '-2': codeIndented,\n  // Horizontal tab\n  '-1': codeIndented,\n  // Virtual space\n  32: codeIndented // Space\n}\nvar flow = {\n  35: headingAtx,\n  // Number sign\n  42: thematicBreak,\n  // Asterisk\n  45: [setextUnderline, thematicBreak],\n  // Dash\n  60: htmlFlow,\n  // Less than\n  61: setextUnderline,\n  // Equals to\n  95: thematicBreak,\n  // Underscore\n  96: codeFenced,\n  // Grave accent\n  126: codeFenced // Tilde\n}\nvar string = {\n  38: characterReference,\n  // Ampersand\n  92: characterEscape // Backslash\n}\nvar text = {\n  '-5': lineEnding,\n  // Carriage return\n  '-4': lineEnding,\n  // Line feed\n  '-3': lineEnding,\n  // Carriage return + line feed\n  33: labelStartImage,\n  // Exclamation mark\n  38: characterReference,\n  // Ampersand\n  42: attention,\n  // Asterisk\n  60: [autolink, htmlText],\n  // Less than\n  91: labelStartLink,\n  // Left square bracket\n  92: [hardBreakEscape, characterEscape],\n  // Backslash\n  93: labelEnd,\n  // Right square bracket\n  95: attention,\n  // Underscore\n  96: codeText // Grave accent\n}\nvar insideSpan = {\n  null: [attention, text$1.resolver]\n}\nvar disable = {\n  null: []\n}\n\nexports.contentInitial = contentInitial\nexports.disable = disable\nexports.document = document\nexports.flow = flow\nexports.flowInitial = flowInitial\nexports.insideSpan = insideSpan\nexports.string = string\nexports.text = text\n","/**\n * @import {\n *   InitialConstruct,\n *   Initializer,\n *   State,\n *   TokenizeContext,\n *   Token\n * } from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {InitialConstruct} */\nexport const content = {\n  tokenize: initializeContent\n};\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Initializer}\n *   Content.\n */\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\n  /** @type {Token} */\n  let previous;\n  return contentStart;\n\n  /** @type {State} */\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return factorySpace(effects, contentStart, \"linePrefix\");\n  }\n\n  /** @type {State} */\n  function paragraphInitial(code) {\n    effects.enter(\"paragraph\");\n    return lineStart(code);\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    const token = effects.enter(\"chunkText\", {\n      contentType: \"text\",\n      previous\n    });\n    if (previous) {\n      previous.next = token;\n    }\n    previous = token;\n    return data(code);\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (code === null) {\n      effects.exit(\"chunkText\");\n      effects.exit(\"paragraph\");\n      effects.consume(code);\n      return;\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      effects.exit(\"chunkText\");\n      return lineStart;\n    }\n\n    // Data.\n    effects.consume(code);\n    return data;\n  }\n}","/**\n * @import {\n *   Construct,\n *   ContainerState,\n *   InitialConstruct,\n *   Initializer,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Tokenizer,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n *   Construct and its state.\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\n/** @type {InitialConstruct} */\nexport const document = {\n  tokenize: initializeDocument\n};\n\n/** @type {Construct} */\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n};\n\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\nfunction initializeDocument(effects) {\n  const self = this;\n  /** @type {Array<StackItem>} */\n  const stack = [];\n  let continued = 0;\n  /** @type {TokenizeContext | undefined} */\n  let childFlow;\n  /** @type {Token | undefined} */\n  let childToken;\n  /** @type {number} */\n  let lineStartOffset;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued];\n      self.containerState = item[1];\n      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n    }\n\n    // Done.\n    return checkNewContainers(code);\n  }\n\n  /** @type {State} */\n  function documentContinue(code) {\n    continued++;\n\n    // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined;\n      if (childFlow) {\n        closeFlow();\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n      const indexBeforeExits = self.events.length;\n      let indexBeforeFlow = indexBeforeExits;\n      /** @type {Point | undefined} */\n      let point;\n\n      // Find the flow chunk.\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === \"chunkFlow\") {\n          point = self.events[indexBeforeFlow][1].end;\n          break;\n        }\n      }\n      exitContainers(continued);\n\n      // Fix positions.\n      let index = indexBeforeExits;\n      while (index < self.events.length) {\n        self.events[index][1].end = {\n          ...point\n        };\n        index++;\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));\n\n      // Discard the duplicate exits.\n      self.events.length = index;\n      return checkNewContainers(code);\n    }\n    return start(code);\n  }\n\n  /** @type {State} */\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code);\n      }\n\n      // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code);\n      }\n\n      // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n      self.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);\n    }\n\n    // Check if there is a new container.\n    self.containerState = {};\n    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n  }\n\n  /** @type {State} */\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow();\n    exitContainers(continued);\n    return documentContinued(code);\n  }\n\n  /** @type {State} */\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length;\n    lineStartOffset = self.now().offset;\n    return flowStart(code);\n  }\n\n  /** @type {State} */\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {};\n    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n  }\n\n  /** @type {State} */\n  function containerContinue(code) {\n    continued++;\n    stack.push([self.currentConstruct, self.containerState]);\n    // Try another.\n    return documentContinued(code);\n  }\n\n  /** @type {State} */\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow();\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter(\"chunkFlow\", {\n      _tokenizer: childFlow,\n      contentType: \"flow\",\n      previous: childToken\n    });\n    return flowContinue(code);\n  }\n\n  /** @type {State} */\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit(\"chunkFlow\"), true);\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      writeToChild(effects.exit(\"chunkFlow\"));\n      // Get ready for the next line.\n      continued = 0;\n      self.interrupt = undefined;\n      return start;\n    }\n    effects.consume(code);\n    return flowContinue;\n  }\n\n  /**\n   * @param {Token} token\n   *   Token.\n   * @param {boolean | undefined} [endOfFile]\n   *   Whether the token is at the end of the file (default: `false`).\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function writeToChild(token, endOfFile) {\n    const stream = self.sliceStream(token);\n    if (endOfFile) stream.push(null);\n    token.previous = childToken;\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.defineSkip(token.start);\n    childFlow.write(stream);\n\n    // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length;\n      while (index--) {\n        if (\n        // The token starts before the line ending…\n        childFlow.events[index][1].start.offset < lineStartOffset && (\n        // …and either is not ended yet…\n        !childFlow.events[index][1].end ||\n        // …or ends after it.\n        childFlow.events[index][1].end.offset > lineStartOffset)) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return;\n        }\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n      const indexBeforeExits = self.events.length;\n      let indexBeforeFlow = indexBeforeExits;\n      /** @type {boolean | undefined} */\n      let seen;\n      /** @type {Point | undefined} */\n      let point;\n\n      // Find the previous chunk (the one before the lazy line).\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === \"chunkFlow\") {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end;\n            break;\n          }\n          seen = true;\n        }\n      }\n      exitContainers(continued);\n\n      // Fix positions.\n      index = indexBeforeExits;\n      while (index < self.events.length) {\n        self.events[index][1].end = {\n          ...point\n        };\n        index++;\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits));\n\n      // Discard the duplicate exits.\n      self.events.length = index;\n    }\n  }\n\n  /**\n   * @param {number} size\n   *   Size.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exitContainers(size) {\n    let index = stack.length;\n\n    // Exit open containers.\n    while (index-- > size) {\n      const entry = stack[index];\n      self.containerState = entry[1];\n      entry[0].exit.call(self, effects);\n    }\n    stack.length = size;\n  }\n  function closeFlow() {\n    childFlow.write([null]);\n    childToken = undefined;\n    childFlow = undefined;\n    self.containerState._closeFlow = undefined;\n  }\n}\n\n/**\n * @this {TokenizeContext}\n *   Context.\n * @type {Tokenizer}\n *   Tokenizer.\n */\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n\n  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), \"linePrefix\", this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n}","/**\n * @import {\n *   InitialConstruct,\n *   Initializer,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\n\nimport { blankLine, content } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {InitialConstruct} */\nexport const flow = {\n  tokenize: initializeFlow\n};\n\n/**\n * @this {TokenizeContext}\n *   Self.\n * @type {Initializer}\n *   Initializer.\n */\nfunction initializeFlow(effects) {\n  const self = this;\n  const initial = effects.attempt(\n  // Try to parse a blank line.\n  blankLine, atBlankEnding,\n  // Try to parse initial flow (essentially, only code).\n  effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), \"linePrefix\")));\n  return initial;\n\n  /** @type {State} */\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n    effects.enter(\"lineEndingBlank\");\n    effects.consume(code);\n    effects.exit(\"lineEndingBlank\");\n    self.currentConstruct = undefined;\n    return initial;\n  }\n\n  /** @type {State} */\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code);\n      return;\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    self.currentConstruct = undefined;\n    return initial;\n  }\n}","/**\n * @import {\n *   Code,\n *   InitialConstruct,\n *   Initializer,\n *   Resolver,\n *   State,\n *   TokenizeContext\n * } from 'micromark-util-types'\n */\n\nexport const resolver = {\n  resolveAll: createResolver()\n};\nexport const string = initializeFactory('string');\nexport const text = initializeFactory('text');\n\n/**\n * @param {'string' | 'text'} field\n *   Field.\n * @returns {InitialConstruct}\n *   Construct.\n */\nfunction initializeFactory(field) {\n  return {\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined),\n    tokenize: initializeText\n  };\n\n  /**\n   * @this {TokenizeContext}\n   *   Context.\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this;\n    const constructs = this.parser.constructs[field];\n    const text = effects.attempt(constructs, start, notText);\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter(\"data\");\n      effects.consume(code);\n      return data;\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit(\"data\");\n        return text(code);\n      }\n\n      // Data.\n      effects.consume(code);\n      return data;\n    }\n\n    /**\n     * @param {Code} code\n     *   Code.\n     * @returns {boolean}\n     *   Whether the code is a break.\n     */\n    function atBreak(code) {\n      if (code === null) {\n        return true;\n      }\n      const list = constructs[code];\n      let index = -1;\n      if (list) {\n        // Always populated by defaults.\n\n        while (++index < list.length) {\n          const item = list[index];\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n *   Resolver.\n * @returns {Resolver}\n *   Resolver.\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1;\n    /** @type {number | undefined} */\n    let enter;\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === \"data\") {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== \"data\") {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n        enter = undefined;\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === \"lineEnding\") && events[eventIndex - 1][1].type === \"data\") {\n      const data = events[eventIndex - 1][1];\n      const chunks = context.sliceStream(data);\n      let index = chunks.length;\n      let bufferIndex = -1;\n      let size = 0;\n      /** @type {boolean | undefined} */\n      let tabs;\n      while (index--) {\n        const chunk = chunks[index];\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n\n      // Allow final trailing whitespace.\n      if (context._contentTypeTextTrailing && eventIndex === events.length) {\n        size = 0;\n      }\n      if (size) {\n        const token = {\n          type: eventIndex === events.length || tabs || size < 2 ? \"lineSuffix\" : \"hardBreakTrailing\",\n          start: {\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex,\n            _index: data.start._index + index,\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size\n          },\n          end: {\n            ...data.end\n          }\n        };\n        data.end = {\n          ...token.start\n        };\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n      eventIndex++;\n    }\n  }\n  return events;\n}","/**\n * @import {Extension} from 'micromark-util-types'\n */\n\nimport { attention, autolink, blockQuote, characterEscape, characterReference, codeFenced, codeIndented, codeText, definition, hardBreakEscape, headingAtx, htmlFlow, htmlText, labelEnd, labelStartImage, labelStartLink, lineEnding, list, setextUnderline, thematicBreak } from 'micromark-core-commonmark';\nimport { resolver as resolveText } from './initialize/text.js';\n\n/** @satisfies {Extension['document']} */\nexport const document = {\n  [42]: list,\n  [43]: list,\n  [45]: list,\n  [48]: list,\n  [49]: list,\n  [50]: list,\n  [51]: list,\n  [52]: list,\n  [53]: list,\n  [54]: list,\n  [55]: list,\n  [56]: list,\n  [57]: list,\n  [62]: blockQuote\n};\n\n/** @satisfies {Extension['contentInitial']} */\nexport const contentInitial = {\n  [91]: definition\n};\n\n/** @satisfies {Extension['flowInitial']} */\nexport const flowInitial = {\n  [-2]: codeIndented,\n  [-1]: codeIndented,\n  [32]: codeIndented\n};\n\n/** @satisfies {Extension['flow']} */\nexport const flow = {\n  [35]: headingAtx,\n  [42]: thematicBreak,\n  [45]: [setextUnderline, thematicBreak],\n  [60]: htmlFlow,\n  [61]: setextUnderline,\n  [95]: thematicBreak,\n  [96]: codeFenced,\n  [126]: codeFenced\n};\n\n/** @satisfies {Extension['string']} */\nexport const string = {\n  [38]: characterReference,\n  [92]: characterEscape\n};\n\n/** @satisfies {Extension['text']} */\nexport const text = {\n  [-5]: lineEnding,\n  [-4]: lineEnding,\n  [-3]: lineEnding,\n  [33]: labelStartImage,\n  [38]: characterReference,\n  [42]: attention,\n  [60]: [autolink, htmlText],\n  [91]: labelStartLink,\n  [92]: [hardBreakEscape, characterEscape],\n  [93]: labelEnd,\n  [95]: attention,\n  [96]: codeText\n};\n\n/** @satisfies {Extension['insideSpan']} */\nexport const insideSpan = {\n  null: [attention, resolveText]\n};\n\n/** @satisfies {Extension['attentionMarkers']} */\nexport const attentionMarkers = {\n  null: [42, 95]\n};\n\n/** @satisfies {Extension['disable']} */\nexport const disable = {\n  null: []\n};","/**\n * @import {\n *   Chunk,\n *   Code,\n *   ConstructRecord,\n *   Construct,\n *   Effects,\n *   InitialConstruct,\n *   ParseContext,\n *   Point,\n *   State,\n *   TokenizeContext,\n *   Token\n * } from 'micromark-util-types'\n */\n\n/**\n * @callback Restore\n *   Restore the state.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef Info\n *   Info.\n * @property {Restore} restore\n *   Restore.\n * @property {number} from\n *   From.\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n *   Construct.\n * @param {Info} info\n *   Info.\n * @returns {undefined}\n *   Nothing.\n */\n\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n *   Parser.\n * @param {InitialConstruct} initialize\n *   Construct.\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n *   Point (optional).\n * @returns {TokenizeContext}\n *   Context.\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = {\n    _bufferIndex: -1,\n    _index: 0,\n    line: from && from.line || 1,\n    column: from && from.column || 1,\n    offset: from && from.offset || 0\n  };\n  /** @type {Record<string, number>} */\n  const columnStart = {};\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = [];\n  /** @type {Array<Chunk>} */\n  let chunks = [];\n  /** @type {Array<Token>} */\n  let stack = [];\n  /** @type {boolean | undefined} */\n  let consumed = true;\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    consume,\n    enter,\n    exit,\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  };\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    code: null,\n    containerState: {},\n    defineSkip,\n    events: [],\n    now,\n    parser,\n    previous: null,\n    sliceSerialize,\n    sliceStream,\n    write\n  };\n\n  /**\n   * The state function.\n   *\n   * @type {State | undefined}\n   */\n  let state = initialize.tokenize.call(context, effects);\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode;\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize);\n  }\n  return context;\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice);\n    main();\n\n    // Exit if we’re not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== null) {\n      return [];\n    }\n    addResult(initialize, 0);\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context);\n    return context.events;\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs);\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token);\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {\n      _bufferIndex,\n      _index,\n      line,\n      column,\n      offset\n    } = point;\n    return {\n      _bufferIndex,\n      _index,\n      line,\n      column,\n      offset\n    };\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column;\n    accountForPotentialSkip();\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex;\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index];\n\n      // If we’re in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index;\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0;\n        }\n        while (point._index === chunkIndex && point._bufferIndex < chunk.length) {\n          go(chunk.charCodeAt(point._bufferIndex));\n        }\n      } else {\n        go(chunk);\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   *   Code.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function go(code) {\n    consumed = undefined;\n    expectedCode = code;\n    state = state(code);\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++;\n      point.column = 1;\n      point.offset += code === -3 ? 2 : 1;\n      accountForPotentialSkip();\n    } else if (code !== -1) {\n      point.column++;\n      point.offset++;\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++;\n    } else {\n      point._bufferIndex++;\n\n      // At end of string chunk.\n      if (point._bufferIndex ===\n      // Points w/ non-negative `_bufferIndex` reference\n      // strings.\n      /** @type {string} */\n      chunks[point._index].length) {\n        point._bufferIndex = -1;\n        point._index++;\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code;\n\n    // Mark as consumed.\n    consumed = true;\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {};\n    token.type = type;\n    token.start = now();\n    context.events.push(['enter', token, context]);\n    stack.push(token);\n    return token;\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    const token = stack.pop();\n    token.end = now();\n    context.events.push(['exit', token, context]);\n    return token;\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from);\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore();\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   *   Callback.\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   *   Fields.\n   */\n  function constructFactory(onreturn, fields) {\n    return hook;\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | ConstructRecord | Construct} constructs\n     *   Constructs.\n     * @param {State} returnState\n     *   State.\n     * @param {State | undefined} [bogusState]\n     *   State.\n     * @returns {State}\n     *   State.\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {ReadonlyArray<Construct>} */\n      let listOfConstructs;\n      /** @type {number} */\n      let constructIndex;\n      /** @type {Construct} */\n      let currentConstruct;\n      /** @type {Info} */\n      let info;\n      return Array.isArray(constructs) ? /* c8 ignore next 1 */\n      handleListOfConstructs(constructs) : 'tokenize' in constructs ?\n      // Looks like a construct.\n      handleListOfConstructs([(/** @type {Construct} */constructs)]) : handleMapOfConstructs(constructs);\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       *   Constructs.\n       * @returns {State}\n       *   State.\n       */\n      function handleMapOfConstructs(map) {\n        return start;\n\n        /** @type {State} */\n        function start(code) {\n          const left = code !== null && map[code];\n          const all = code !== null && map.null;\n          const list = [\n          // To do: add more extension tests.\n          /* c8 ignore next 2 */\n          ...(Array.isArray(left) ? left : left ? [left] : []), ...(Array.isArray(all) ? all : all ? [all] : [])];\n          return handleListOfConstructs(list)(code);\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ReadonlyArray<Construct>} list\n       *   Constructs.\n       * @returns {State}\n       *   State.\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list;\n        constructIndex = 0;\n        if (list.length === 0) {\n          return bogusState;\n        }\n        return handleConstruct(list[constructIndex]);\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       *   Construct.\n       * @returns {State}\n       *   State.\n       */\n      function handleConstruct(construct) {\n        return start;\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store();\n          currentConstruct = construct;\n          if (!construct.partial) {\n            context.currentConstruct = construct;\n          }\n\n          // Always populated by defaults.\n\n          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {\n            return nok(code);\n          }\n          return construct.tokenize.call(\n          // If we do have fields, create an object w/ `context` as its\n          // prototype.\n          // This allows a “live binding”, which is needed for `interrupt`.\n          fields ? Object.assign(Object.create(context), fields) : context, effects, ok, nok)(code);\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        consumed = true;\n        onreturn(currentConstruct, info);\n        return returnState;\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        consumed = true;\n        info.restore();\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex]);\n        }\n        return bogusState;\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   *   Construct.\n   * @param {number} from\n   *   From.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct);\n    }\n    if (construct.resolve) {\n      splice(context.events, from, context.events.length - from, construct.resolve(context.events.slice(from), context));\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context);\n    }\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   *   Info.\n   */\n  function store() {\n    const startPoint = now();\n    const startPrevious = context.previous;\n    const startCurrentConstruct = context.currentConstruct;\n    const startEventsIndex = context.events.length;\n    const startStack = Array.from(stack);\n    return {\n      from: startEventsIndex,\n      restore\n    };\n\n    /**\n     * Restore state.\n     *\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function restore() {\n      point = startPoint;\n      context.previous = startPrevious;\n      context.currentConstruct = startCurrentConstruct;\n      context.events.length = startEventsIndex;\n      stack = startStack;\n      accountForPotentialSkip();\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line];\n      point.offset += columnStart[point.line] - 1;\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {ReadonlyArray<Chunk>} chunks\n *   Chunks.\n * @param {Pick<Token, 'end' | 'start'>} token\n *   Token.\n * @returns {Array<Chunk>}\n *   Chunks.\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index;\n  const startBufferIndex = token.start._bufferIndex;\n  const endIndex = token.end._index;\n  const endBufferIndex = token.end._bufferIndex;\n  /** @type {Array<Chunk>} */\n  let view;\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];\n  } else {\n    view = chunks.slice(startIndex, endIndex);\n    if (startBufferIndex > -1) {\n      const head = view[0];\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex);\n        /* c8 ignore next 4 -- used to be used, no longer */\n      } else {\n        view.shift();\n      }\n    }\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex));\n    }\n  }\n  return view;\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {ReadonlyArray<Chunk>} chunks\n *   Chunks.\n * @param {boolean | undefined} [expandTabs=false]\n *   Whether to expand tabs (default: `false`).\n * @returns {string}\n *   Result.\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1;\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {boolean | undefined} */\n  let atTab;\n  while (++index < chunks.length) {\n    const chunk = chunks[index];\n    /** @type {string} */\n    let value;\n    if (typeof chunk === 'string') {\n      value = chunk;\n    } else switch (chunk) {\n      case -5:\n        {\n          value = \"\\r\";\n          break;\n        }\n      case -4:\n        {\n          value = \"\\n\";\n          break;\n        }\n      case -3:\n        {\n          value = \"\\r\" + \"\\n\";\n          break;\n        }\n      case -2:\n        {\n          value = expandTabs ? \" \" : \"\\t\";\n          break;\n        }\n      case -1:\n        {\n          if (!expandTabs && atTab) continue;\n          value = \" \";\n          break;\n        }\n      default:\n        {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk);\n        }\n    }\n    atTab = chunk === -2;\n    result.push(value);\n  }\n  return result.join('');\n}","/**\n * @import {\n *   Create,\n *   FullNormalizedExtension,\n *   InitialConstruct,\n *   ParseContext,\n *   ParseOptions\n * } from 'micromark-util-types'\n */\n\nimport { combineExtensions } from 'micromark-util-combine-extensions';\nimport { content } from './initialize/content.js';\nimport { document } from './initialize/document.js';\nimport { flow } from './initialize/flow.js';\nimport { string, text } from './initialize/text.js';\nimport * as defaultConstructs from './constructs.js';\nimport { createTokenizer } from './create-tokenizer.js';\n\n/**\n * @param {ParseOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ParseContext}\n *   Parser.\n */\nexport function parse(options) {\n  const settings = options || {};\n  const constructs = /** @type {FullNormalizedExtension} */\n  combineExtensions([defaultConstructs, ...(settings.extensions || [])]);\n\n  /** @type {ParseContext} */\n  const parser = {\n    constructs,\n    content: create(content),\n    defined: [],\n    document: create(document),\n    flow: create(flow),\n    lazy: {},\n    string: create(string),\n    text: create(text)\n  };\n  return parser;\n\n  /**\n   * @param {InitialConstruct} initial\n   *   Construct to start with.\n   * @returns {Create}\n   *   Create a tokenizer.\n   */\n  function create(initial) {\n    return creator;\n    /** @type {Create} */\n    function creator(from) {\n      return createTokenizer(parser, initial, from);\n    }\n  }\n}","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction safeFromInt(value, base) {\n  var code = parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.\n    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) || // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 || // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n\n  return fromCharCode(code)\n}\n\nmodule.exports = safeFromInt\n","'use strict'\n\nvar asciiPunctuation = require('../character/ascii-punctuation.js')\n\nvar characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return open\n  }\n\n  function open(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = characterEscape\n","'use strict'\n\nvar splice = [].splice\n\nmodule.exports = splice\n","'use strict'\n\nvar markdownSpace = require('../character/markdown-space.js')\n\nfunction spaceFactory(effects, ok, type, max) {\n  var limit = max ? max - 1 : Infinity\n  var size = 0\n  return start\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n\nmodule.exports = spaceFactory\n","'use strict'\n\nfunction markdownLineEndingOrSpace(code) {\n  return code < 0 || code === 32\n}\n\nmodule.exports = markdownLineEndingOrSpace\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar content = require('../tokenize/content.js')\nvar factorySpace = require('../tokenize/factory-space.js')\nvar partialBlankLine = require('../tokenize/partial-blank-line.js')\n\nvar tokenize = initializeFlow\n\nfunction initializeFlow(effects) {\n  var self = this\n  var initial = effects.attempt(\n    // Try to parse a blank line.\n    partialBlankLine,\n    atBlankEnding, // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        'linePrefix'\n      )\n    )\n  )\n  return initial\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    self.currentConstruct = undefined\n    return initial\n  }\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nvar chunkedPush = require('../util/chunked-push.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar classifyCharacter = require('../util/classify-character.js')\nvar movePoint = require('../util/move-point.js')\nvar resolveAll = require('../util/resolve-all.js')\nvar shallow = require('../util/shallow.js')\n\nvar attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n\nfunction resolveAllAttention(events, context) {\n  var index = -1\n  var open\n  var group\n  var text\n  var openingSequence\n  var closingSequence\n  var use\n  var nextEvents\n  var offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: movePoint(shallow(events[open][1].end), -use),\n            end: shallow(events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: shallow(events[index][1].start),\n            end: movePoint(shallow(events[index][1].start), use)\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: shallow(events[open][1].end),\n            end: shallow(events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: shallow(openingSequence.start),\n            end: shallow(closingSequence.end)\n          }\n          events[open][1].end = shallow(openingSequence.start)\n          events[index][1].start = shallow(closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = chunkedPush(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = chunkedPush(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = chunkedPush(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = chunkedPush(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = chunkedPush(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeAttention(effects, ok) {\n  var before = classifyCharacter(this.previous)\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    var token\n    var after\n    var open\n    var close\n\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    token = effects.exit('attentionSequence')\n    after = classifyCharacter(code)\n    open = !after || (after === 2 && before)\n    close = !before || (before === 2 && after)\n    token._open = marker === 42 ? open : open && (before || !close)\n    token._close = marker === 42 ? close : close && (after || !open)\n    return ok(code)\n  }\n}\n\nmodule.exports = attention\n","'use strict'\n\n// chunks (replacement characters, tabs, or line endings).\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n  return point\n}\n\nmodule.exports = movePoint\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\n\n// eslint-disable-next-line max-params\nfunction labelFactory(effects, ok, nok, type, markerType, stringType) {\n  var self = this\n  var size = 0\n  var data\n  return start\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  function atBreak(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      (code === 93 && !data) ||\n      /* c8 ignore next */\n      (code === 94 &&\n        /* c8 ignore next */\n        !size &&\n        /* c8 ignore next */\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\n      size > 999\n    ) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return label(code)\n  }\n\n  function label(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    data = data || !markdownSpace(code)\n    return code === 92 ? labelEscape : label\n  }\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n}\n\nmodule.exports = labelFactory\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\nmodule.exports = asciiPunctuation\n","'use strict'\n\nfunction normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered “uppercase”, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no object method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n\nmodule.exports = normalizeIdentifier\n","'use strict'\n\nfunction markdownLineEnding(code) {\n  return code < -2\n}\n\nmodule.exports = markdownLineEnding\n","'use strict'\n\nfunction sliceChunks(chunks, token) {\n  var startIndex = token.start._index\n  var startBufferIndex = token.start._bufferIndex\n  var endIndex = token.end._index\n  var endBufferIndex = token.end._bufferIndex\n  var view\n\n  if (startIndex === endIndex) {\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      view[0] = view[0].slice(startBufferIndex)\n    }\n\n    if (endBufferIndex > 0) {\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n\nmodule.exports = sliceChunks\n","'use strict'\n\nvar splice = require('../constant/splice.js')\n\n// causes a stack overflow in V8 when trying to insert 100k items for instance.\n\nfunction chunkedSplice(list, start, remove, items) {\n  var end = list.length\n  var chunkStart = 0\n  var parameters // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0 // No need to chunk the items if there’s only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    splice.apply(list, parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      splice.apply(list, parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\nmodule.exports = chunkedSplice\n","'use strict'\n\nvar fromCharCode = String.fromCharCode\n\nmodule.exports = fromCharCode\n","'use strict'\n\n// Note: EOF is seen as ASCII control here, because `null < 32 == true`.\nfunction asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code < 32 || code === 127\n  )\n}\n\nmodule.exports = asciiControl\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiDigit = regexCheck(/\\d/)\n\nmodule.exports = asciiDigit\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\nmodule.exports = asciiHexDigit\n","'use strict'\n\nvar assign = require('../constant/assign.js')\n\nfunction shallow(object) {\n  return assign({}, object)\n}\n\nmodule.exports = shallow\n","'use strict'\n\nvar decodeEntity = require('parse-entities/decode-entity.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar asciiDigit = require('../character/ascii-digit.js')\nvar asciiHexDigit = require('../character/ascii-hex-digit.js')\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {default: e}\n}\n\nvar decodeEntity__default = /*#__PURE__*/ _interopDefaultLegacy(decodeEntity)\n\nvar characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  var self = this\n  var size = 0\n  var max\n  var test\n  return start\n\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n\n  function value(code) {\n    var token\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue')\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeEntity__default['default'](self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = characterReference\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\nmodule.exports = asciiAlphanumeric\n","/**\n * @import {Event} from 'micromark-util-types'\n */\n\nimport { subtokenize } from 'micromark-util-subtokenize';\n\n/**\n * @param {Array<Event>} events\n *   Events.\n * @returns {Array<Event>}\n *   Events.\n */\nexport function postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n  return events;\n}","'use strict'\n\n// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.\nvar raws = ['pre', 'script', 'style', 'textarea']\n\nmodule.exports = raws\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('../tokenize/factory-space.js')\n\nvar tokenize = initializeContent\n\nfunction initializeContent(effects) {\n  var contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  var previous\n  return contentStart\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, contentStart, 'linePrefix')\n  }\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph')\n    return lineStart(code)\n  }\n\n  function lineStart(code) {\n    var token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous: previous\n    })\n\n    if (previous) {\n      previous.next = token\n    }\n\n    previous = token\n    return data(code)\n  }\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText')\n      effects.exit('paragraph')\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit('chunkText')\n      return lineStart\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nvar chunkedSplice = require('./chunked-splice.js')\n\nfunction chunkedPush(list, items) {\n  if (list.length) {\n    chunkedSplice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n\nmodule.exports = chunkedPush\n"],"names":["search","preprocess","atCarriageReturn","column","buffer","start","value","encoding","end","chunks","match","next","startPosition","endPosition","code","toString","TextDecoder","undefined","decode","charCodeAt","length","lastIndex","exec","index","slice","push","Math","ceil","markdownLineEnding","require","shallow","factorySpace","setextUnderline","name","tokenize","effects","ok","nok","marker","paragraph","self","this","events","type","lazy","interrupt","enter","closingSequence","consume","exit","closingSequenceEnd","resolveTo","context","content","text","definition","heading","splice","module","exports","Object","defineProperty","partialBlankLine","inspectResult","childFlow","childToken","stack","continued","inspectConstruct","subcontinued","inspectStart","containerState","attempt","continuation","inspectContinue","inspectLess","currentConstruct","concrete","flowContinue","inspectDone","interruptible","containerConstruct","inspectFlowEnd","_closeFlow","lazyFlowConstruct","check","inspectLazy","flowEnd","partial","documentContinue","documentContinued","flowStart","containerContinue","exitContainers","parser","flow","now","contentType","previous","_tokenizer","continueFlow","documentAfterPeek","token","defineSkip","write","sliceStream","size","call","constructs","document","disable","null","indexOf","hasOwnProperty","chunkedSplice","miniflat","extension","all","hook","left","right","list","existing","before","add","extensions","markdownLineEndingOrSpace","normalizeIdentifier","factoryDestination","factoryLabel","factoryWhitespace","factoryTitle","identifier","labelAfter","sliceSerialize","titleConstruct","after","defined","markdownSpace","headingAtx","fenceOpenInside","headingBreak","sequence","data","resolve","contentEnd","contentStart","chunkedPush","resolveAll","labelEnd","labelStart","_balanced","_inactive","balanced","afterLabelEnd","resourceConstruct","fullReferenceConstruct","collapsedReferenceConstruct","group","label","open","close","media","offset","insideSpan","_used","destinationAfter","between","afterLabel","combineExtensions","createTokenizer","options","concat","create","string","initializer","from","subtokenize","prefixSize","continuationConstruct","contentContinue","prefixed","codeFenced","closingFenceConstruct","closingSequenceStart","sizeOpen","initialPrefix","sequenceOpen","infoOpen","openAfter","info","infoAfter","meta","thematicBreak","atBreak","blockQuote","_container","lineEnding","unicodeWhitespace","regexCheck","fromCharCode","regex","test","codeIndented","indentedContentConstruct","afterPrefix","chunk","atTab","result","join","labelStartImage","called","codeText","openingSequence","gap","tailExitIndex","headEnterIndex","assign","serializeChunks","sliceChunks","initialize","point","line","columnStart","resolveAllConstructs","accountForPotentialSkip","_bufferIndex","_index","fields","pop","constructFactory","construct","addResult","onsuccessfulcheck","main","state","chunkIndex","go","restore","onreturn","returnState","bogusState","listOfConstructs","constructIndex","handleListOfConstructs","handleConstruct","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","Array","store","sizeChunks","tail","asciiControl","literalType","literalMarkerType","rawType","stringType","max","limit","Infinity","balance","destinationEnclosedBefore","destinationRaw","destinationEnclosed","destinationEnclosedEscape","destinationRawEscape","initializeFactory","resolver","createResolver","field","notText","resolveAllLineSuffixes","extraResolver","bufferIndex","tabs","eventIndex","markerType","atFirstTitleBreak","atTitleBreak","title","titleEscape","own","asciiAlpha","asciiAlphanumeric","htmlText","declarationOpen","tagCloseStart","instruction","tagOpen","commentOpen","cdataOpen","declaration","commentStart","commentStartDash","comment","commentClose","atLineEnding","cdata","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","asciiAtext","hardBreakEscape","unicodePunctuationRegex","unicodePunctuation","htmlBlockNames","htmlRawNames","htmlFlow","kind","startTag","declarationStart","continuationDeclarationInside","tagName","commentOpenInside","cdataOpenInside","toLowerCase","basicSelfClosing","completeAttributeNameBefore","completeClosingTagAfter","completeEnd","completeAttributeName","completeAttributeNameAfter","completeAttributeValueBefore","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","continuationCharacterDataInside","continuationAtLineEnding","nextBlankConstruct","htmlContinueStart","done","continuationRawEndTag","subcontent","stream","entered","adjust","startPositions","tokenizer","childEvents","jumps","gaps","isInFirstContentOfListItem","_gfmTasklistFirstContentOfListItem","unshift","event","lineIndex","otherIndex","otherEvent","parameters","subevents","more","_movePreviousLineEndings","autolink","schemeOrEmailAtext","emailAtext","schemeInsideOrEmailAtext","urlInside","emailAtSignOrDot","emailLabel","emailValue","seen","labelStartLink","asciiDigit","initialSize","atMarker","inside","onBlank","listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","furtherBlankLines","notInCurrentItem","indentConstruct","text$1","attention","characterEscape","characterReference","contentInitial","flowInitial","lineStart","lineStartOffset","item","checkNewContainers","closeFlow","indexBeforeExits","indexBeforeFlow","_objectSpread","Boolean","_gfmTableDynamicInterruptHack","thereIsANewContainer","thereIsNoNewContainer","writeToChild","endOfFile","entry","includes","initial","blankLine","afterConstruct","_contentTypeTextTrailing","resolveText","attentionMarkers","consumed","expandTabs","String","expectedCode","startIndex","startBufferIndex","endIndex","endBufferIndex","view","head","shift","_","isArray","map","handleMapOfConstructs","parse","settings","defaultConstructs","base","parseInt","asciiPunctuation","prefix","classifyCharacter","movePoint","_open","_close","use","nextEvents","labelEscape","replace","toUpperCase","remove","items","chunkStart","apply","asciiHexDigit","object","decodeEntity","_interopDefaultLegacy","e","default","decodeEntity__default","numeric","postprocess"],"sourceRoot":""}