{"version":3,"sources":["../node_modules/codemirror/mode/pascal/pascal.js"],"names":["CodeMirror","defineMode","keywords","str","obj","words","split","i","length","atoms","isOperatorChar","tokenBase","stream","state","quote","ch","next","startOfLine","skipToEnd","tokenize","escaped","end","eat","tokenComment","tokenCommentBraces","test","eatWhile","cur","current","propertyIsEnumerable","maybeEnd","startState","token","eatSpace","style","electricChars","defineMIME","mod"],"mappings":"gHAOG,SAAUA,GACX,aAEAA,EAAWC,WAAW,UAAU,WAY9B,IAAIC,EAXJ,SAAeC,GAIb,IAHA,IAAIC,EAAM,GACNC,EAAQF,EAAIG,MAAM,KAEbC,EAAI,EAAGA,EAAIF,EAAMG,SAAUD,EAClCH,EAAIC,EAAME,KAAM,EAGlB,OAAOH,EAGMC,CAAM,w9BACjBI,EAAQ,CACV,MAAQ,GAENC,EAAiB,mBAErB,SAASC,EAAUC,EAAQC,GACzB,IAkDmBC,EAlDfC,EAAKH,EAAOI,OAEhB,GAAU,KAAND,GAAaF,EAAMI,YAErB,OADAL,EAAOM,YACA,OAGT,GAAU,KAANH,GAAmB,KAANA,EAEf,OADAF,EAAMM,UA0CWL,EA1CYC,EA2CxB,SAAUH,EAAQC,GAKvB,IAJA,IACIG,EADAI,GAAU,EAEVC,GAAM,EAEuB,OAAzBL,EAAOJ,EAAOI,SAAiB,CACrC,GAAIA,GAAQF,IAAUM,EAAS,CAC7BC,GAAM,EACN,MAGFD,GAAWA,GAAmB,MAARJ,EAIxB,OADIK,GAAQD,IAASP,EAAMM,SAAW,MAC/B,WAzDAN,EAAMM,SAASP,EAAQC,GAGhC,GAAU,KAANE,GAAaH,EAAOU,IAAI,KAE1B,OADAT,EAAMM,SAAWI,EACVA,EAAaX,EAAQC,GAG9B,GAAU,KAANE,EAEF,OADAF,EAAMM,SAAWK,EACVA,EAAmBZ,EAAQC,GAGpC,GAAI,mBAAmBY,KAAKV,GAC1B,OAAO,KAGT,GAAI,KAAKU,KAAKV,GAEZ,OADAH,EAAOc,SAAS,UACT,SAGT,GAAU,KAANX,GACEH,EAAOU,IAAI,KAEb,OADAV,EAAOM,YACA,UAIX,GAAIR,EAAee,KAAKV,GAEtB,OADAH,EAAOc,SAAShB,GACT,WAGTE,EAAOc,SAAS,WAChB,IAAIC,EAAMf,EAAOgB,UACjB,OAAI1B,EAAS2B,qBAAqBF,GAAa,UAC3ClB,EAAMoB,qBAAqBF,GAAa,OACrC,WAuBT,SAASJ,EAAaX,EAAQC,GAI5B,IAHA,IACIE,EADAe,GAAW,EAGRf,EAAKH,EAAOI,QAAQ,CACzB,GAAU,KAAND,GAAae,EAAU,CACzBjB,EAAMM,SAAW,KACjB,MAGFW,EAAiB,KAANf,EAGb,MAAO,UAGT,SAASS,EAAmBZ,EAAQC,GAGlC,IAFA,IAAIE,EAEGA,EAAKH,EAAOI,QACjB,GAAU,KAAND,EAAW,CACbF,EAAMM,SAAW,KACjB,MAIJ,MAAO,UAIT,MAAO,CACLY,WAAY,WACV,MAAO,CACLZ,SAAU,OAGda,MAAO,SAAepB,EAAQC,GAC5B,GAAID,EAAOqB,WAAY,OAAO,KAC9B,IAAIC,GAASrB,EAAMM,UAAYR,GAAWC,EAAQC,GAClD,OAAkDqB,GAGpDC,cAAe,SAGnBnC,EAAWoC,WAAW,gBAAiB,UA5IrCC,CAAI,EAAQ","file":"static/js/538.a10bbef0.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"pascal\", function () {\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n\n    var keywords = words(\"absolute and array asm begin case const constructor destructor div do \" + \"downto else end file for function goto if implementation in inherited \" + \"inline interface label mod nil not object of operator or packed procedure \" + \"program record reintroduce repeat self set shl shr string then to type \" + \"unit until uses var while with xor as class dispinterface except exports \" + \"finalization finally initialization inline is library on out packed \" + \"property raise resourcestring threadvar try absolute abstract alias \" + \"assembler bitpacked break cdecl continue cppdecl cvar default deprecated \" + \"dynamic enumerator experimental export external far far16 forward generic \" + \"helper implements index interrupt iocheck local message name near \" + \"nodefault noreturn nostackframe oldfpccall otherwise overload override \" + \"pascal platform private protected public published read register \" + \"reintroduce result safecall saveregisters softfloat specialize static \" + \"stdcall stored strict unaligned unimplemented varargs virtual write\");\n    var atoms = {\n      \"null\": true\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"#\" && state.startOfLine) {\n        stream.skipToEnd();\n        return \"meta\";\n      }\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == \"(\" && stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n\n      if (ch == \"{\") {\n        state.tokenize = tokenCommentBraces;\n        return tokenCommentBraces(stream, state);\n      }\n\n      if (/[\\[\\]\\(\\),;\\:\\.]/.test(ch)) {\n        return null;\n      }\n\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w\\.]/);\n        return \"number\";\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_]/);\n      var cur = stream.current();\n      if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return \"variable\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !escaped) state.tokenize = null;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          state.tokenize = null;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenCommentBraces(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"}\") {\n          state.tokenize = null;\n          break;\n        }\n      }\n\n      return \"comment\";\n    } // Interface\n\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: null\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\") return style;\n        return style;\n      },\n      electricChars: \"{}\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-pascal\", \"pascal\");\n});"],"sourceRoot":""}